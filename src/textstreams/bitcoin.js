import { randomItemFromArray, randomLineRepeatedString } from "../utils";

const stream =
  '// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2021 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <fs.h>\n#include <wallet/bdb.h>\n#include <wallet/db.h>\n\n#include <util/strencodings.h>\n#include <util/translation.h>\n\n#include <stdint.h>\n\n#ifndef WIN32\n\n#include <sys/stat.h>\n\n#endif\n\nnamespace wallet {\nnamespace {\n\nvoid CheckUniqueFileid(const BerkeleyEnvironment &env,\n                       const std::string &filename, Db &db,\n                       WalletDatabaseFileId &fileid) {\n  if (env.IsMock()) return;\n\n  int ret = db.get_mpf()->get_fileid(fileid.value);\n  if (ret != 0) {\n    throw std::runtime_error(strprintf(\n        "BerkeleyDatabase: Can\'t open database %s (get_fileid failed with %d)",\n        filename, ret));\n  }\n\n  for (const auto &item : env.m_fileids) {\n    if (fileid == item.second && &fileid != &item.second) {\n      throw std::runtime_error(strprintf(\n          "BerkeleyDatabase: Can\'t open database %s (duplicates fileid %s from %\n          filename,\n          HexStr(item.second.value), item.first));\n    }\n  }\n}\n\nRecursiveMutex cs_db;\nstd::map <std::string, std::weak_ptr<BerkeleyEnvironment>> g_dbenvs\nGUARDED_BY(cs_db); //!< Map from directory name to db environment.\n} // namespace\n\nbool\nWalletDatabaseFileId::operator==(const WalletDatabaseFileId &rhs) const {\nreturn memcmp(value, &rhs.value, sizeof(value)) == 0;\n}\n\nstd::shared_ptr <BerkeleyEnvironment>\nGetBerkeleyEnv(const fs::path &env_directory, bool use_shared_memory) {\nLOCK(cs_db);\nauto inserted = g_dbenvs.emplace(fs::PathToString(env_directory),\n                                 std::weak_ptr<BerkeleyEnvironment>());\nif (inserted.second) {\n  auto env = std::make_shared<BerkeleyEnvironment>(env_directory,\n                                                   use_shared_memory);\n  inserted.first->second = env;\n  return env;\n}\nreturn inserted.first->second.lock();\n}\n\nvoid BerkeleyEnvironment::Close() {\n  if (!fDbEnvInit)\n    return;\n\n  fDbEnvInit = false;\n\n  for (auto &db : m_databases) {\n    BerkeleyDatabase &database = db.second.get();\n    assert(database.m_refcount <= 0);\n    if (database.m_db) {\n      database.m_db->close(0);\n      database.m_db.reset();\n    }\n  }\n\n  FILE *error_file = nullptr;\n  dbenv->get_errfile(&error_file);\n\n  int ret = dbenv->close(0);\n  if (ret != 0)\n    LogPrintf(\n        "BerkeleyEnvironment::Close: Error %d closing database environment: %s\\n\n        ret, DbEnv::strerror(ret));\n  if (!fMockDb)\n    DbEnv((u_int32_t) 0).remove(strPath.c_str(), 0);\n\n  if (error_file) fclose(error_file);\n\n  UnlockDirectory(fs::PathFromString(strPath), ".walletlock");\n}\n\nvoid BerkeleyEnvironment::Reset() {\n  dbenv.reset(new DbEnv(DB_CXX_NO_EXCEPTIONS));\n  fDbEnvInit = false;\n  fMockDb = false;\n}\n\nBerkeleyEnvironment::BerkeleyEnvironment(const fs::path &dir_path,\n                                         bool use_shared_memory) : strPath(\n    fs::PathToString(dir_path)), m_use_shared_memory(\n    use_shared_memory) {\n  Reset();\n}\n\nBerkeleyEnvironment::~BerkeleyEnvironment() {\n  LOCK(cs_db);\n  g_dbenvs.erase(strPath);\n  Close();\n}\n\n//! Construct an in-memory mock Berkeley environment for testing\nBerkeleyEnvironment::BerkeleyEnvironment() : m_use_shared_memory(false) {\n  Reset();\n\n  LogPrint(BCLog::WALLETDB, "BerkeleyEnvironment::MakeMock\\n");\n\n  dbenv->set_cachesize(1, 0, 1);\n  dbenv->set_lg_bsize(10485760 * 4);\n  dbenv->set_lg_max(10485760);\n  dbenv->set_lk_max_locks(10000);\n  dbenv->set_lk_max_objects(10000);\n  dbenv->set_flags(DB_AUTO_COMMIT, 1);\n  dbenv->log_set_config(DB_LOG_IN_MEMORY, 1);\n  int ret = dbenv->open(nullptr,\n                        DB_CREATE |\n                        DB_INIT_LOCK |\n                        DB_INIT_LOG |\n                        DB_INIT_MPOOL |\n                        DB_INIT_TXN |\n                        DB_THREAD |\n                        DB_PRIVATE,\n                        S_IRUSR | S_IWUSR);\n  if (ret > 0) {\n    throw std::runtime_error(strprintf(\n        "BerkeleyEnvironment::MakeMock: Error %d opening database environment.",\n        ret));\n  }\n\n  fDbEnvInit = true;\n  fMockDb = true;\n}\n\nBerkeleyBatch::SafeDbt::SafeDbt() {\n  m_dbt.set_flags(DB_DBT_MALLOC);\n}\n\nBerkeleyBatch::SafeDbt::SafeDbt(void *data, size_t size)\n    : m_dbt(data, size) {\n}\n\nBerkeleyBatch::SafeDbt::~SafeDbt() {\n  if (m_dbt.get_data() != nullptr) {\n    // Clear memory, e.g. in case it was a private key\n    memory_cleanse(m_dbt.get_data(), m_dbt.get_size());\n    // under DB_DBT_MALLOC, data is malloced by the Dbt, but must be\n    // freed by the caller.\n    // https://docs.oracle.com/cd/E17275_01/html/api_reference/C/dbt.html\n    if (m_dbt.get_flags() & DB_DBT_MALLOC) {\n      free(m_dbt.get_data());\n    }\n  }\n}\n\nconst void *BerkeleyBatch::SafeDbt::get_data() const {\n  return m_dbt.get_data();\n}\n\nu_int32_t BerkeleyBatch::SafeDbt::get_size() const {\n  return m_dbt.get_size();\n}\n\nBerkeleyBatch::SafeDbt::operator Dbt *() {\n  return &m_dbt;\n}\n\nbool BerkeleyDatabase::Verify(bilingual_str &errorStr) {\n  fs::path walletDir = env->Directory();\n  fs::path file_path = walletDir / strFile;\n\n  LogPrintf("Using BerkeleyDB version %s\\n", BerkeleyDatabaseVersion());\n  LogPrintf("Using wallet %s\\n", fs::PathToString(file_path));\n\n  if (!env->Open(errorStr)) {\n    return false;\n  }\n\n  if (fs::exists(file_path)) {\n    assert(m_refcount == 0);\n\n    Db db(env->dbenv.get(), 0);\n    int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n    if (result != 0) {\n      errorStr = strprintf(\n          _("%s corrupt. Try using the wallet tool bitcoin-wallet to salvage or \n          fs::quoted(fs::PathToString(file_path)));\n      return false;\n    }\n  }\n  // also return true if files does not exists\n  return true;\n}\n\nvoid BerkeleyEnvironment::CheckpointLSN(const std::string &strFile) {\n  dbenv->txn_checkpoint(0, 0, 0);\n  if (fMockDb)\n    return;\n  dbenv->lsn_reset(strFile.c_str(), 0);\n}\n\nBerkeleyDatabase::~BerkeleyDatabase() {\n  if (env) {\n    LOCK(cs_db);\n    env->CloseDb(strFile);\n    assert(!m_db);\n    size_t erased = env->m_databases.erase(strFile);\n    assert(erased == 1);\n    env->m_fileids.erase(strFile);\n  }\n}\n\nBerkeleyBatch::BerkeleyBatch(BerkeleyDatabase &database,\n                             const bool read_only, bool fFlushOnCloseIn)\n    : pdb(nullptr), activeTxn(nullptr), m_cursor(nullptr),\n      m_database(database) {\n  database.AddRef();\n  database.Open();\n  fReadOnly = read_only;\n  fFlushOnClose = fFlushOnCloseIn;\n  env = database.env.get();\n  pdb = database.m_db.get();\n  strFile = database.strFile;\n  if (!Exists(std::string("version"))) {\n    bool fTmp = fReadOnly;\n    fReadOnly = false;\n    Write(std::string("version"), CLIENT_VERSION);\n    fReadOnly = fTmp;\n  }\n}\n\nvoid BerkeleyDatabase::Open() {\n  unsigned int nFlags = DB_THREAD | DB_CREATE;\n\n  {\n    LOCK(cs_db);\n    bilingual_str open_err;\n    if (!env->Open(open_err))\n      throw std::runtime_error(\n          "BerkeleyDatabase: Failed to open database environment.");\n\n    if (m_db == nullptr) {\n      int ret;\n      std::unique_ptr <Db> pdb_temp = std::make_unique<Db>(\n          env->dbenv.get(), 0);\n\n      bool fMockDb = env->IsMock();\n      if (fMockDb) {\n        DbMpoolFile *mpf = pdb_temp->get_mpf();\n        ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n        if (ret != 0) {\n          throw std::runtime_error(strprintf(\n              "BerkeleyDatabase: Failed to configure for no temp file backing fo\n              strFile));\n        }\n      }\n\n      ret = pdb_temp->open(\n          nullptr,                             // Txn pointer\n          fMockDb ? nullptr : strFile.c_str(),      // Filename\n          fMockDb ? strFile.c_str()\n                  : "main",       // Logical db name\n          DB_BTREE,                                 // Database type\n          nFlags,                                   // Flags\n          0);\n\n      if (ret != 0) {\n        throw std::runtime_error(strprintf(\n            "BerkeleyDatabase: Error %d, can\'t open database %s",\n            ret, strFile));\n      }\n\n      // Call CheckUniqueFileid on the containing BDB environment to\n      // avoid BDB data consistency bugs that happen when different data\n      // files in the same environment have the same fileid.\n      CheckUniqueFileid(*env, strFile, *pdb_temp,\n                        this->env->m_fileids[strFile]);\n\n      m_db.reset(pdb_temp.release());\n\n    }\n  }\n}\n\nvoid BerkeleyBatch::Flush() {\n  if (activeTxn)\n    return;\n\n  // Flush database activity from memory pool to disk log\n  unsigned int nMinutes = 0;\n  if (fReadOnly)\n    nMinutes = 1;\n\n  if (env) { // env is nullptr for dummy databases (i.e. in tests). Don\'t actual\n    env->dbenv->txn_checkpoint(\n        nMinutes ? m_database.m_max_log_mb * 1024 : 0, nMinutes, 0);\n  }\n}\n\nvoid BerkeleyDatabase::IncrementUpdateCounter() {\n  ++nUpdateCounter;\n}\n\nBerkeleyBatch::~BerkeleyBatch() {\n  Close();\n  m_database.RemoveRef();\n}\n\nvoid BerkeleyBatch::Close() {\n  if (!pdb)\n    return;\n  if (activeTxn)\n    activeTxn->abort();\n  activeTxn = nullptr;\n  pdb = nullptr;\n  CloseCursor();\n\n  if (fFlushOnClose)\n    Flush();\n}\n\nvoid BerkeleyEnvironment::CloseDb(const std::string &strFile) {\n  {\n    LOCK(cs_db);\n    auto it = m_databases.find(strFile);\n    assert(it != m_databases.end());\n    BerkeleyDatabase &database = it->second.get();\n    if (database.m_db) {\n      // Close the database handle\n      database.m_db->close(0);\n      database.m_db.reset();\n    }\n  }\n}\n\nvoid BerkeleyEnvironment::ReloadDbEnv() {\n  // Make sure that no Db\'s are in use\n  AssertLockNotHeld(cs_db);\n  std::unique_lock <RecursiveMutex> lock(cs_db);\n  m_db_in_use.wait(lock, [this]() {\n    for (auto &db : m_databases) {\n      if (db.second.get().m_refcount > 0) return false;\n    }\n    return true;\n  });\n\n  std::vector <std::string> filenames;\n  for (auto it : m_databases) {\n    filenames.push_back(it.first);\n  }\n  // Close the individual Db\'s\n  for (const std::string &filename : filenames) {\n    CloseDb(filename);\n  }\n  // Reset the environment\n  Flush(true); // This will flush and close the environment\n  Reset();\n  bilingual_str open_err;\n  Open(open_err);\n}\n\nbool BerkeleyDatabase::Rewrite(const char *pszSkip) {\n  while (true) {\n    {\n      LOCK(cs_db);\n      if (m_refcount <= 0) {\n        // Flush log data to the dat file\n        env->CloseDb(strFile);\n        env->CheckpointLSN(strFile);\n        m_refcount = -1;\n\n        bool fSuccess = true;\n        LogPrintf("BerkeleyBatch::Rewrite: Rewriting %s...\\n",\n                  strFile);\n        std::string strFileRes = strFile + ".rewrite";\n        { // surround usage of db with extra {}\n          BerkeleyBatch db(*this, true);\n          std::unique_ptr <Db> pdbCopy = std::make_unique<Db>(\n              env->dbenv.get(), 0);\n\n          int ret = pdbCopy->open(\n              nullptr,               // Txn pointer\n              strFileRes.c_str(), // Filename\n              "main",             // Logical db name\n              DB_BTREE,           // Database type\n              DB_CREATE,          // Flags\n              0);\n          if (ret > 0) {\n            LogPrintf(\n                "BerkeleyBatch::Rewrite: Can\'t create database file %s\\n",\n                strFileRes);\n            fSuccess = false;\n          }\n\n          if (db.StartCursor()) {\n            while (fSuccess) {\n              CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n              CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n              bool complete;\n              bool ret1 = db.ReadAtCursor(ssKey, ssValue,\n                                          complete);\n              if (complete) {\n                break;\n              } else if (!ret1) {\n                fSuccess = false;\n                break;\n              }\n              if (pszSkip &&\n                  strncmp((const char *) ssKey.data(),\n                          pszSkip, std::min(ssKey.size(),\n                                            strlen(pszSkip))) ==\n                  0)\n                continue;\n              if (strncmp((const char *) ssKey.data(),\n                          "\\x07version", 8) == 0) {\n                // Update version:\n                ssValue.clear();\n                ssValue << CLIENT_VERSION;\n              }\n              Dbt datKey(ssKey.data(), ssKey.size());\n              Dbt datValue(ssValue.data(), ssValue.size());\n              int ret2 = pdbCopy->put(nullptr, &datKey,\n                                      &datValue,\n                                      DB_NOOVERWRITE);\n              if (ret2 > 0)\n                fSuccess = false;\n            }\n            db.CloseCursor();\n          }\n          if (fSuccess) {\n            db.Close();\n            env->CloseDb(strFile);\n            if (pdbCopy->close(0))\n              fSuccess = false;\n          } else {\n            pdbCopy->close(0);\n          }\n        }\n        if (fSuccess) {\n          Db dbA(env->dbenv.get(), 0);\n          if (dbA.remove(strFile.c_str(), nullptr, 0))\n            fSuccess = false;\n          Db dbB(env->dbenv.get(), 0);\n          if (dbB.rename(strFileRes.c_str(), nullptr,\n                         strFile.c_str(), 0))\n            fSuccess = false;\n        }\n        if (!fSuccess)\n          LogPrintf(\n              "BerkeleyBatch::Rewrite: Failed to rewrite database file %s\\n",\n              strFileRes);\n        return fSuccess;\n      }\n    }\n    UninterruptibleSleep(std::chrono::milliseconds{100});\n  }\n}\n\n\nvoid BerkeleyEnvironment::Flush(bool fShutdown) {\n  int64_t nStart = GetTimeMillis();\n  // Flush log data to the actual data file on all files that are not in use\n  LogPrint(BCLog::WALLETDB,\n           "BerkeleyEnvironment::Flush: [%s] Flush(%s)%s\\n", strPath,\n           fShutdown ? "true" : "false",\n           fDbEnvInit ? "" : " database not started");\n  if (!fDbEnvInit)\n    return;\n  {\n    LOCK(cs_db);\n    bool no_dbs_accessed = true;\n    for (auto &db_it : m_databases) {\n      std::string strFile = db_it.first;\n      int nRefCount = db_it.second.get().m_refcount;\n      if (nRefCount < 0) continue;\n      LogPrint(BCLog::WALLETDB,\n               "BerkeleyEnvironment::Flush: Flushing %s (refcount = %d)...\\n",\n               strFile, nRefCount);\n      if (nRefCount == 0) {\n        // Move log data to the dat file\n        CloseDb(strFile);\n        LogPrint(BCLog::WALLETDB,\n                 "BerkeleyEnvironment::Flush: %s checkpoint\\n",\n                 strFile);\n        dbenv->txn_checkpoint(0, 0, 0);\n        LogPrint(BCLog::WALLETDB,\n                 "BerkeleyEnvironment::Flush: %s detach\\n",\n                 strFile);\n        if (!fMockDb)\n          dbenv->lsn_reset(strFile.c_str(), 0);\n        LogPrint(BCLog::WALLETDB,\n                 "BerkeleyEnvironment::Flush: %s closed\\n",\n                 strFile);\n        nRefCount = -1;\n      } else {\n        no_dbs_accessed = false;\n      }\n    }\n    LogPrint(BCLog::WALLETDB,\n             "BerkeleyEnvironment::Flush: Flush(%s)%s took %15dms\\n",\n             fShutdown ? "true" : "false",\n             fDbEnvInit ? "" : " database not started",\n             GetTimeMillis() - nStart);\n    if (fShutdown) {\n      char **listp;\n      if (no_dbs_accessed) {\n        dbenv->log_archive(&listp, DB_ARCH_REMOVE);\n        Close();\n        if (!fMockDb) {\n          fs::remove_all(\n              fs::PathFromString(strPath) / "database");\n        }\n      }\n    }\n  }\n}\n\nbool BerkeleyDatabase::PeriodicFlush() {\n  // Don\'t flush if we can\'t acquire the lock.\n  TRY_LOCK(cs_db, lockDb);\n  if (!lockDb) return false;\n\n  // Don\'t flush if any databases are in use\n  for (auto &it : env->m_databases) {\n    if (it.second.get().m_refcount > 0) return false;\n  }\n\n  // Don\'t flush if there haven\'t been any batch writes for this database.\n  if (m_refcount < 0) return false;\n\n  LogPrint(BCLog::WALLETDB, "Flushing %s\\n", strFile);\n  int64_t nStart = GetTimeMillis();\n\n  // Flush wallet file so it\'s self contained\n  env->CloseDb(strFile);\n  env->CheckpointLSN(strFile);\n  m_refcount = -1;\n\n  LogPrint(BCLog::WALLETDB, "Flushed %s %dms\\n", strFile,\n           GetTimeMillis() - nStart);\n\n  return true;\n}\n\nbool BerkeleyDatabase::Backup(const std::string &strDest) const {\n  while (true) {\n    {\n      LOCK(cs_db);\n      if (m_refcount <= 0) {\n        // Flush log data to the dat file\n        env->CloseDb(strFile);\n        env->CheckpointLSN(strFile);\n\n        // Copy wallet file\n        fs::path pathSrc = env->Directory() / strFile;\n        fs::path pathDest(fs::PathFromString(strDest));\n        if (fs::is_directory(pathDest))\n          pathDest /= fs::PathFromString(strFile);\n\n        try {\n          if (fs::exists(pathDest) &&\n              fs::equivalent(pathSrc, pathDest)) {\n            LogPrintf(\n                "cannot backup to wallet source file %s\\n",\n                fs::PathToString(pathDest));\n            return false;\n          }\n\n          fs::copy_file(pathSrc, pathDest,\n                        fs::copy_options::overwrite_existing);\n          LogPrintf("copied %s to %s\\n", strFile,\n                    fs::PathToString(pathDest));\n          return true;\n        } catch (const fs::filesystem_error &e) {\n          LogPrintf("error copying %s to %s - %s\\n", strFile,\n                    fs::PathToString(pathDest),\n                    fsbridge::get_filesystem_error_message(e));\n          return false;\n        }\n      }\n    }\n    UninterruptibleSleep(std::chrono::milliseconds{100});\n  }\n}\n\nvoid BerkeleyDatabase::Flush() {\n  env->Flush(false);\n}\n\nvoid BerkeleyDatabase::Close() {\n  env->Flush(true);\n}\n\nvoid BerkeleyDatabase::ReloadDbEnv() {\n  env->ReloadDbEnv();\n}\n\nbool BerkeleyBatch::StartCursor() {\n  assert(!m_cursor);\n  if (!pdb)\n    return false;\n  int ret = pdb->cursor(nullptr, &m_cursor, 0);\n  return ret == 0;\n}\n\nbool BerkeleyBatch::ReadAtCursor(CDataStream &ssKey, CDataStream &ssValue,\n                                 bool &complete) {\n  complete = false;\n  if (m_cursor == nullptr) return false;\n  // Read at cursor\n  SafeDbt datKey;\n  SafeDbt datValue;\n  int ret = m_cursor->get(datKey, datValue, DB_NEXT);\n  if (ret == DB_NOTFOUND) {\n    complete = true;\n  }\n  if (ret != 0)\n    return false;\n  else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n    return false;\n\n  // Convert to streams\n  ssKey.SetType(SER_DISK);\n  ssKey.clear();\n  ssKey.write({BytePtr(datKey.get_data()), datKey.get_size()});\n  ssValue.SetType(SER_DISK);\n  ssValue.clear();\n  ssValue.write({BytePtr(datValue.get_data()), datValue.get_size()});\n  return true;\n}\n\nvoid BerkeleyBatch::CloseCursor() {\n  if (!m_cursor) return;\n  m_cursor->close();\n  m_cursor = nullptr;\n}\n\nbool BerkeleyBatch::TxnBegin() {\n  if (!pdb || activeTxn)\n    return false;\n  DbTxn *ptxn = env->TxnBegin();\n  if (!ptxn)\n    return false;\n  activeTxn = ptxn;\n  return true;\n}\n\nbool BerkeleyBatch::TxnCommit() {\n  if (!pdb || !activeTxn)\n    return false;\n  int ret = activeTxn->commit(0);\n  activeTxn = nullptr;\n  return (ret == 0);\n}\n\nbool BerkeleyBatch::TxnAbort() {\n  if (!pdb || !activeTxn)\n    return false;\n  int ret = activeTxn->abort();\n  activeTxn = nullptr;\n  return (ret == 0);\n}\n\nbool BerkeleyDatabaseSanityCheck() {\n  int major, minor;\n  DbEnv::version(&major, &minor, nullptr);\n\n  /* If the major version differs, or the minor version of library is *older*\n   * than the header that was compiled against, flag an error.\n   */\n  if (major != DB_VERSION_MAJOR || minor < DB_VERSION_MINOR) {\n    LogPrintf(\n        "BerkeleyDB database version conflict: header version is %d.%d, library \n        DB_VERSION_MAJOR, DB_VERSION_MINOR, major, minor);\n    return false;\n  }\n\n  return true;\n}\n\nstd::string BerkeleyDatabaseVersion() {\n  return DbEnv::version(nullptr, nullptr, nullptr);\n}\n\nbool BerkeleyBatch::ReadKey(CDataStream &&key, CDataStream &value) {\n  if (!pdb)\n    return false;\n\n  SafeDbt datKey(key.data(), key.size());\n\n  SafeDbt datValue;\n  int ret = pdb->get(activeTxn, datKey, datValue, 0);\n  if (ret == 0 && datValue.get_data() != nullptr) {\n    value.write({BytePtr(datValue.get_data()), datValue.get_size()});\n    return true;\n  }\n  return false;\n}\n\nbool BerkeleyBatch::WriteKey(CDataStream &&key, CDataStream &&value,\n                             bool overwrite) {\n  if (!pdb)\n    return false;\n  if (fReadOnly)\n    assert(!"Write called on database in read-only mode");\n\n  SafeDbt datKey(key.data(), key.size());\n\n  SafeDbt datValue(value.data(), value.size());\n\n  int ret = pdb->put(activeTxn, datKey, datValue,\n                     (overwrite ? 0 : DB_NOOVERWRITE));\n  return (ret == 0);\n}\n\nbool BerkeleyBatch::EraseKey(CDataStream &&key) {\n  if (!pdb)\n    return false;\n  if (fReadOnly)\n    assert(!"Erase called on database in read-only mode");\n\n  SafeDbt datKey(key.data(), key.size());\n\n  int ret = pdb->del(activeTxn, datKey, 0);\n  return (ret == 0 || ret == DB_NOTFOUND);\n}\n\nbool BerkeleyBatch::HasKey(CDataStream &&key) {\n  if (!pdb)\n    return false;\n\n  SafeDbt datKey(key.data(), key.size());\n\n  int ret = pdb->exists(activeTxn, datKey, 0);\n  return ret == 0;\n}\n\nvoid BerkeleyDatabase::AddRef() {\n  LOCK(cs_db);\n  if (m_refcount < 0) {\n    m_refcount = 1;\n  } else {\n    m_refcount++;\n  }\n}\n\nvoid BerkeleyDatabase::RemoveRef() {\n  LOCK(cs_db);\n  m_refcount--;\n  if (env) env->m_db_in_use.notify_all();\n}\n\nstd::unique_ptr <DatabaseBatch>\nBerkeleyDatabase::MakeBatch(bool flush_on_close) {\n  return std::make_unique<BerkeleyBatch>(*this, false, flush_on_close);\n}\n\nstd::unique_ptr <BerkeleyDatabase>\nMakeBerkeleyDatabase(const fs::path &path, const DatabaseOptions &options,\n                     DatabaseStatus &status, bilingual_str &error) {\n  fs::path data_file = BDBDataFile(path);\n  std::unique_ptr <BerkeleyDatabase> db;\n  {\n    LOCK(\n        cs_db); // Lock env.m_databases until insert in BerkeleyDatabase constru\n    std::string data_filename = fs::PathToString(data_file.filename());\n    std::shared_ptr <BerkeleyEnvironment> env = GetBerkeleyEnv(\n        data_file.parent_path(), options.use_shared_memory);\n    if (env->m_databases.count(data_filename)) {\n      error = Untranslated(strprintf(\n          "Refusing to load database. Data file \'%s\' is already loaded.",\n          fs::PathToString(env->Directory() / data_filename)));\n      status = DatabaseStatus::FAILED_ALREADY_LOADED;\n      return nullptr;\n    }\n    db = std::make_unique<BerkeleyDatabase>(std::move(env),\n                                            std::move(data_filename),\n                                            options);\n  }\n\n  if (options.verify && !db->Verify(error)) {\n    status = DatabaseStatus::FAILED_VERIFY;\n    return nullptr;\n  }\n\n  status = DatabaseStatus::SUCCESS;\n  return db;\n}\n} // namespace wallet';

const bitcoin = {
  numCols: 81,
  get streams() {
    return [
      {
        get title() {
          delete this.title;
          const titles = ["Bitcoin - wallet.cpp", "Editor - CPP", "C++"];
          return (this.title = randomItemFromArray(titles));
        },

        get stream() {
          delete this.stream;
          return (this.stream = randomLineRepeatedString(stream));
        },

        get dt() {
          delete this.dt;
          return (this.dt = 81 * 5);
        },
      },
    ];
  },
};

export default bitcoin;
